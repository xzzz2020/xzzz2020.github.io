{"posts":[{"title":"美化JS生成随机颜色","content":"该代码应用到博客主题，展示地址：https://xzzz2020.gitee.io/tags/，如果有更好的优化思路，可以跟博主探讨探讨。生成随机颜色代码比较多，但是想要美化这个随机算法有点难。博主对此进行了一些相关测试，该测试结果因个人的审美会有较大的差距。基本优化思路是：如果固定一个颜色，再优化会更加简单，主要固定了一个是红色一个是蓝色（以绿为底，觉得很丑）剩下两个颜色不能过深或者过浅，所以进行了限定最后就是以红为底和以蓝为底的比例，就采用了经典黄金分割比&lt;script&gt;functiongetColor1(){//固定红色值varre=&quot;#&quot;;varcol=color();re+=col+&quot;FF&quot;;returnre}functiongetColor2(){//固定蓝色值varre=&quot;#FF&quot;;varcol=color();re+=col;returnre}functioncolor(){varre=&quot;&quot;;for(varxunhuan=0;xunhuan&lt;2;xunhuan++){vartemp=Math.floor(256*Math.random());if(temp&lt;130&amp;&amp;xunhuan==0){temp=130;}if(temp&gt;200&amp;&amp;xunhuan==1){temp=200;}temp=temp.toString(16);//将数值转换成16进制if(temp.length!==2){temp=&quot;0&quot;+temp}re+=temp//对颜色进行拼接}returnre;}varglobal_tags_random=5//这个是博主标签的按钮数目，这样让每个标签都有不同的颜色for(xunhuan=0;xunhuan&lt;=global_tags_random;xunhuan++){vartemp=document.getElementById(&quot;tag-&quot;+xunhuan.toString());varrandom=Math.random();if(random&lt;0.618){//分配红色和蓝色出现的比例temp.style.backgroundColor=getColor1()}else{temp.style.backgroundColor=getColor2()}}&lt;/script&gt;","link":"https://xzzz2020.github.io/post/ExM6FNFMM/"},{"title":"【面试题】进程、线程和死锁","content":"本文档为面试精华版，如果是初学者，建议从专栏学习：操作系统专栏1.聊聊进程和线程2.进程有几种状态？3.进程间的通信方式4.线程间的同步的⽅式有哪些呢?5.你知道操作系统中进程的调度算法有哪些吗?6.发生死锁的必要条件7.解决死锁的方式1.聊聊进程和线程进程进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。进程实体由程序段、相关数据段和PCB组成线程线程的提出源于在并发的时候，进程的切换需要消耗很大的时空开销，而线程的提出可以提高并发时系统的性能进程和线程的区别？拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。2.进程有几种状态？有五种状态：创建：进程正在被分配资源结束：当进程正常或者异常退出。就绪：进程已处于准备运⾏状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间⽚)即可运⾏执行：进程正在处理器上上运⾏阻塞：进程正在等待某⼀事件⽽暂停运⾏如等待某资源为可⽤或等待IO操作完成。即使处理器空闲，该进程也不能运⾏应该注意以下内容：只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态。3.进程间的通信方式大概有7种常见的进程间的通信⽅式：管道/匿名管道(Pipes)：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。有名管道(NamesPipes):克服了管道只能⽤于亲缘关系的进程间通信这个缺点，严格遵循先进先出(firstinfirstout)。有名管道以磁盘⽂件的⽅式存在，可以实现本机任意两个进程通信。信号(Signal)：信号是⼀种⽐较复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；消息队列(MessageQueuing)：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐FIFO更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字节流以及缓冲区大小受限等缺。信号量(Semaphores)：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。共享内存(Sharedmemory)：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。套接字(Sockets):此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持TCP/IP的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。4.线程间的同步的⽅式有哪些呢?线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统-般有下面三种线程同步的方式:互斥量(Mutex):采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为.互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。信号量(Semphares):它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量事件(Event):通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作5.你知道操作系统中进程的调度算法有哪些吗?不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。a.批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。先来先服务first-comefirst-serverd（FCFS）非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。短作业优先shortestjobfirst（SJF）非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。最短剩余时间优先shortestremainingtimenext（SRTN）最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。b.交互式系统交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。时间片轮转将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证优先级调度为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。多级反馈队列一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换7次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。6.发生死锁的必要条件互斥：每个资源要么已经分配给了一个进程，要么就是可用的。占有和等待：已经得到了某个资源的进程可以再请求新的资源。不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。7.解决死锁的方式主要有以下四种方法：鸵鸟策略：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。死锁检测与死锁恢复：检测主要是查看当前是否出现了环路等待；恢复可以通过杀死进程或者利用回滚死锁预防：在程序运行之前破坏发生死锁的条件，预防发生死锁，比如说破坏环路等待可以给资源统一编号，进程只能按编号顺序来请求资源。死锁避免：使用银行家算法，假设给进程分配资源，看能不能找到一个安全序列，如果系统处于不安全状态，不一定会发生死锁；但是死锁时，系统一定处于不安全状态","link":"https://xzzz2020.github.io/post/jURZ4BrJ2/"},{"title":"【面试题】操作系统基础","content":"本文档为面试精华版，如果是初学者，建议从专栏学习：操作系统专栏1.什么是操作系统？2.什么是用户态和系统态？什么是系统调用呢？3.操作系统的基本特征4.中断分类1.什么是操作系统？我通过以下四点向您介绍⼀下什么是操作系统吧：操作系统（OperatingSystem，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；操作系统本质上是运⾏在计算机上的软件程序；操作系统为⽤户提供⼀个与系统交互的操作界⾯；操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应⽤程序，⽽内核就是能操作硬件的程序）。关于内核多插⼀嘴：内核负责管理系统的进程、内存、设备驱动程序、⽂件和⽹络系统等等，决定着系统的性能和稳定性。是连接应⽤程序和硬件的桥梁。内核就是操作系统背后⿊盒的核⼼。2.什么是用户态和系统态？什么是系统调用呢？根据进程访问资源的特点，我们可以把进程在系统上的运⾏分为两个级别：⽤户态(usermode):⽤户态运⾏的进程或可以直接读取⽤户程序的数据，能执行部分指令。系统态(kernelmode):可以简单的理解系统态运⾏的进程或程序⼏乎可以访问计算机的任何资源，能执行全部的指令，不受限制。我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢?那就需要系统调用了!也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。这些系统调⽤按功能⼤致可分为如下⼏类：设备管理。完成设备的请求或释放，以及设备启动等功能。⽂件管理。完成⽂件的读、写、创建及删除等功能。进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。进程通信。完成进程之间的消息传递或信号传递等功能。内存管理。完成内存的分配、回收以及获取作业占⽤内存区⼤⼩及地址等功能。3.操作系统的基本特征并发：宏观上是一段时间内多个程序一起运行，而并行是同一时刻多个程序一起运行操作系统通过引入进程和线程，使得程序能够并发运行共享：系统中的资源可以被多个并发进程共同使用。虚拟：虚拟技术把一个物理实体转换为多个逻辑实体，主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换异步：异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。4.中断分类外中断：由CPU执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。异常：由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。陷入：在用户程序中使用系统调用","link":"https://xzzz2020.github.io/post/aArRF4IZF/"},{"title":"Java集合面试题总结","content":"一、主要容器概述二、List1.ArrayList2.LinkedList3.Vector4.ArrayList与LinkedList异同5.ArrayList和Vector的区别6.System.arraycopy()和Arrays.copyOf()三、Set1.哈希表2.HashSet3.hashCode()4.TreeSet四、Map1.HashMap2.HashTable3.LinkedHashMap五、Collections常用方法排序查找,替换操作同步控制设置不可变集合一、主要容器概述注意Collection是一个接口，是List和Set的公共接口，Collections是一个工具类Java容器主要有三个：List:是一个有序集合，可以放重复的数据Set:是一个无序集合，不允许放重复的数据Map:是一个无序集合，集合中包含一个键对象，-一个值对象，键对象不允许重复，值对象可以重复(身份证号-姓名)size，length，length()区别？size()是集合中使用，统计集合中元素的个数length是数组的一个成员属性length()是String的一个方法Iterator方法描述booleanhasNext()判断集合中是否还有下一个元素Objectnext()返回下一个元素voidremove()从集合中删除一个由next()方法返回的元素二、ListArrayList：查询数据比较快，添加和删除数据比较慢(基于可变数组)LinkedList：查询数据比较慢，添加和删除数据比较快（基于链表数据结构）1.ArrayList查找比较快，增删比较慢底层是基于数组。默认容量是10每次扩容1.5倍如果增加0.5倍后的新容量超过限制的容量，则用所需的最小容量与限制的容量进行判断，超过则指定为Integer的最大值通过数组的复制将原数据复制到一个更大(新的容量大小)的数组如何保证线程安全？继承ArrayList，重写其中的方法Listlist=Collections.synchronizedList(newArrayList());2.LinkedList增删比较快，查找比较慢基于链表的，除了存放数据，还需要存放指针，所以占用的空间会大一些它实现了Deque接口，使得LinkedList类也具有队列的特性不是线程安全的3.VectorVector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。4.ArrayList与LinkedList异同是否保证线程安全：ArrayList和LinkedList都是不同步的，也就是不保证线程安全；底层数据结构：Arraylist底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）；插入和删除是否受元素位置的影响：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行add(Ee)方法的时候，ArrayList会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置i插入和删除元素的话（add(intindex,Eelement)）时间复杂度就为O(n-i)。因为在进行上述操作的时候集合中第i和第i个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n）。是否支持快速随机访问：LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问就5.ArrayList和Vector的区别Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要保证线程安全时时建议使用ArrayList。【CopyOnWriteArrayList是同步的】。6.System.arraycopy()和Arrays.copyOf()arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置copyOf()是系统自动在内部新建一个数组，并返回该数组。三、Set在Set家族中，常用的有三种：HashSet:采用Hashmap的key来储存元素，主要特点是无序的，基本操作都是O(1)的时间复杂度，很快。LinkedHashSet:这个是一个HashSet+LinkedList的结构，特点就是既拥有了O(1)的时间复杂度，又能够保留插入的顺序。TreeSet:采用红黑树结构，特点是可以有序，可以用自然排序或者自定义比较器来排序；缺点就是查询速度没有HashSet快。1.哈希表哈希表是一种数据结构，哈希表能够提供快速存取操作。哈希表是基于数组的，所以也存在缺点，数组一旦创建将不能扩展。正常的数组，如果需要查询某个值，需要对数组进行遍历，只是一种线性查找，查找的速度比较慢。如果数组中的元素值和下标能够存在明确的对应关系，那么通过数组元素的值就可以换算出数据元素的下**标，通过下标就可以快数定位数组元素，这样的数组就是哈希表。**一张哈希表：元素值101112131415161718元素下标012345678以上我们的示例元素值和下标的关系为：元素下标=元素值-10，此时的示例hashcode就是和数组下标一致了,取得hashcode方法如下：//取得hashCodepubicinthashCode(intvalue){returnvalue–10;}2.HashSetHashSet中的数据是无序的不可重复的。采用Hashmap的key来储存元素3.hashCode()覆盖了equals和hashCode，当hashCode相同，它会调用equals进行比较，如果equals比较相等将不加把此元素加入到Set中但equals比较不相等会重新根据hashCode换算位置仍然会将该元素加入进去的。hashCode()与equals()的相关规定：如果两个对象相等，则hashcode一定也是相同的两个对象相等,对两个对象分别调用equals方法都返回true两个对象有相同的hashcode值，它们也不一定是相等的因此，equals方法被覆盖过，则hashCode方法也必须被覆盖hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）再次强调：特别是向HashSet或HashMap中加入数据时必须同时覆盖equals和hashCode方法，应该养成一种习惯覆盖equals的同时最好同时覆盖hashCodeJava要求：两个对象equals相等，那么它的hashcode相等两个对象equals不相等，那么它的hashcode并不要求它不相等，但一般建议不相等hashcode相等不代表两个对象相等（采用equals比较）为什么重写equals()就必须要重写hashCode()？当key的hashCode()计算的数值相同时，就会出现hash冲突处理hash冲突有哪些方法？Java中用的哪一种？为什么？另一种方法你在工作中用过吗？在什么情况下用得多？见：https://xzzz2020.gitee.io/post/d0otbdSTy4.TreeSetTreeSet可以对Set集合进行排序，默认自然排序（即升序）引用类型实现排序，需要实现Comparator或者ComparableComparable和Comparator的区别？Comparable是自然排序，需要实体类实现，需要修改源代码Comparator是定制排序，不需要更改源代码，定义一个比较规则，传递给需要调用的方法中，将比较策略与数据分离，体现了策略模式Comparator比Comparable优先级更高四、Map关于HashMap的全部面试题见：https://xzzz2020.gitee.io/post/hashmapMap中可以放置键值对，也就是每一个元素都包含键对象和值对象，Map实现较常用的为HashMap，HashMap对键对象的存取和HashSet一样，仍然采用的是哈希算法，所以如果使用自定类作为Map的键对象，必须复写equals和hashCode方法Map中常用的三个：HashMap:与HashSet对应，也是无序的，O(1)。LinkedHashMap:这是一个「HashMap+双向链表」的结构，落脚点是HashMap，所以既拥有HashMap的所有特性还能有顺序。TreeMap:是有序的，本质是用二叉搜索树来实现的。1.HashMap实现原理对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的Hash函数跟HashMap的容量有关系如果不同的元素的key算出了相同的哈希值，那么该怎么存放呢？这就是哈希碰撞，即多个key对应了同一个桶。HashMap中是如何保证元素的唯一性的呢？即相同的元素会不会算出不同的哈希值呢？通过hashCode()和equals()方法来保证元素的唯一性。2.HashTable是一个线程安全的，但是锁住了全部数据效率低下HashMap和Hashtable的区别?线程是否安全：HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。（如果你要保证线程安全的话就使用ConcurrentHashMap吧！）；效率：因为线程安全的问题，HashMap要比HashTable效率高一点。另外，HashTable基本被淘汰，不要在代码中使用它；对Nullkey和Nullvalue的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null。但是在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。初始容量大小和每次扩充容量大小的不同：①创建时如果不指定容量初始值，Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tableSizeFor()方法保证，下面给出了源代码）。也就是说HashMap总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。底层数据结构：JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable没有这样的机制。3.LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。五、Collections常用方法排序voidreverse(Listlist)//反转voidshuffle(Listlist)//随机排序voidsort(Listlist)//按自然排序的升序排序voidsort(Listlist,Comparatorc)//定制排序，由Comparator控制排序逻辑voidswap(Listlist,inti,intj)//交换两个索引位置的元素voidrotate(Listlist,intdistance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面。查找,替换操作intbinarySearch(Listlist,Objectkey)//对List进行二分查找，返回索引，注意List必须是有序的intmax(Collectioncoll)//根据元素的自然顺序，返回最大的元素。intmin(Collectioncoll)intmax(Collectioncoll,Comparatorc)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。intmin(Collectioncoll,Comparatorc)voidfill(Listlist,Objectobj)//用指定的元素代替指定list中所有元素。intfrequency(Collectionc,Objecto)//统计元素出现次数intindexOfSubList(Listlist,Listtarget)//统计target在list中第一次出现的索引，找不到则返回-1，intlastIndexOfSubList(Listsource,listtarget).booleanreplaceAll(Listlist,ObjectoldVal,ObjectnewVal),用新元素替换旧元素同步控制Collections提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。我们知道HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合synchronizedCollection(Collection&lt;T&gt;c)//返回指定collection支持的同步（线程安全的）collection。synchronizedList(List&lt;T&gt;list)//返回指定列表支持的同步（线程安全的）List。synchronizedMap(Map&lt;K,V&gt;m)//返回由指定映射支持的同步（线程安全的）Map。synchronizedSet(Set&lt;T&gt;s)//返回指定set支持的同步（线程安全的）set。设置不可变集合emptyXxx()：返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。singletonXxx()：返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。unmodifiableXxx()：返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本","link":"https://xzzz2020.github.io/post/D60cWKdQu/"},{"title":"解决Hash冲突的方法总结","content":"1.开放地址法当出现冲突时，di是产生冲突的时候的增量序列，则将冲突的元素进行移动：-di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.-di取值可能为1,-1,4,-4,9,-9,16,-16,…kk,-kk(k&lt;=m/2）称二次探测再散列。-di取值可能为伪随机数列。称伪随机探测再散列。2.多哈希法设计多种哈希函数，可以避免冲突，但是冲突几率还是有的，函数设计的越好或越多都可以将几率降到最低。3.拉链法（Java中采用的）利用一个额外的空间比如链表来保存冲突的元素，此法可以完全避免哈希函数的冲突。4.建立一个公共溢出区一旦发生冲突，都填入溢出表。","link":"https://xzzz2020.github.io/post/d0otbdSTy/"},{"title":"HashMap面试题总结","content":"HashMap简介问题集合问点一：你了解HashMap的底层数据结构吗？问点二：为什么JDK7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？问点六：聊一聊JDK7的HashMap中的“死锁”是怎么回事？问点七：HashMap是线程安全的吗？为什么安全或者不安全？问点八：什么HashMap的加载因子是0.75？为什么是超过“8”才用红黑树？问点九：HashMap、HashTable、ConcurrentHashMap的区别问点十：谈谈你理解的HashMap，讲讲其中的get和put过程由于HashMap在面试中是一个重点，内容十分多，需要单独写一篇文章总结HashMap在Jdk1.7与1.8之中有很大区别！！HashMap简介HashMap是用来存储数据的，它底层在JDK1.7是数组+链表实现的，而JDK1.8是使用数组+链表+红黑树实现，通过对key进行哈希计算等操作后得到数组下标，把value等信息存放在链表或红黑树存在此位置。如果两个不同的key运算后获取的数组下标一致，就出现了哈希冲突。数组默认长度是16，如果实际数组长度超过一定的值，就会进行扩容。问题集合问点一：你了解HashMap的底层数据结构吗？在JDK1.7使用的是数组+链表的实现，在JDK1.8中使用的是数组+链表+红黑树问点二：为什么JDK7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？JDK7使用数组+链表，是因为HashMap是根据Key计算Hash值，从而得到哈希表的索引下标，而哈希表本质是数组实现。当出现Hash冲突时，则一个桶可能需要存放多个数据。HashMap将会根据equals()方法，判断Hash冲突的Key是否是同一个值，此时如果仍然不相同，就会利用头插法，将出现Hash冲突的Key+Value存放在链表上。但是如果一个链表比较长，那么查询的效率将会降低，所以JDK8中又使用了红黑树来解决链表过长导致查询效率变差的问题，会在一个桶上链表长度为8时，进行树化。但是树化的时候，会判断当前的长度是否小于64，如果小于，则不进行树化，而是选择进行一次扩容，因为扩容的时候会使哈希表长度增加，hash值会重新计算，将重新打乱当前的元素排列，分配到新的空间上，这样也避免了链表过长。对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的。//key进行哈希计算inthash=hash(key);//获取数组下标inti=indexFor(hash,table.length);通过计算后的下标，从而得到数组的对应下标的位置，最后把k，v值存进去，同样的当再次第二次存值的时候，同样把k，v传进来，当k再次进行计算出数组下标index，有可能和第一次计算的index的值相同。但是，两次的需要存进去的value值是不同的，这就出现了同一个数组后面有一条链表，会比较链表上的每一个value值与当前的value是否相同，若是不相同，通过头插法，将数值插入链表中。如下图所示：接下来通通过源码进行分析，在jdk7插入的put方法源码如下：publicVput(Kkey,Vvalue){//数组为空就进行初始化if(table==EMPTY_TABLE){inflateTable(threshold);}if(key==null)returnputForNullKey(value);//key进行哈希计算inthash=hash(key);//获取数组下标inti=indexFor(hash,table.length);//如果此下标有值，遍历链表上的元素，key一致的话就替换value的值for(Entry&lt;K,V&gt;e=table[i];e!=null;e=e.next){Objectk;if(e.hash==hash&amp;&amp;((k=e.key)==key||key.equals(k))){VoldValue=e.value;e.value=value;e.recordAccess(this);returnoldValue;}}modCount++;//新增一个keyaddEntry(hash,key,value,i);returnnull;}put方法中主要做了以下几件事：判断table数组是否为空，若为空进行初始化table数组。判断key值是否为null，将null是作为key存进去。若key不为空，通过key计算出数组下标，判断table[i]是否为空。若是不为空通过链表循环，判断在链表中是否存在与该key相等，若是存在，直接将value替换成新的value。若是table[i]为空或者链表中不存在与之相同的key，就addEntry(hash,key,value,i)新增一个节点。接下来看看addEntry(hash,key,value,i)新增节点的源码如下：voidaddEntry(inthash,Kkey,Vvalue,intbucketIndex){//数组长度大于阈值且存在哈希冲突（即当前数组下标有元素），就将数组扩容至2倍if((size&gt;=threshold)&amp;&amp;(null!=table[bucketIndex])){resize(2*table.length);hash=(null!=key)?hash(key):0;bucketIndex=indexFor(hash,table.length);}createEntry(hash,key,value,bucketIndex);}这个方法很简单，直接就是判断当前数组的大小是否&gt;=threshold并且table[bucketIndex]是否为null。若成立扩容，然后rehash，重新得到新数组的下标值，最后createEntry(hash,key,value,bucketIndex)创建新节点。最后来看一下createEntry(hash,key,value,bucketIndex)创建新节点的源码如下：voidcreateEntry(inthash,Kkey,Vvalue,intbucketIndex){//此位置有元素，就在链表头部插入新元素（头插法）Entry&lt;K,V&gt;e=table[bucketIndex];table[bucketIndex]=newEntry&lt;&gt;(hash,key,value,e);size++;}在JDK7中，链表存储有一个缺点，就是当数据很多的时候，链表就会很长，每次查询都会遍历很长的链表。因此在JDK8中为了优化HashMap的查询效率，将内部的结构改为数组+链表+和红黑树，当一个哈希桶后面的链表长度&gt;8的时候，就会将链表转化为红黑树，红黑树是二分查找，提高了查询的效率。接下来通过JDK8的put源码分析如下：publicVput(Kkey,Vvalue){returnputVal(hash(key),key,value,false,true);}finalVputVal(inthash,Kkey,Vvalue,booleanonlyIfAbsent,booleanevict){Node&lt;K,V&gt;[]tab;Node&lt;K,V&gt;p;intn,i;//数组为空就初始化if((tab=table)==null||(n=tab.length)==0)n=(tab=resize()).length;//当前下标为空，就直接插入if((p=tab[i=(n-1)&amp;hash])==null)tab[i]=newNode(hash,key,value,null);else{Node&lt;K,V&gt;e;Kk;//key相同就覆盖原来的值if(p.hash==hash&amp;&amp;((k=p.key)==key||(key!=null&amp;&amp;key.equals(k))))e=p;//树节点插入数据elseif(pinstanceofTreeNode)e=((TreeNode&lt;K,V&gt;)p).putTreeVal(this,tab,hash,key,value);else{for(intbinCount=0;;++binCount){//链表，尾插法插入数据if((e=p.next)==null){p.next=newNode(hash,key,value,null);//链表长度超过8，就把链表转为红黑树if(binCount&gt;=TREEIFY_THRESHOLD-1)//-1for1sttreeifyBin(tab,hash);break;}//key相同就覆盖原来的值if(e.hash==hash&amp;&amp;((k=e.key)==key||(key!=null&amp;&amp;key.equals(k))))break;p=e;}}if(e!=null){//existingmappingforkeyVoldValue=e.value;if(!onlyIfAbsent||oldValue==null)e.value=value;afterNodeAccess(e);returnoldValue;}}++modCount;//数组长度大于阈值，就扩容if(++size&gt;threshold)resize();afterNodeInsertion(evict);returnnull;}通过分析源码，上面的方法主要做了以下几件事：判断当前桶是否为空，空的就需要初始化（resize中会判断是否进行初始化）。根据当前key的hashcode定位到具体的桶中并判断是否为空，为空表明没有Hash冲突就直接在当前位置创建一个新桶即可。如果当前桶有值（Hash冲突），那么就要比较当前桶中的key、key的hashcode与写入的key是否相等，相等就赋值给e。如果当前桶为红黑树，那就要按照红黑树的方式写入数据。如果是个链表，就需要将当前的key、value封装成一个新节点写入到当前桶的后面（形成链表）。接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。如果在遍历过程中找到key相同时直接退出遍历。如果e!=null就相当于存在相同的key,那就需要将值覆盖。最后判断是否需要进行扩容。继续看下treeifyBin的源码：finalvoidtreeifyBin(Node&lt;K,V&gt;[]tab,inthash){intn,index;Node&lt;K,V&gt;e;//链表转为红黑树时，若此时数组长度小于64，扩容数组if(tab==null||(n=tab.length)&lt;MIN_TREEIFY_CAPACITY)resize();elseif((e=tab[index=(n-1)&amp;hash])!=null){TreeNode&lt;K,V&gt;hd=null,tl=null;//链表转为树结构do{TreeNode&lt;K,V&gt;p=replacementTreeNode(e,null);if(tl==null)hd=p;else{p.prev=tl;tl.next=p;}tl=p;}while((e=e.next)!=null);if((tab[index]=hd)!=null)hd.treeify(tab);}}由此可以看到1.8中，数组有两种情况会发生扩容：一是超过阈值二是链表转为红黑树且数组元素小于64时由此在jdk1.8中，默认长度为16情况下，要么元素一直放在同一下标，链表转为红黑树且数组元素小于64时就会扩容，要么超过阈值12时才会扩容。依据上面的源码分析，在JDK1.8中put方法的执行的原理图如下问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？JDK1.7的扩容条件是数组长度大于阈值且存在哈希冲突，而JDK1.8扩容条件是数组长度大于阈值或链表转为红黑树且数组元素小于64时，源码中的体现如下所示：JDK1.7扩容源码：voidaddEntry(inthash,Kkey,Vvalue,intbucketIndex){//数组长度大于阈值且存在哈希冲突（即当前数组下标有元素），就将数组扩容至2倍if((size&gt;=threshold)&amp;&amp;(null!=table[bucketIndex])){resize(2*table.length);hash=(null!=key)?hash(key):0;bucketIndex=indexFor(hash,table.length);}createEntry(hash,key,value,bucketIndex);}JDK1.8扩容源码：//数组长度大于阈值，就扩容if(++size&gt;threshold)resize();//链表转为红黑树时，若此时数组长度小于64，扩容数组if(tab==null||(n=tab.length)&lt;MIN_TREEIFY_CAPACITY)resize();问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？JDK两个版本都可以。JDK1.7和1.8本质都是去寻找Hash值为0的那个桶，然后如果key为null，则直接替换值问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？在JDK7和JDK8中的做法是一样的，若是存入的key值一样，就会将原来的key所对应的value值直接替换掉问点六：聊一聊JDK7的HashMap中的“死锁”是怎么回事？首先JDK7采用的头插法，会有链表成环的问题，JDK采用的尾插法，不会有循环链表的问题。HashMap是线程不安全的，在HashMap的源码中并未对其操作进行同步执行，所以在并发访问的时候就会出现线程安全的问题。JDK7死锁出现在高并发的时候，此时两个线程都将对数据进行扩容，每次扩容的时候，会让链表翻转。transfer函数源码（transfer函数是resize扩容方法中调用的另一个方法）：voidtransfer(Entry[]newTable,booleanrehash){intnewCapacity=newTable.length;for(Entry&lt;K,V&gt;e:table){while(null!=e){Entry&lt;K,V&gt;next=e.next;---------------------(1)if(rehash){e.hash=null==e.key?0:hash(e.key);}inti=indexFor(e.hash,newCapacity);e.next=newTable[i];newTable[i]=e;e=next;}//while}}假设一个链表，A.next=B,B.next=null：正常情况下，新扩容的数组应该是位null，然后A.next=newTable[i]，则A.next=null，newTable[i]=A，B.next=newTable[i]，则B.next=A，newTable[i]=B如果两个线程同时转换，此时已然会执行A.next=newTable[i],则将A.next=null变成A.next=B，剩下过程一致，出现循环链表问点七：HashMap是线程安全的吗？为什么安全或者不安全？不是线程安全的，比如会在扩容的时候产生循环链表；在put的时候会覆盖别的线程的值问点八：什么HashMap的加载因子是0.75？为什么是超过“8”才用红黑树？因为HashMap底层的数据结构是哈希表，在插入数据的时候会出现hash冲突，而HashMap的解决方式是使用拉链法，即采用额外的空间来解决冲突。而选择加载因子是0.75主要跟数学上泊松分布有关系，选择的参数平均为0.5的泊松分布，计算出来当前加载因子是0.75，这更是空间与时间的一种选择折中。而超过8才使用红黑树，源于该泊松分布计算出来的，一个节点哈希冲突8次的概率极为的小，几乎为不可能时间，这也是一次空间与时间的折中。​//1个节点哈希冲突n次的概率0:0.606530661:0.303265332:0.075816333:0.012636064:0.001579525:0.000157956:0.000013167:0.000000948:0.00000006问点九：HashMap、HashTable、ConcurrentHashMap的区别HashMap是线程不安全的，在jdk1.7高并发的时候，可能会在扩容的时候，产生循环链表，所以在高并发的时候，不去使用。HashTable是一个线程安全的，采用的是synchronize的方式，关键字加在方法上，即对当前HashTable对象加锁，会导致所有的数据加上锁。ConcurrentHashMap在JDK1.7的时候使用的是Segment分段锁的思想，将数据分成段，每个段都有个可重入锁，则多线程的时候不会影响到其他线程访问其他段的数据。ConcurrentHashMap在JDK1.8的时候使用的是CAS+synchronized方式，抛弃了Segment分段锁的思想，CAS是一个乐观锁，则在不加锁情况下实现赋值，在当前节点为空的时候，会采用CAS的方式添加节点；而用synchronized而不用是可重入锁的原因是因为官方对synchronized做了很多优化。HashTable其中使用synchronize来保证线程安全，即当有一个线程拥有锁的时候，其他的线程都会进入阻塞或者轮询状态,这样会使得效率越来越低。而ConcurrentHashMapMap的锁分段技术可以有效的提高并发访问率，HashTable访问效率低下的原因，就是因为所有的线程在竞争同一把锁。如果容器中有多把锁，不同的锁锁定不同的位置，这样线程间就不会存在锁的竞争，这样就可以有效的提高并发访问效率,这就是ConcurrentHashMap所使用的锁分段技术将数据一段一段的存储，为每一段都配一把锁，当一个线程只是占用其中的一个数据段时,其他段的数据也能被其他线程访问。在JDK1.7中currentHashMap采用的是Segment分段锁的思想方式实现：Segment是将数据分成段，默认是16，每个段都有一把锁，则理论最高支持16个线程并发JDK1.8的currentHashMap采用的是**数组+链表+红黑树，抛弃了原有的Segment分段锁，而采用了CAS+synchronized**方式实现：CAS，是一个乐观锁，他主要思想是比较然后再执行操作，比较的是内存的值和预期的原值是否一致，如果不一致，则需要自旋获取新值，但是CAS的最大问题就是可能出现ABA的问题。在nolockwhenaddingtoemptybin，也就是桶为空的时候采用CAS方式添加数据，而不为空的时候采用synchronized的方式问点十：谈谈你理解的HashMap，讲讲其中的get和put过程put方法：考虑是否要初始化根据key计算哈希值，找到hash表对应的索引然后判断是否出现的hash冲突，如果没有则直接插入，查看是否需要扩容JDK1.7出现hash冲突直接插入链表中即可JDK1.8出现hash冲突，需要先判断当前是红黑树还是链表，对于链表可能会有一个树化的过程get方法：思路与上面一致，只是少了一个扩容和树化的过程","link":"https://xzzz2020.github.io/post/hashmap/"},{"title":"JavaSE基础知识面试考点总结","content":"一、概述1.JDK版本2.Java语言特性3.Java的加载与执行过程4.JVM、JDK和JRE的区别二、Java语言基础1.八种基本类型2.字符编码3.类型转换4.运算符5.控制语句6.方法三、面向对象1.面向过程与面向对象的区别2.面向对象特征封装继承多态抽象3.参数传递4.关键字this关键字：super关键字static关键字final关键字5.代码块静态代码块实例语句块6.类的继承7.static、构造方法和父子类的调用顺序8.抽象类和接口（***）抽象类接口9.类之间的关系10.Object类equalsfinalize11.访问控制权限12内部类实例内部类静态内部类局部内部类匿名内部类四、异常1.异常的体系2.说出几个常见的异常3.异常处理该文章是博主采集于各大博文，用于复习和总结相关知识点，将会持续的收集和更新。一、概述1.JDK版本目前只维护两个JDK版本，一个是8，一个是11（2018年）2.Java语言特性可移植性，跨平台，因为Java有一个JVM虚拟机，虚拟机负责执行字节码文件健壮性，具有GC，有自动垃圾回收机制3.Java的加载与执行过程T.java（源文件）通过javac命令变成字节码文件字节码文件通过类加载器加载到JVM中JVM屏蔽了和操作系统打交道的操作4.JVM、JDK和JRE的区别Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”的关键所在。JDK是JavaDevelopmentKit，它是功能齐全的JavaSDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。JRE是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。二、Java语言基础1.八种基本类型八种基本数据类型：byte、short、int、long、float、double、boolean、char。一个字节等于8位IEE754标准（32位）：1位是符号位，8位是阶码用移码表示，23位尾数2.字符编码类型可以存放一个汉字，java中的char使用utf-16编码编码名称解释ASCII字符编码只支持英文字母、标点符号、数字字符等，ASCII码占用1个字节，所以ASCII码最多可以表示256个字符.小a97大A65,’0’是48ISO-8859-1有称latin-1,是国际化标准或组织ISO制定的，主要为了西欧语言中的字符编码，和ASCII兼容，仍不支持中文GB2312/GBK/GB18030主要是汉字编码，三种编码从容量上看是包含关系简体中文：GBK&lt;GB2312&lt;GB18030繁体中文：Big5【大五码】unicodeUnicode统一了全世界上的所有文字编码，unicode有几种实现：UTF-8,UTF-16,UTF-32java语言采用的是Unicode编码，所以在java中标识符也可以使用中文3.类型转换在java中基本类型可以相互转换，boolean类型比较特殊不可以转换成其他类型转换分为默认转换和强制转换:默认转换：容量小的类型会默认转换为容量大的类型byte--&gt;short--&gt;int--&gt;long--&gt;float--&gt;doublebyte、short、char之间计算不会互相转换，首先先转换成int强制转换：将容量大的类型转换成容量小的类型，需要进行强制转换注意：只要不超出范围可以将整型值直接赋值给byte，short，char在多种类型混合运算过程中，首先先将所有数据转换成容量最大的那种，再运算publicclassDataTypeTest08{publicstaticvoidmain(String[]args){longx=100L;inty=x;//编译不通过longa=2147483648L;intb=(int)a;System.out.println(b);//出现精度丢失问题，大类型--&gt;&gt;小类型会出现问题，输出-2147483648bytea=1000;//出现错误，1000超出了byte的范围longg=10;inth=g/3;//出现错误，多个数值在运算过程中，会转换成容量最大的类型byteh3=(byte)(int)g/3;//考察优先级，将g先转换成int，再强转成byte，再除以3得到int，赋值错误byteh4=(byte)(int)(g/3);//正确的byteh5=(byte)g/3;//考察优先级，先转换成byte，再运算byteh6=(byte)(g/3);//正确shorth7=(short)(g/3);//正确shorti=10;bytej=5;shortk=i+j;//错误的，short和byte运算，首先会转换成int再运算}}4.运算符短路与和逻辑与的区别？短路与比逻辑与智能，短路与效率高。短路或和逻辑或的区别？短路或：左边的算子结果是true，右边的表达式不执行，发生短路a+=3和a=a+3;是一样的吗？结论(重点)：扩展赋值运算符不改变运算结果的类型。初始类型和最终运算结果类型完全相同。publicclassOperatorTest09{publicstaticvoidmain(String[]args){byteb=10;//编译错误//b=b+3;//修改b=(byte)(b+3);System.out.println(b);//13b+=3;System.out.println(b);//16b+=10000;//等同于b=(byte)(b+10000);System.out.println(b);//32}}5.控制语句switch语句switch也称为多重分支，具体格式如下switch(表达式){case值1：语句break;case值2：语句break;default：语句Break;}说明：表达式的值只能为：char、byte、short、int类型（JDK7以后支持String），boolean、long、float、double都是非法的break语句可以省略,但会出现switch穿透default语句也可以省略，一般不建议省略，并且放置在最后需求：假定系统给定学生的考试成绩，考试成绩可以带有小数。假定成绩是合法的[0-100]，请根据学生考试成绩判断该学生成绩等级：[90-100]A[80-90)B[70-80)C[60-70)D[0-60)E以上业务只能使用switch语句完成，不允许使用if语句。publicclassSwitchTest04{publicstaticvoidmain(String[]args){//考试成绩合法doublescore=100;//开始判断intgrade=(int)(score/10);//case条件不能为浮点数switch(grade){case10:System.out.println(&quot;A&quot;);break;case9:System.out.println(&quot;A&quot;);break;case8:System.out.println(&quot;B&quot;);break;case7:System.out.println(&quot;C&quot;);break;case6:System.out.println(&quot;D&quot;);break;default:System.out.println(&quot;E&quot;);}//重点：case是可以合并的switch(grade){case10:case9:System.out.println(&quot;A&quot;);break;case8:System.out.println(&quot;B&quot;);break;case7:System.out.println(&quot;C&quot;);break;case6:System.out.println(&quot;D&quot;);break;default:System.out.println(&quot;E&quot;);}}}for语句for(;false;){//会出现编译错误，因为无法访问System.out.println(&quot;呵呵&quot;);}for(;true;){//死循环System.out.println(&quot;哈哈&quot;);}6.方法方法的返回值问题：publicclassMethodTest07{//缺少返回语句，程序编译时无法判断是否能走到else，无法编译通过publicstaticintm1(){booleanflag=true;if(flag){return1;}}//正确publicstaticintm2(){booleanflag=true;if(flag){return1;}else{return0;}}//编译错误publicstaticintm3(){booleanflag=false;if(flag){//return1;//return后不能接任何语句System.out.println(&quot;??????????&quot;);}System.out.println(&quot;??????????&quot;);return0;System.out.println(&quot;??????????&quot;);}}三、面向对象1.面向过程与面向对象的区别面向过程：面向过程性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。2.面向对象特征封装封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。关于继承如下3点请记住：子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。（以后介绍）。多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。抽象抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。3.参数传递所有基本数据类型的都是值传递，其他类型的为址传递4.关键字this关键字：this关键字指的是当前调用的对象，只能用在构造函数和实例方法内部，还可以应用在成员变量的声明上，static标识的方法里是不能使用this的。作用：代码复用。super关键字调用父类的构造方法没有显示地调用super();父类的无参构造方法也执行必须将super放到子类的构造函数的第一语句来调用父类的构造方法调用父类的成员方法需要注意：super只能应用在成员方法和构造方法中，不能应用在静态方法中（和this是一样的），如果在构造方法中使用必须放在第一行为什么会有super关键字？因为子类必须要调用父类的构造方法，先把父类构造完成，因为子类依赖于父类，没有父，也就没有子有时需要在子类中显示的调用父类的成员方法那么我们以前为什么没有看到super，而且我们也有继承，如：Student继承了Person？因为子类中我们没有显示的调用父类构造方法，那么他会默认调用父类的无参构造方法，此种情况下如果父类中没有无参构造方法，那么编译时将会失败注意构造方法不存在覆盖的概念，构造方法可以重载static关键字可以用来修饰它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。final关键字final表示不可改变的含义采用final修饰的类不能被继承采用final修饰的方法不能被覆盖采用final修饰的变量不能被修改final修饰的变量必须显示初始化局部变量：一旦赋值不能重新赋值成员变量：不能采用系统默认值，必须手动赋值如果修饰的引用，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的构造方法不能被final修饰会影响JAVA类的初始化:final定义的静态常量调用时不会执行static代码块等相关语句，这是由java虚拟机规定的。我们不需要了解的很深，有个概念就可以了修饰引用变量：final修饰引用变量，主要修饰的是变量的地址，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的publicclassFinalTest05{publicstaticvoidmain(String[]args){Personp1=newPerson();//可以赋值p1.name=&quot;张三&quot;;System.out.println(p1.name);finalPersonp2=newPerson();p2.name=&quot;李四&quot;;System.out.println(p2.name);//不能编译通过//p2采用final修饰，主要限制了p2指向堆区中的地址不能修改(也就是p2只能指向一个对象)//p2指向的对象的属性是可以修改的p2=newPerson();}}classPerson{Stringname;}final和static联合修饰实例变量==常量（尽量使用一个静态工具类抽取出常量）常量名要求全部大写[规范]常量都是publicstaticfinal的常量在类加载的时候完成初始化，存储在JVM的方法区中常量是值不可改变的变量5.代码块静态属性和静态代码块按照代码顺序执行，实例代码块和成员属性同理静态代码块使用static关键字可以定义静态语句块，静态语句块具有以下特点：静态语句块在类加载时执行，在main方法执行之前就已经执行了。类只加载一次，所以静态语句块也是只执行一次一个类中可以编写多个静态语句块，执行顺序是：自上而下依次执行。静态语句块的使用时机：当程序需要在类加载的时候就做一些事情，可以在静态语句块中来实现实例语句块实例语句块和静态代码块没有关系，实例语句块有以下特点：实例语句块在构造方法执行之前执行，构造函数执行一次，实例语句块对应执行一次。每调用一次构造函数之前就会执行一次实例语句块实例语句块可以编写多个，也是按照自上而下的顺序依次执行。实例语句块使用时机：当程序需要在对象初始化时刻就做一些事情，可以在实例语句块中实现//静态语句块static{System.out.println(1);}//实例语句块{System.out.println(1);}6.类的继承如何实现Java多继承？继承特征：继承是面向对象的重要概念，软件中的继承和现实中的继承概念是一样的继承是实现软件可重用性的重要手段，如：A继承B，A就拥有了B的所有特性，如现实世界中的儿子继承父亲的财产，儿子不用努力就有了财产，这就是重用性Java中只支持类的单继承，也就是说A只能继承B，A不能同时继承CJava中的继承使用extends关键字，语法格式：[修饰符]class子类extends父类{}方法的重载的条件方法名相同方法的参数类型，个数，顺序至少有一个不同方法的返回类型可以不同（不依靠返回类型来区分重载）方法的修饰符可以不同，因为方法重载和修饰符没有任何关系方法重载只出现在同一个类中方法的覆盖(Override)的条件：必须要有继承关系覆盖只能出现在子类中，如果没有继承关系，不存在覆盖，只存在重载在子类中被覆盖的方法，必须和父类中的方法完全一样，也就是方法名，返回类型、参数列表，完全一样子类方法的访问权限不能小于父类方法的访问权限子类方法不能抛出比父类方法更多的异常，但可以抛出父类方法异常的子异常父类的静态方法不能被子类覆盖父类的私有方法不能覆盖覆盖是针对成员方法，而非属性为什么需要覆盖？就是要改变父类的行为。方法重写之后，“子类对象”执行的一定是重写之后的方法，也体现了就近原则7.static、构造方法和父子类的调用顺序要点：静态的代码块一定比构造方法先执行如果都是静态代码，一个类里面，按照先后顺序执行，父子之间，父类静态代码块先执行静态代码只会执行一次，多次new新的对象，构造方法，非静态代码块会多次执行classParent{static{System.out.println(&quot;父类的静态块&quot;);}privatestaticStringstaticStr=getStaticStr();privateStringstr=getStr();{System.out.println(&quot;父类的实例块&quot;);}publicParent(){System.out.println(&quot;父类的构造方法&quot;);}privatestaticStringgetStaticStr(){System.out.println(&quot;父类的静态属性初始化&quot;);returnnull;}privateStringgetStr(){System.out.println(&quot;父类的实例属性初始化&quot;);returnnull;}}classChildextendsParent{privatestaticStringstaticStr=getStaticStr();static{System.out.println(&quot;子类的静态块&quot;);}{System.out.println(&quot;子类的实例块&quot;);}publicChild(){System.out.println(&quot;子类的构造方法&quot;);}privateStringstr=getStr();privatestaticStringgetStaticStr(){System.out.println(&quot;子类的静态属性初始化&quot;);returnnull;}privateStringgetStr(){System.out.println(&quot;子类的实例属性初始化&quot;);returnnull;}}publicclassTest{publicstaticvoidmain(String[]args){newChild();}}分析：首先先加载类到JVM的方法区中，则先加载静态的内容，比如静态代码块和静态属性，并且先加载父类，且按照代码顺序加载接着加载对象到堆内存中，先加载父类的实例语句块和实例属性，按照父类优先，根据代码顺序加载，最后加载构造方法执行结果：父类的静态块父类的静态属性初始化子类的静态属性初始化子类的静态块父类的实例属性初始化父类的实例块父类的构造方法子类的实例块子类的实例属性初始化子类的构造方法8.抽象类和接口（***）抽象类看我们以前示例中的Person、Student和Employee，从我们使用的角度来看主要对Student和Employee进行实例化，Person中主要包含了一些公共的属性和方法，而Person我们通常不会实例化，所以我们可以把它定义成抽象的：在java中采用abstract关键字定义的类就是抽象类，采用abstract关键字定义的方法就是抽象方法抽象的方法只需在抽象类中，提供声明，不需要实现如果一个类中含有抽象方法，那么这个类必须定义成抽象类，一个抽象类不一定含有抽象方法如果这个类是抽象的，那么这个类被子类继承，抽象方法必须被重写。如果在子类中不复写该抽象方法，那么必须将此类再次声明为抽象类抽象的类是不能实例化的，就像现实世界中人其实是抽象的，张三、李四才是具体的抽象类不能被final修饰抽象方法不能被final修饰，因为抽象方法就是被子类实现的抽象类中可以包含方法实现，可以将一些公共的代码放到抽象类中，另外在抽象类中可以定义一些抽象的方法，这样就会存在一个约束，而子类必须实现我们定义的方法，如：teacher必须实现printInfo方法，Student也必须实现printInfo方法，方法名称不能修改，必须为printInfo，这样就能实现多态的机制，有了多态的机制，我们在运行期就可以动态的调用子类的方法。所以在运行期可以灵活的互换实现。抽象类和普通类的区别？抽象类普通类不能被实例化，也就是使用new关键字可以被实例化权限限定于Public和Protected，因为需要子类去继承抽象类JDK1.8以前，抽象类的方法默认访问权限为protectedJDK1.8时，抽象类的方法默认访问权限变为default没有权限限制如果一个类继承抽象类，则必须实现抽象类的抽象方法如果没有实现抽象方法，则该类必须定义成抽象类不强制实现父类的方法接口注：JDK1.8以后，接口里可以有静态方法和方法体了。接口我们可以看作是抽象类的一种特殊情况，在接口中只能定义抽象的方法和常量(完全抽象)接口中的方法默认都是publicabstract的(可以省略写)，不能更改接口中的变量默认都是publicstaticfinal的(省略不写)，不能更改，所以必须显示的初始化注意：接口里的所有数据都是public修饰的！如果一个非抽象的类实现了接口，那么接口中所有的方法必须实现一类可以实现多个接口，接口和接口之间支持也是多继承的,但接口之间不能实现在java中接口其实描述了类需要做的事情，类要遵循接口的定义来做事，使用接口到底有什么本质的好处？可以归纳为两点：采用接口明确的声明了它所能提供的服务解决了Java单继承的问题接口和抽象类的区别？接口抽象类不能被实例化不能被实例化需要被子类实现，并实现接口的方法需要被子类继承，并实现抽象方法只能做方法的声明（JDK1.8之后允许方法体）可以做方法的声明，也可以做方法的实现如果子类不能实现接口中的所有方法，则该类只能是抽象类如果子类不能实现抽象类的所有抽象，则该类只能是抽象类属性只能是静态的常量没有限制接口与接口之间可以多继承只能单继承9.类之间的关系泛化关系类与类之间的继承以及接口与接口之间的继承实现关系类对接口的实现关联关系一个类中属性是另个类publicclass学生{private班级班级;//getter/setter}publicclass班级{}聚合关系是关联关系的一种，有着较强的关联关系在java中一个类是整体，使用对象数组包含另个类；另个类属于某个整体publicclass汽车{private轮胎集合轮胎；//getter/setter}publicclass轮胎{private汽车汽车;//getter/setter}依赖关系依赖关系是比关联关系弱的关系，在java语言中体现为返回值，参数，局部变量和静态方法调用publicclassTest{publicstaticvoidmain(String[]args){Personperson=newPerson();}}classPerson{}10.Object类Object类是所有Java类的根基类如果在类的声明中未使用extends关键字指明其基类，则默认基类为Object类equalsequals的源码是这样写的：publicbooleanequals(Objectobj){//this-s1//obj-s2return(this==obj);}所以，默认情况下比较的是地址值，但是可以让我们覆写该方法，实现对象的比较。如何覆写equals方法？首先为了提高效率，需要用==判断是否是同一个对象，如果是直接返回true接着为了提高健壮性，判断是否对象是否是该类的一个对象，如果是，需要对其向下转型最后是比较的逻辑publicclassObjectDemo{publicstaticvoidmain(Stringargs[]){Studentstudent1=newStudent(&quot;生命壹号&quot;,22,&quot;成都&quot;);Studentstudent2=newStudent(&quot;生命壹号&quot;,22,&quot;成都&quot;);System.out.println(student1==student2);System.out.println(student1.equals(student2));}}classStudent{privateStringname;privateintage;privateStringaddress;publicStudent(Stringname,intage,Stringaddress){this.name=name;this.age=age;this.address=address;}//重写Object类中的equals方法（比较两个对象的值是否相等）publicbooleanequals(Objectobj){//为了提高效率：如果两个内存地址相等，那么一定是指向同一个对内存中的对象，就无需比较两个对象的属性值（自己跟自己比，没啥意义嘛）if(this==obj){returntrue;}//为了提供程序的健壮性//我先判断一下，obj是不是学生的一个对象，如果是，再做向下转型，如果不是，直接返回false。//这个时候，我们要判断的是对象是否是某个类的对象?//记住一个格式：对象名instanceof类名。表示：判断该对象是否是该类的一个对象if(!(objinstanceofStudent)){returnfalse;}//如果是就继续Students=(Student)obj;//强制转换，即向下转型（毕竟Object类型没有具体的对象属性）returnthis.name.equals(s.name)&amp;&amp;this.age==s.age&amp;&amp;this.address.equals(s.address);//判断两个对象的属性值是否相等}}==与equals()区别？==equals()等号比较的是值，特别是比较引用类型，比较的是引用的内存地址的那个值默认源码使用的是==，但是可以通过覆写该方法，实现对象的比较对于基本数据的包装类型（Byte,Short,Character，Integer，Float,Double，Long,Boolean）除了Float和Double之外，其他的六种都是实现了常量池的，因此对于这些数据类型而言，一般我们也可以直接通过==来判断是否相等publicclassTest{publicstaticvoidmain(String[]args){Integera=127;Integerb=127;System.out.println(a==b);//trueIntegerc=128;Integerd=128;System.out.println(c==d);//false}}因为Integer在常量池中的存储范围为[-128,127]，127在这范围内，因此是直接存储于常量池的，而128不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以m，n分别指向了两个不同的对象地址，故而导致了不相等。finalize当垃圾收集器将要收集某个垃圾对象时将会调用finalize，建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行JVM当看到对象类含有finalize函数，会将该对象交给FinalizerThread处理，但是处理的时间不确定。11.访问控制权限范围由大到小的排序：public&gt;protected&gt;缺省&gt;private对类的修饰只有public和缺省，内部类除外修饰符类的内部同一个包中子类任何地方publicYYYYprotectedYYYN缺省YYNNprivateYNNN总结为一句话：private修饰的只能类的内部调用；缺省的可以在一个包中调用；protected扩展到了子类中，比如继承某个类，则可以使用那个类的属性和方法；public可以在任何地方访问。12内部类分为四种内部类：实例内部类：在类的内部定义的普通类静态内部类：在类的内部定义的静态类局部内部类：在方法中定义的普通类匿名内部类：方法使用中定义的普通类，主要用来实现接口实例内部类特点：创建实例内部类，外部类的实例必须已经创建实例内部类会持有外部类的引用，可以直接访问外部类的属性不允许有静态声明publicclassOuterClass{//静态变量privatestaticStrings1=&quot;静态变量&quot;;//实例变量privateStrings2=&quot;实例变量&quot;;//实例内部类publicclassInnerClass{//编译错误，实例内部类中不允许有静态的声明publicstaticvoidm1(){}//实例方法publicvoidm2(){System.out.println(s1);System.out.println(s2);}}//入口publicstaticvoidmain(String[]args){OuterClassoc=newOuterClass();InnerClassinnerClass=oc.newInnerClass();//??innerClass.m2();}}静态内部类特点：静态内部类不会持有外部的类的引用创建时可以不用创建外部类，在静态内部类中只能直接访问外部类中所有的静态数据。静态内部类等同于静态变量publicclassOuterClass{//静态变量privatestaticStrings1=&quot;静态变量&quot;;//实例变量privateStrings2=&quot;实例变量&quot;;//静态内部类//静态内部类可以使用任何一个访问控制权限修饰符修饰。protectedstaticclassInnerClass{//静态方法publicstaticvoidm1(){System.out.println(s1);//System.out.println(s2);}//实例方法publicvoidm2(){System.out.println(s1);//System.out.println(s2);}}//入口publicstaticvoidmain(String[]args){OuterClass.InnerClass.m1();//外部类.可以省略InnerClassinnerClass=newOuterClass.InnerClass();innerClass.m2();}}局部内部类局部内部类等同于局部变量局部内部类是在方法体中声明的类，该类只能在方法体中使用局部内部类不能使用public、protected、private修饰局部内部类访问本地变量的时候，方法中的参数需要使用final修饰publicclassOuterClass{privateinta=100;//局部变量在内部类中使用必须采用final修饰publicvoidmethod1(finalinttemp){classInner3{inti1=10;//可以访问外部类的成员变量inti2=a;inti3=temp;}//使用内部类Inner3inner3=newInner3();System.out.println(inner3.i1);System.out.println(inner3.i3);}publicstaticvoidmain(String[]args){OuterClassout=newOuterClass();out.method1(300);}}匿名内部类是一种特殊的内部类，该类没有名字通过new关键字创建，并加上方法体主要用于实现接口publicclassTest{publicstaticvoidmain(String[]args){//在方法中实现接口newThread(newRunnable(){@Overridepublicvoidrun(){}}).run();}}四、异常任意的异常都是在运行时发生的！！！1.异常的体系所有的异常都是Throwable的子类Thorwable有两个直接子类Error和ExceptionError:在Java中只要Error发生了就一种结果——退出JVM，例如StackOverErrorException的直接子类：Exception的直接子类叫做编译时异常、受控异常、检查异常。它虽然叫做编译时异常，但是它不是发生在编译阶段的异常，之所以叫做编译时异常是因为编译时异常要求必须在程序编译的阶段就手动的处理，如果不处理这些异常的话，程序无法编译通过。对于编译时异常有两种手段处理，一是trycatch捕获，一是throws抛出RuntimeException的直接子类：RuntimeException的直接子类叫做运行时异常、非受控异常、非检查异常。这种异常不要求在程序编译阶段处理，编译也可以通过比如说除0异常自定义异常：JDK提供的异常不能够满足要求的情况下用户可以自己自定义异常，可以根据实际情况选择继承Exception或者RuntimeException两种形式。2.说出几个常见的异常ErrorStackOverError（堆溢出）OutOfMemoryError（内存溢出）受控异常IOException（IO异常）SQLException（SQL异常）ClassNotFoundException（找不到指定的类异常）不受控异常NullPointerException（空指针异常）ArithmeticException（算术异常）ArrayIndexOutOfBoundsException（数组下表越界异常）3.异常处理异常的捕获应该从小到大一般有两种方式try...catch...finally....thorws抛给调用者finally在任何情况下都会执行，除非JVM挂掉，通常在finally里关闭资源publicclassExceptionTest12{publicstaticvoidmain(String[]args){intr=method1();//输出为：100？50？System.out.println(r);//输出是50}privatestaticintmethod1(){inta=10;try{a=50;returna;//直接返回值}finally{a=100;//该语句也会执行，只是a已经返回}}}throws和throw的区别？throwsthrowthorws是声明异常thorws是声明异常用在函数上用在函数内部","link":"https://xzzz2020.github.io/post/amjJC-n_8/"},{"title":"秒杀策略（缓存+消息队列）","content":"该项目为仅供个人学习使用！！！个人博客地址：https://blog.csdn.net/qq_43040688个人网站地址：http://www.xzzz2020.cn/一、项目简介二、技术栈三、详细实现3.1分布式Session3.2页面缓存+URL缓存3.3对象级缓存3.4核心接口优化3.5接口安全优化四、项目实践中遇到的问题4.1秒杀成功商品订单数超过预订数值4.2一个用户的多个请求导致秒杀成功秒杀多次4.3使用了缓存依然会大量访问数据库五、接下来的优化思路一、项目简介该项目主要学习常用的高并发优化技术，并发的瓶颈往往在数据库，采用缓存和消息队列对接口进行优化减少对数据优化，掌握面对高并发场景下的设计思路：以SpringBoot为主线的技术栈，使用了Mybatis+Druid，采用前后端分离架构整个项目基于商品的秒杀接口，设计登录、商品展示以及订单展示等一系列的功能接口高并发的优化主要利用Redis实现页面缓存+URL缓存+对象缓存，利用前后端分离实现页面静态化以及整合RabbitMQ实现异步下单的优化。QPS优化至少两倍用户登录信息使用Cookie+Redis实现分布式Session，使用拦截器+自定义参数解析器，获取用户信息。解决了不同服务器之间出现的缓存不一致或者服务器宕机Session消失的问题接口安全实现了秒杀接口地址隐藏+数学公式验证码+利用Redis实现接口防刷。防止机器人对于核心业务的攻击利用Jmeter模拟5000个用户，使用1万个线程，对商品展示接口和秒杀接口进行压测。商品展示接口优化前QPS：584.8，优化后QPS：2085.9；秒杀接口优化前QPS：351.8，优化后QPS：2242.7二、技术栈前端BootstrapAjaxthymeleaf后端SpringBootMybatisDruidJedisfastjson数据库MySQLRedis中间件RabbitMQ测试Jmeter三、详细实现3.1分布式Session常用的有三种分布式Session解决方案：服务器之间Session共享、Session绑定、Cookie+缓存。本项目使用的就是Cookie+缓存的方式。下面将介绍这几种方式：服务器之间Session共享：使用一台作为用户的登录服务器，当用户登录成功之后，会将session写到当前服务器上，我们通过脚本或者守护进程将session同步到其他服务器上，这时当用户跳转到其他服务器，session一致，也就不用再次登录。缺陷：速度慢，同步session有延迟性，可能导致跳转服务器之后，session未同步。而且单向同步时，登录服务器宕机，整个系统都不能正常运行。Session绑定：基于nginx的ip-hash策略，可以对客户端和服务器进行绑定，同一个客户端就只能访问该服务器，无论客户端发送多少次请求都被同一个服务器处理缺陷：容易造成单点故障，如果有一台服务器宕机，那么该台服务器上的session信息将会丢失前端不能有负载均衡，如果有，session绑定将会出问题Cookie+缓存将用户信息保存在Redis上，将键值放在Cookie中传递给浏览器，浏览器再下一次的访问中就会携带该Cookie。此时利用拦截器+自定义参数解析器解析用户的Cookie，从缓存中获取数据传递给方法。部分代码如下：利用Cookie+加缓存保存用户信息/***分布式Session的思路是将数据存放在Redis中*将数据的key放在cookie中发送给用户*用户会携带cookie访问*获取期中的token，从redis中获取*每次访问都会生成一个新的，延长有效期*/privatevoidaddCookie(HttpServletResponseresponse,Stringtoken,MiaoshaUseruser){//生成Cookie//生成一个随机字符串token，去掉&quot;-&quot;//将token+加上Redis通用缓存Key，保存在redis中redisService.set(MiaoshaUserKey.getByToken(),token,user);//生成Cookie，只将token存放在cookie,防止用户获取其他用户信息Cookiecookie=newCookie(COOKIE_NAME_TOKEN,token);//将Cookie的时间和Redis缓存时间一直cookie.setMaxAge(MiaoshaUserKey.getByToken().expireSeconds());//将Cookie存放在根目录cookie.setPath(&quot;/&quot;);////将Cookie返回给浏览器response.addCookie(cookie);}3.2页面缓存+URL缓存页面缓存和URL缓存主要差异在于URL缓存会根据URL的变化，数据会有所不同，如某个商品的详细信息、视频的详细信息等。故只介绍商品列表页面缓存技术：页面缓存当客户的请求到达后端时，先去redis中查询缓存，如果缓存中找不到，则进行数据库逻辑操作，然后渲染，存入缓存并返回给前端如果在缓存中找到了则直接返回给前端。存储在Redis缓存中的页面需要设置超时时间，缓存的时间长度根据页面数据变化频繁程度适当调整。目前大多数页面缓存都是在60~120秒，少数几乎不变化的可以调整到5分钟!部分代码实现：商品列表的Controller层@RequestMapping(value=&quot;/to_list&quot;,produces=&quot;text/html&quot;)@ResponseBodypublicStringtoGoods(Modelmodel,MiaoshaUseruser,finalHttpServletRequestrequest,finalHttpServletResponseresponse){//取缓存Stringhtml;html=redisService.get(GoodsKey.getGoodsList(),&quot;&quot;,String.class);if(html!=null){//如果缓存有这个页面returnhtml;}else{//如果没有这个页面//访问数据库获取商品数据List&lt;GoodsVo&gt;goodsList=goodsService.listGoodsVo();if(user!=null){//如果有用户信息，则保存在Model中model.addAttribute(&quot;user&quot;,user);}//将商品数据保存在Model中model.addAttribute(&quot;goodsList&quot;,goodsList);//手动渲染SpringWebContextspringWebContext=newSpringWebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap(),context);html=viewResolver.getTemplateEngine().process(&quot;goods_list&quot;,springWebContext);if(!StringUtils.isEmpty(html)){//保存到缓存，缓存时间只有60秒，不宜过长redisService.set(GoodsKey.getGoodsList(),&quot;&quot;,html);}//返回到浏览器returnhtml;}}接下来使用Jmeter启动1万个线程进行压测：优化前，可以看的吞吐量达到584.8优化后，可以看的吞吐量达到2085.93.3对象级缓存相比页面缓存是更细粒度缓存。在实际项目中，不会大规模使用页面缓存，因为涉及到分页，一般只缓存前面1-2页。对象缓存就是当用到用户数据的时候，可以从缓存中取出。需要注意两个问题：一旦数据发生更改，一定要将缓存失效Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存部分代码实现：保存用户信息/***这个是对象级的缓存*从缓存中取出用户信息*&lt;p&gt;*和页面缓存最大的区别是：1.时间是永久的2.当对象发生更新时，需删除或者更新缓存*&lt;p&gt;*从这里可以看出，Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存*/publicMiaoshaUsergetById(longid){//取缓存MiaoshaUseruser;user=redisService.get(MiaoshaUserKey.getById(),&quot;:&quot;+id,MiaoshaUser.class);if(user!=null){returnuser;}else{//取数据库，加入到缓存中user=miaoshaUserDao.getById(id);redisService.set(MiaoshaUserKey.getById(),&quot;:&quot;+id,user);returnuser;}}3.4核心接口优化核心的业务接口优化主要思路是：使用利用Redis保存商品库存的数量、用户的秒杀成功的订单信息和商品是否秒杀完的标记，这样请求更多的访问缓存，减少对数据库的压力若用户秒杀成功，利用RabbitMQ实现异步下单，服务器控制访问数据库的压力，让用户暂时等待，这样可以优化用户的体验，防止出现服务器宕机等问题部分代码如下所示：秒杀接口Controller@RequestMapping(value=&quot;/{path}/do_miaosha&quot;,method=RequestMethod.POST)@ResponseBodypublicResult&lt;Integer&gt;do_miaosha(MiaoshaUseruser,@RequestParam(&quot;goodsId&quot;)longgoodsId,@PathVariable(&quot;path&quot;)Stringpath){//判断用户是否登录，如果没用登录，则传递提示信息if(user==null){returnResult.error(CodeMsg.SESSION_ERROR);}//隐藏了访问接口，需要验证pathif(StringUtils.isEmpty(path)){returnResult.error(CodeMsg.REQUEST_ILLEGAL);}booleancheck=miaoshaService.checkPath(path,user.getId(),goodsId);if(!check){returnResult.error(CodeMsg.REQUEST_ILLEGAL);}//判断是否秒杀到了MiaoshaOrderorder=orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(),goodsId);//如果能够获取订单，说明该用户已经秒杀到商品if(order!=null){returnResult.error(CodeMsg.REPEATE_MIAO_SHA);}//判断是否秒杀已经结束Booleanover=localOverMap.get(goodsId);if(over){returnResult.error(CodeMsg.MIAO_SHA_OVER);}//预减库存longstock=redisService.decr(GoodsKey.getMiaoGoodsStock(),&quot;:&quot;+goodsId);if(stock&lt;0){//如果发现库存不足，则将秒杀结束的标记置成truelocalOverMap.put(goodsId,true);returnResult.error(CodeMsg.MIAO_SHA_OVER);}//保存信息MiaoshaMessagemiaoshaMessage=newMiaoshaMessage();miaoshaMessage.setGoodsId(goodsId);miaoshaMessage.setUser(user);//入队，实现异步下单mqSender.sendMiaoshaMessage(miaoshaMessage);//返回客户端订单处理中returnResult.success(0);//排队中}消息的发送者publicvoidsendMiaoshaMessage(MiaoshaMessagemiaoshaMessage){//将数据序列化字符串Stringstr=SerializableUtil.beanToString(miaoshaMessage);//发送消息amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE,str);}消息的接收者@RabbitListener(queues=MQConfig.MIAOSHA_QUEUE)publicvoidmiaoshaReceive(Stringmessage){//将消息反序列化MiaoshaMessagemiaoshaMessage=SerializableUtil.stringToBean(message,MiaoshaMessage.class);//获取用户MiaoshaUseruser=miaoshaMessage.getUser();//获取用户idlonggoodsId=miaoshaMessage.getGoodsId();//再次判断库存是否足够GoodsVogoods=goodsService.getGoodsVoByGoodsId(goodsId);IntegerstockCount=goods.getStockCount();//如果库存不足，则直接返回if(stockCount&lt;=0){return;}//减库存下订单写入订单一个事务中miaoshaService.miaosha(user,goods);}订单的处理@TransactionalpublicOrderInfomiaosha(MiaoshaUseruser,GoodsVogoods){//减库存booleansuccess=goodsService.reduceStock(goods);if(success){//下订单returnorderService.creatOrder(user,goods);}else{//如果库存不足，设置商品已经卖完setGoodsOver(goods.getId());}returnnull;}/***设置商品已经卖完*/privatevoidsetGoodsOver(Longid){redisService.set(MiaoshaKey.getMiaoshaOver(),&quot;:&quot;+id,true);}接下来使用Jmeter启动1万个线程，模拟5000个用户进行压测：优化前，可以看的吞吐量达到351.8优化后，可以看的吞吐量达到2242.73.5接口安全优化接口的安全优化主要的防止恶意用户的访问，以及减少瞬时用户的并发量接口隐藏由于前端的代码在浏览器，所以可以轻易的获取到核心业务的接口解决：地址是在客户端动态生成的，前端需要先获取地址信息，然后在发送给服务器，服务器会对浏览器的地址进行处理并和真实的地址进行比较数学问题验证码验证码主要防止机器人的大量访问，以及将用户的请求分散开，避免集中的下单解决：服务器生成验证码，通过前端输入进行验证接口防刷恶意用户可能会大量的访问服务器，给服务器造成压力解决：利用缓存，保存一定时间的访问数，如果超过一定限制，则直接拒绝访问四、项目实践中遇到的问题4.1秒杀成功商品订单数超过预订数值问题分析：该问题主要因为在高并发下，线程不安全导致的在判断是否秒杀成功时，多个用户通过了判断，然后才减少了库存问题解决：MySQL数据库在更新数据时，会自动加锁在SQL语句中减少库存时，判断库存是否大于0，如果不是则执行失败，订单回滚4.2一个用户的多个请求导致秒杀成功秒杀多次问题分析：由于采用的异步下单，在该用户订单没有完成时，则可能会出现一个用户同时下多个订单问题解决：设计数据库表时，多设计一个秒杀的订单，和普通的订单分离在秒杀订单上，user_id采用唯一索引4.3使用了缓存依然会大量访问数据库问题分析：由于为了简便，在Service上面统统加了@Transactional注解，会导致所有的方法启用事务此时即使使用了缓存，也依然会访问数据库，最终造成数据库压力过大问题解决：只在需要事务的方法上使用@Transactiona注解，提高性能五、接下来的优化思路静态资源优化CDN加速Nginx水平扩展","link":"https://xzzz2020.github.io/post/k_uLsJY6w/"},{"title":"贪心策略","content":"简介贪心的特点实际例子1.硬币支付问题2.小船渡河问题3.区间调度问题（二维数组排序）4.区间选点5.区间覆盖问题6.字典序最小问题7.乘船问题总结简介无论是DFS还是BFS都是遍历解空间动态规划和贪心算法都是一种递推算法，运用局部最优解来推到全局最优解是对遍历解空间的一种优化当问题具有最优子结构的时候，可以用动归，而贪心是动归的特例。贪心的特点只看眼前。根据某种规则，不断的选取当前策略，最终找到最优解主要需要不断的举例，去猜测出一个贪心策略。注意：当前最优的未必是整体最优实际例子1.硬币支付问题硬币问题有1元,5元,10元,50元,100元,500元的硬币各c1,c5,c10,c50,c100,c500枚.现在要用这些硬币来支付A元,最少需要多少枚硬币?假定本题至少存在一种支付方案.0≤ci≤10^90≤A≤10^9输入:第一行有六个数字,分别代表从小到大6种面值的硬币的个数第二行为A,代表需支付的A元样例:输入321302620输出6/***尽量先用大面值,因为不用大面值,将使用更多的小面值硬币,一定得不到最优解*/publicclassMain{staticint[]cin=newint[6];publicstaticvoidmain(String[]args)throwsInterruptedException{Scannerscanner=newScanner(System.in);intmoney;intans=0;for(inti=0;i&lt;6;i++){cin[i]=scanner.nextInt();}int[]coins=newint[]{1,5,10,50,100,500};money=scanner.nextInt();for(inti=5;i&gt;=0;i--){intx=money/coins[i];//金额有多少个coins[i]intt=Math.min(cin[i],x);//当前面值的硬币有cin[i]个ans+=t;money-=t*coins[i];}System.out.println(ans);}}2.小船渡河问题N个人过河，船每次最多只能坐两个人，船载每个人过河的所需时间不同，问最快的过河时间。有N个人要渡河，但是只有一艘船，船上每次最多只能载两个人，渡河的速度由两个人中较慢的那个决定，小船来回载人直到所有人都渡河，求最短的渡河时间。输入的每种情况的第一行包含N，第二行包含N个整数，表示每个人过河的时间。每个案例前面都有一个空行。不会有超过1000人，没有人会花超过100秒的时间穿越。对于每个测试用例，打印一行，其中包含所有N个人过河所需的总秒数。SampleInput1412510SampleOutput17可以发现，4个人以上时，前四轮都是将最慢的两个渡过河。publicclassCase02_POJ_1700{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intT=sc.nextInt();for(inti=0;i&lt;T;i++){intn=sc.nextInt();int[]speed=newint[n];for(intj=0;j&lt;n;j++){speed[j]=sc.nextInt();}//排序Arrays.sort(speed);f(n,speed);}}/***speed已经排序**@paramn*@paramspeed*/privatestaticvoidf(intn,int[]speed){intleft=n;intans=0;while(left&gt;0){if(left==1){//只有1人ans+=speed[0];break;}elseif(left==2){//只有两人ans+=speed[1];break;}elseif(left==3){//有三人ans+=speed[2]+speed[0]+speed[1];break;}else{//通过两种策略来回两趟，渡过最慢的两个人//1，2出发，1返回，最后两名出发，2返回ints1=speed[1]+speed[0]+speed[left-1]+speed[1];//1，3出发，1返回，1，4出发，1返回，1，2过河ints2=speed[left-1]+speed[left-2]+2*speed[0];ans+=Math.min(s1,s2);left-=2;//左侧是渡河的起点，left代表左侧的剩余人数}}System.out.println(ans);}3.区间调度问题（二维数组排序）有n项工作,每项工作分别在si时间开始,在ti时间结束.对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.此外,参与工作的时间段不能重复(即使是开始的瞬间和结束的瞬间的重叠也是不允许的).你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?1≤n≤1000001≤si≤ti≤10^9输入:第一行:n第二行:n个整数空格隔开,代表n个工作的开始时间第三行:n个整数空格隔开,代表n个工作的结束时间样例输入:513168352910样例输出:3说明:选取工作1,3,5面向对象的排序思想：将不同的维度，比如说身高、体重、年龄，进行打包。将对象的一些操作打包到一起，操作可以直接影响数据。//贪心策略：选择结束时间最早的publicclassCase03_区间调度问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intn=sc.nextInt();int[]s=newint[n];int[]t=newint[n];//建立开始时间和终止时间的打包对象Job[]jobs=newJob[n];for(inti=0;i&lt;n;i++){s[i]=sc.nextInt();}for(inti=0;i&lt;n;i++){t[i]=sc.nextInt();}for(inti=0;i&lt;n;i++){jobs[i]=newJob(s[i],t[i]);}Arrays.sort(jobs);//此时数据按照终止时间和开始时间由小到大排序intres=f(n,jobs);System.out.println(res);}privatestaticintf(intn,Job[]jobs){intcnt=1;inty=jobs[0].t;//先选择最小的终止时间for(inti=0;i&lt;n;i++){//选择下一个终止时间最早的if(jobs[i].s&gt;y){cnt++;y=jobs[i].t;}}returncnt;}/***必须实现排序规则*/privatestaticclassJobimplementsComparable&lt;Job&gt;{ints;intt;publicJob(ints,intt){this.s=s;this.t=t;}//排序规则@OverridepublicintcompareTo(Jobother){intx=this.t-other.t;if(x==0)//如果终止的时间相同，则比较开始时间returnthis.s-other.s;elsereturnx;}}}4.区间选点题意:有n个如下形式的条件:aibici,表示在区间[ai,bi]内至少要选择ci个整数点.（不同区间内含的点可以是同一个）问你满足n个条件的情况下,最少需要选多少个点?SampleInput5373810368113110111SampleOutput6publicclassCase04_区间选点问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intn=sc.nextInt();Interval[]intervals=newInterval[n];for(inti=0;i&lt;n;i++){intervals[i]=newInterval(sc.nextInt(),sc.nextInt(),sc.nextInt());}Arrays.sort(intervals);//按区间右端点排序intmax=intervals[n-1].t;//右端最大值int[]axis=newint[max+1];//标记数轴上的点是否已经被选中for(inti=0;i&lt;n;i++){//1.查阅区间中有多少个点ints=intervals[i].s;//起点intt=intervals[i].t;//终点intcnt=sum(axis,s,t);//找到这个区间已经选点的数量，sums[t]-sums[s-1];//效率低//2.如果不够，从区间右端开始标记，遇标记过的就跳过intervals[i].c-=cnt;//需要新增的点的数量while(intervals[i].c&gt;0){if(axis[t]==0){//从区间终点开始选点axis[t]=1;//updateSums(t,sums);//更新前缀和intervals[i].c--;//进一步减少需要新增的点的数量t--;}else{//这个点已经被选过了，不选择重复的点t--;}}}System.out.println(sum(axis,0,max));}/***统计数轴axis上s-t区间已经有多少个点被选中*@paramaxis*@params*@paramt*@return*/privatestaticintsum(int[]axis,ints,intt){intsum=0;for(inti=s;i&lt;=t;i++){sum+=axis[i];}returnsum;}privatestaticclassIntervalimplementsComparable&lt;Interval&gt;{ints;//起点intt;//终点intc;//区间需求publicInterval(ints,intt,intc){this.s=s;this.t=t;this.c=c;}//按照终点由小到大排序@OverridepublicintcompareTo(Intervalother){intx=this.t-other.t;if(x==0)returnthis.s-other.s;elsereturnx;}}}5.区间覆盖问题如果给定一堆线段，给定一个区间，看最少需要几个线段才能完全覆盖这个区间。解决思路：设区间起点为start，终点为end，所需线段数目为ans首先线段中的终点，小于区间的起点，则该线段肯定无法覆盖同理如果区间的终点，大于线段的起点，则也一定无法覆盖接着就需要保存线段终点大于等于区间起点且线段起点小于等于区间终点的线段对上面的线段根据起点的大小排序接着此时的寻找线段起点小于start同时终点最远的线段，并该终点设置为新的start，将ans+1重复上述步骤直到找到终点大于end的题目：给出n条线段，以及最大长度m，问最少需要多少条才能覆盖1-m这个区间，当无法全部覆盖的时候输出-1SampleInput3101736610SampleOutput2publicclassCase05_区间覆盖问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intN=sc.nextInt();intT=sc.nextInt();Job[]jobs=newJob[N];for(inti=0;i&lt;N;i++){jobs[i]=newJob(sc.nextInt(),sc.nextInt());}Arrays.sort(jobs);intstart=1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右intend=1;intans=1;for(inti=0;i&lt;N;i++){ints=jobs[i].s;intt=jobs[i].t;if(i==0&amp;&amp;s&gt;1)break;//第一个起点比区间起点小，则一定无法覆盖if(s&lt;=start){//当前区间有可能覆盖startend=Math.max(t,end);//寻找起点小于start同时终点最远的线段}else{//说明已经没有线段再比start小，开始下一个区间ans++;//上一个目标覆盖已经达成，计数加1start=end+1;//更新起点，设置一个新的覆盖目标if(s&lt;=start){end=Math.max(t,end);}else{//当前的起点如果比end大，则后面的都一定大，无法继续覆盖break;}}if(end&gt;=T){//当前的end超越了线段的右侧，则不需要继续判断了break;}}if(end&lt;T)//如果没有覆盖System.out.println(-1);elseSystem.out.println(ans);}privatestaticclassJobimplementsComparable&lt;Job&gt;{ints;intt;publicJob(ints,intt){this.s=s;this.t=t;}/**按照区间起点排序*/@OverridepublicintcompareTo(Jobother){intx=this.s-other.s;if(x==0)returnthis.t-other.t;elsereturnx;}}}6.字典序最小问题字典序最小问题给一个定长为N的字符串S,构造一个字符串T,长度也为N。起初，T是一个空串，随后反复进行下列任意操作从S的头部删除一个字符，加到T的尾部从S的尾部删除一个字符，加到T的尾部目标是最后生成的字符串T的字典序尽可能小1≤N≤2000字符串S只包含大写英文字母输入：字符串S输出：字符串TpublicclassCase06_字典序最小问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intN=sc.nextInt();StringBuilderss=newStringBuilder();//字符输入小技巧for(inti=0;i&lt;N;i++){ss.append(sc.next());}//Strings=sc.nextLine();f(ss.toString());}privatestaticvoidf(Strings){Strings1=newStringBuilder(s).reverse().toString();//字符串翻转，intN=s.length();StringBuilderrs=newStringBuilder();while(rs.length()&lt;N){//这样就可以直接比较两个字符串的头，相当于一个取头一个取尾if(s.compareTo(s1)&lt;=0){//这是个字符串字典比较的小技巧rs.append(s.charAt(0));s=s.substring(1);}else{rs.append(s1.charAt(0));s1=s1.substring(1);}}}7.乘船问题有n个人，第i个人重量为wi。每艘船的最大载重量均为C，且最多只能乘两个人。用最少的船装载所有人。贪心策略：考虑最轻的人i，如果每个人都无法和他一起坐船（重量和超过C），则唯一的方案是每个人坐一艘否则，他应该选择能和他一起坐船的人中最重的一个j求需要船的数量publicclassCase07_乘船问题{publicstaticvoidmain(String[]args){int[]w={1,2,3,4,5,6,7,8,9,10};intn=w.length;intc=10;Arrays.sort(w);intcntOfPerson=n;intcntOfBoat=0;intp1=0;intp2=n-1;while(cntOfPerson&gt;0){if(p1+p2&gt;c){//如果最大的和当前最小的不能在一艘船，则一定需要自己一艘船p2--;cntOfPerson--;cntOfBoat++;}else{p1++;p2--;cntOfPerson-=2;cntOfBoat++;}}System.out.println(cntOfBoat);}}总结本质是一种DFS的剪枝法选择的是当下最优的策略","link":"https://xzzz2020.github.io/post/-Soxdr6Ou/"},{"title":"第七章操作系统接口","content":"命令接口实现系统调用命令接口实现分为下图所示的两个模块实现：终端处理程序，接收键盘的输入，并将命令执行的结果回显在显示器上，功能包括：字符接收字符缓冲回送显示屏幕编辑特殊字符的处理命令解释程序，从.输入缓冲区中取出数据，然后识别命令、执行命令,最后把结果放到输出缓冲区中。系统调用什么是系统调用？系统调用是操作系统提供给应用程序的一-种过程调用，保护操作系统程序不被用户，程序破坏。系统调用是操作系统的程序接口。系统调用与一般的过程调用不同：系统调用处理程序运行在内核态，而一般的过程调用运行在用户态;系统调用需要借助软中断实现，而--般过程调用不需要;系统调用从内核返回时，要进行决策是否运行调度算法，而一般过程调用不需要;系统调用可以嵌套调用，但调用深度有一定的限制，而一般过程调用没有深度限制;","link":"https://xzzz2020.github.io/post/KpZgrFFRY/"},{"title":"第六章文件管理","content":"文件及其逻辑结构顺序文件索引文件索引顺序文件直接文件和哈希文件目录的要求文件的物理结构（***）连续分配链接分配索引分配空闲空间管理空闲表法空闲链表法位视图法（***）成组链表法文件系统软件模型对象及其属性对对象操纵和管理的软件集合文件系统接口文件共享课本习题题目练习文件及其逻辑结构文件概念：由创建者所定义、具有文件名的一组相关元素的集合，可分为结构文件和无结构文件两种。文件逻辑结构概念：文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性，又称为文件组织。顺序文件顺序文件由数据依次排列组成。顺序文件可分为串结构文件和有序结构文件。、串结构文件按记录存入文件的时间先后排列。有序结构按关键字值大小排列。顺序文件又分为定长记录文件和变长记录文件。索引文件若顺序文件是变长记录文件，可按记录号或关键字为每条记录建立一个索引文件，存储记录在顺序文件中的位置信息。索引文件是定长的文件。索引顺序文件索引文件太长会要求更多的I/O次数，直接影响了文件的读/写效率。索引顺序文件先对顺序文件按记录号或关键字排序分组，然后对组的第一个记录索引。直接文件和哈希文件直接文件是一种特殊的哈希文件,记录关键字值决定了记录在顺序文件中的位置。哈希文件则由关键字值通过哈希函数计算获得记录在顺序文件中的位置。目录的要求实现“按名存取”。提高对目录的检索速度。文件共享。允许文件重名。文件的物理结构（***）概念：文件的物理结构指文件的外存分配组织管理方式文件占用的外存空间以块或簇等逻辑单位计量连续分配文件数据连续存储可以提高存取速度，但限制了文件动态增长。链接分配隐式链接，链接指针包含在给文件分配的块中，目录中仅包含文件的起始块和结束块(或长度)。链接指针分散在多个块中，不利于安全措施的实现显示链接：将所有的链接信息提取放到文件分配表中索引分配在链接分配中，文件块链接指针离散存储,造成文件占用块号解析效率不高。索引分配方式就是将块号集中存放。单级索引（一级索引）用一个块来记录文件占用的所有块号,我们称之为索引块二级索引因为一个索引块的大小有限，但是多级索引需要检索多次，会影响性能混合索引(直接地址、-级索引、两级索引、三级索引方式)空闲空间管理空闲表法若干连续的空闲块组合成一个空闲区。空闲表法将所有的空闲区记录在一张表里，包括项号、起始空闲块号、空闲块数等。空闲链表法空闲链表法是以空闲块或空闲区为结点构成一个链表结构。位视图法（***）用一位二进制表示，1代表已分配，0代表空闲。块号从0开始，BitsOfLine是一行有多少位，如char类型为8位block=lineXBitsOfLine+columnline=block/BitsOfLinecolumn=block%BitsOfLine成组链表法用树的结构表示文件系统软件模型对象及其属性文件系统对象超级块对象文件目录索引结点数据块对对象操纵和管理的软件集合对文件的读/写对目录文件的读/写对磁盘空闲空间的管理将文件的逻辑地址转换为物理地址对文件的保护与共享;文件系统接口基于文件名(路径)、文件逻辑地址(相对于文件起始地址的偏移)给用户提供各种操作。常用的文件操作有，创建文件、删除文件、读文件、写文件、设置文件读1写位置、打开文件、关闭文件等。文件共享基于索引结点的共享方式基于符号链的共享方式课本习题11在UNIX中，如果一个盘块的大小为1KB，每个盘块号占4个字节，即每块可放256个地址。请转换下列文件的字节偏移量为物理地址。⑴9999；⑵18000；⑶420000答：首先将逻辑文件的字节偏移量转换为逻辑块号和块内偏移量,就是将[字节偏移量]/[盘块大小]，商为逻辑块号，余数是块内偏移量。在FCB中，第0-9个地址为直接地址，第10个为一次间接地址，第11个地址为二次间接地址，第12个地址为三次间接地址。再将文件的逻辑块号转换为物理块号。使用多重索引结构，在索引节点中根据逻辑块号通过直接索引或间接索引找到对应的物理块号。9999/1024=9余783，则逻辑块号为9，直接索引第9个地址得到物理块号，块内偏移地址为783。18000/1024=17余592，则逻辑块号为10&lt;17&lt;10+256，通过一次间接索引在第10个地址可得到物理块号，块内偏移地址为592。420000/1024=410余160，则逻辑块号为10+256&lt;410，通过二次间接索引在第11个地址可得到一次间址，再由此得到二次间址，再找到物理块号，其块内偏移地址160。某操作系统磁盘文件空间共500块，若用字长为32位的位示图管理磁盘空间，试问：（1）位示图需要多少字？（2）第i字第j位对应的块号是多少？（3）给出申请/归还一块的工作流程。答：（1）位示图需要的字数计算：INT（500/32）=16个字。（2）块号b=(i-1)*32+j（3）申请的过程：顺序扫描位示图、找到空闲块并分配、修改位示图map[i,j]=1。归还的过程：找到回收盘块在位示图中的行和列，修改位示图map[i,j]=0。题目练习","link":"https://xzzz2020.github.io/post/7ZUXXwU1m/"},{"title":"第五章设备管理","content":"设备分类I/O设备控制方式程序查询方式通道控制方式DMA方式（直接存储器访问方式）中断方式I/O系统的软件模型及功能设备独立性软件Spooling缓冲管理四种缓冲策略设备分配磁盘调度算法（会计算***）先来先服务最短寻道时间扫描算法（电梯调度算法）循环扫描算法题目练习设备分类按信息交换单位分类：块设备：数据传送以块为单位，传输速率较高，可寻址;I/O访问常采用DMA方式。字符设备：数据传送以字符为单位，传输速率较低，不可寻址;I/0访问常采用中断方式。按设备的的共享属性分类：独占设备：一段时间内只允许一个进程使用，属于临界资源。共享设备：在一-段时间，允许多个进程同时访问，共享设备必须是可寻址和可随机访问的设备。虚拟设备：将一台独占设备变换为若干个逻辑设备,如虚拟存储器、虚拟终端。I/O设备控制方式程序查询方式不停的检查设备的状态，造成CPU资源的浪费，优点是比较简单通道控制方式通道程序由一系列通道指令构成，包含以下信息：操作码：读、写、控制等;内存地址：读写内存的始址;计数：指令的读写字节数;通道程序示例：通道程序结束位P，1表示通道指令是通道程序的最后一条指令。记录结束位Record,0表示通道指令与下一条通道指令所处理的数据块属于同--个记录，1表示通道指令所处理的数据块是记录的最后一块数据。DMA方式（直接存储器访问方式）DMA方式以块为单位传送数据，仅在数据块传送前和传送结束时,才需要处理机干预。包含四类寄存器：数据寄存器：缓存从设备到内存，或从内存到设备的数据;数据计数寄存器：存储要读/写的字节数;内存地址寄存器：存放内存起始地址;.控制/状态寄存器：接收处理机发来的1/O命令或有关控制信息，以及设备发送的状态信息;中断方式驱动程序向处理机发出启动I/O设备指令后阻塞，处理机转向处理其它工作。设备完成数据传送后，I/O控制器向处理机发送中断请求。处理机收到中断请求信号转向中断处理程序，中断处理程序将数据寄存器中的数据送到指定内存单元，并唤醒阻塞进程。I/O系统的软件模型及功能设备独立性软件设备独立性指应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备概念，在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。设备独立性软件的功能：向用户层(或文件层)软件提供统一接口。执行设备的公有操作，如逻辑设备名映射为物理设备名、独立设备的分配与回收、对设备进行保护、缓冲管理、差错控制、提供独立于物理设备的逻辑块。设备独立性实现：构建一个逻辑设备表，实现逻辑设备名到物理设备名的映射Spooling在联机情况下实现的同时输入/输出操作称为Spooling，或称为假脱机操作,即数据的输入、输出不再由外围控制机管理,而改为进程执行。Spooling系统的组成：输入进程SPi和输出进程SPo输入和输出缓冲区输入和输出井Spooling系统应用--共享打印机：将所有打印请求挂在打印机请求队列上。把打印数据放入到输出井上。打印机驱动进程依次完成打印机请求队列上的任务。Spooling系统的特点：提高了I/O速度。将独占设备改造成共享设备。实现了设备的虚拟化。缓冲管理目的：减少低速设备对高速的干扰。四种缓冲策略1.单缓冲由于处理机与I/O设备的并行性，用户进程对一块缓冲区数据的处理时间等价于Max(C，T)+M。需要注意的是传送和计算或输入无法同时计算此时生产者是设备，消费者是用户进程，生产者和消费者都只有一个，不存在互斥2.双缓冲数据被采集到缓冲区和数据从缓冲区传送到用户进程空间再被计算可以并行执行;用户进程对一块缓冲区数据的处理时间等价于Max(C、T);如果C&gt;T,则CPU可以连续地工作;如果C&lt;T,则I/0设备可以连续地工作;双缓冲适用于I/O设备与用户进程速度基本匹配的场合;此时设备输入数据和用户进程取数据可以同时进行3.循环缓冲适用于I/O设备与用户进程速度差异较大的场合循环缓冲的使用：GetBuf过程，从循环缓冲中获取一个满缓冲区或一个空缓冲区;ReleaseBuf过程，向循环缓冲中释放一个空缓冲区或一个满缓冲区;4.缓冲池（***）三种缓冲队列空缓冲队列emq输入缓冲队列inq,装满输入数据输出缓冲队列outq,装满输出数据四种缓冲区收容输入数据缓冲区hin提取输入数据缓冲区sin收容输出数据缓冲区hout提取输出数据缓冲区sout设备分配安全分配：进程发出I/0请求后，便进入阻塞状态,直到I/O操作完成时才被唤醒。摒弃&quot;请求和保持”死锁必要条件之一，缺点是进程进展缓慢。不安全分配：进程发出I/O请求后仍继续运行，需要时又发出第二C个、第三个I/O请求等，效率高，缺点是可能造成死锁。磁盘调度算法（会计算***）注意：每次寻道都会改变当前所在磁道先来先服务按照请求顺序进行寻道最短寻道时间每次寻找离当前磁道最近的请求，会导致饥饿现象，默写请求可能很久都难以调度扫描算法（电梯调度算法）磁头可以朝着增加的方向移动也会朝着减少的方向移动，可以避免饥饿现象的发生先寻找离当前磁头最近的磁道且需要比当前磁道大当不存在比当前磁道更大的时候，磁头需要调转方向，朝着减少的方向移动.循环扫描算法改进：当移动到不存在比当前磁道更大的时候，不再调转方向，从0开始继续寻找题目练习","link":"https://xzzz2020.github.io/post/mxhiqNcFj/"},{"title":"第四章存储器管理","content":"程序的链接与装入程序的装入程序的链接连续存储分配方式单一连续分配固定分区分配方式动态分区分配（***）基本分页存储管理方式页表地址变换机构（***）基本分段存储管理方式段表地址变换机构（***）分页和分段的主要区别虚拟存储器（***）虚拟存储器实现方法的硬件支持分页请求系统分段请求系统页面置换算法（***）最佳置换算法（理想化）先进先出页面置换算法最近最久未使用置换算法（LRU）clock置换算法简单clock置换算法（最近未访问页面置换算法）改进型clock置换算法最近最少未使用（LFU）练习题目程序的链接与装入程序的装入目的：是将代码装入内存准备执行绝对装入方式可重定位装入方式：动态运行时的装入方式：增加一个重定位寄存器，通过硬件完成地址的修正。真实地址等于逻辑地址+重定位寄存器上的地址程序的链接目的：将目标模块相对独立的地址空间合并成一个地址空间。​静态链接方式对相对地址进行修改变换外部调用符号装入时动态链接运行时动态链接连续存储分配方式目的：给每一个程序分配一片连续的存储空间，容量为程序运行时所需的最大空间。指标：碎片率，越小越好。单一连续分配内存分为系统区和用户区用户区一次只能装入一个程序运行系统区装入操作系统固定分区分配方式将内存划分成固定数目的区域，如图所示：为了实现内存的管理，需要建立固定分区表（数组实现）：程序的大小和分区大小不能完全匹配，所以需要分配大于等于程序大小的内存，分区中浪费的空间称为内碎片动态分区分配（***）操作系统不预设固定数目分区，按照程序内存需求为其划分，内存中分区数目动态变化。数据结构：分配算法：首次适应算法：空闲分区以地址递增的顺序排列，每次从链首开始顺序查找，直到找到一个大小能满足要求的空闲分区为止。然后再按照程序的要求大小，从该空闲分区中划分出一块内存空间给请求者，余下的空闲部分仍留在空闲链表中。特点是低端或高端地址空间被频繁使用。循环首次适应算法：在首次适应算法的基础上，每次查找时从上次找到空闲分区的下一个空闲分区开始查找。特点是空闲分区使用均匀，但是会缺乏大的空闲分区。最佳适应算法：能满足要求、又是最小的空闲分区分配给作业，避免&quot;大材小用”。特点:分区按照大小顺序排列。最差适应算法：每次从空闲分区中选择最大的空闲分区分配给程序，以便切割剩余的空闲分区空间更大。切割操作会产生一些空间过小，总是不会分配给程序，这些空间被称作外碎片。###可重定位分区分配紧凑：通过移动程序，将外碎片合并一个大的空闲分区基本分页存储管理方式离散分配的基本单位是页页表解决了逻辑地址到物理地址的转换的问题：将程序逻辑地址空间划分成固定大小的页面;内存划分成等大小的页框;页表实现页面到页框的索引;页表项个数由程序的逻辑地址空间决定，页表项位数由页框起始物理地址位数决定。记录了页面和页框号（每个页框的起始地址）的对应关系，如下图所示：页表存储了页框的起始物理地址，需要一个连续的存储空间实现随机访问，对于逻辑地址相当于页号+页内偏移。地址变换机构（***）先让页号与页表基址相加得到页框号再让页框号与页内偏移相加得到物理地址基本分段存储管理方式离散分配的基本单位是端采用二维逻辑地址结构，由段号加段内偏移构成段表地址变换机构（***）分页和分段的主要区别页是信息的物理单位；段是信息的逻辑单位。页大小固定；段大小不固定。分页采用一维线性逻辑地址，分段采用二维逻辑地址。虚拟存储器（***）概念：虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器，其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度,每位成本接近外存。虚拟存储器实现方法的硬件支持分页请求系统请求分页的页表机制缺页中断机构地址变换机构分段请求系统请求分段的端表机制缺段中断机构地址变换机构页面置换算法（***）页面中断：发生页面的置换最佳置换算法（理想化）置换以后永不使用或者最长时间不使用的页面发生3次缺页中断和页面中断先进先出页面置换算法淘汰最先进入的页面，即选择在内存中驻留时间最久的页面予以淘汰。最近最久未使用置换算法（LRU）选择最近最久未使用的页面予以淘汰，即当前使用次数最少的页面。实现方式：利用栈保存当前使用的各个页面的页面号,每当进程访问某页面时，便将该页面的页面号从栈中弹出，并将它压入栈顶。因此，栈底是最近最久未使用的页面。使用寄存器，每一次访问都会在寄存器加一，每次置换选择寄存器中次数最少的页面clock置换算法简单clock置换算法（最近未访问页面置换算法）将所有的页面组成一个循环链表,并为每个页面添加一个访问位A。当一个页面被访问时，将其A位设置为1。置换过程是从pointer开始，若该页面的A位为1,将其设置为0,并使pointer指向下一个页面，直到找到A位为0的页面;若该页面的A位为0，则将其置换出内存，并用换入的页面占用换出页面的页框，使pointer指向下一个页面。如果第一轮没有找到，则执行第二轮，由于第一轮将所有页面的A都设置为0，则一定能在第二轮找到改进型clock置换算法增加一个修改为M，页面状态可以分为四类：1类(A=0，M=0)，未访问未修改;2类(A=0，M=1)，未访问.已修改;3类(A=1，M=0)，已访问未修改;4类(A=1,M=1)，已访问已修改;置换过程：从pointer开始寻找1类页面，直到找到1类页面结束，或者扫描完一遍进入第II步。从pointer开始寻找2类页面，直到找到2类页面结束，或者扫描完一遍进入第I步。在本步每扫描完一个页面，须将页面的访问位修改为0。重复l和II。(一定可以找到置换的页。)最近最少未使用（LFU）在最近时期内选择使用次数最少的页面作为淘汰页练习题目","link":"https://xzzz2020.github.io/post/HB2L7VswF/"},{"title":"第三章进程同步与死锁","content":"进程同步信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥利用信号量实现前驱关系资源的分配同步的问题进程间通信死锁的相关概念处理死锁的基本方法预防死锁避免死锁（***）银行家算法（***）检测死锁解除死锁练习题目进程同步临界资源：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源临界区：每个进程中访问临界资源的代码实现互斥的结构：硬件实现：关中断：让处理机始终执行一个程序，不进行程序的切换指令同步应该遵循的规则：空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。忙则等待：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;前驱图：若想执行S2，则需要先执行S1。信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥实现算法：符合：空闲让进，忙则等待和有限等待利用信号量实现前驱关系资源的分配申请资源时需要执行P操作，释放资源时执行V操作同步的问题生产者-消费者问题哲学家进餐问题读者-写者问题进程间通信低级通信：信号量机制高级通讯：共享存储器系统、消息传递系统、管道通信。死锁的相关概念可抢占资源：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。不可抢占的资源：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。死锁的定义：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。产生死锁的原因：竞争不可抢占资源引发死锁。竞争可消耗资源引发死锁。进程推进顺序不当引发死锁。处理死锁的基本方法预防死锁破坏“请求和保持条件”破坏“不可抢占条件”破坏“循环等待条件”：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，必须按照从1到4或者从4到1的顺序申请。避免死锁（***）安全状态：安全状态，是指系统能按某种顺序(P1,P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,直到满足每个进程对资源的最大需求，使每个进程都可以顺利地完成。不安全状态：如果系统无法找到这样一个安全序列，称系统处于不安全状态。要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态银行家算法（***）先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。寻找安全序列的方式只有两种：每次都从最上面开始；按照从上到下顺序循环应用：如果单向顺序，查找安全序列的流程为：判断P0，返现剩余资源不能满足。判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。P0、P1结束，直接跳过。判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。P0、P1、P2、P3结束，直接跳过。判断P4，发现满足，则释放P4分配的资源。最终的安全序列为：P1、P3、P0、P2、P4。确认分配。此时找不到安全序列，拒绝分配。检测死锁解除死锁练习题目","link":"https://xzzz2020.github.io/post/vUwZiOAP9/"},{"title":"第二章处理机管理","content":"程序的执行方式顺序方式（*）并发执行（***）并行执行进程进程的特征进程的状态进程控制块（PCB）进程控制进程的四个操作进程的创建进程的终止进程的阻塞和进程的唤醒进程调度概念进程调度的方式衡量调度算法指标进程调度算法（计算***）先来先服务调度算法（***）短作业优先调度算法（***）高优先权调度算法（***）高响应比优先调度算法时间片轮转调度算法（***）多级队列调度算法多级反馈队列调度算法线程题目练习程序的执行方式顺序方式（*）内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着严格的先后次序顺序执行的特点：顺序性：程序执行有着明确的先后顺序封闭性：程序运行时独占所有资源可再现性：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同问题：无法满足高性能并发执行（***）并发指一段时间内执行多个程序。多个程序同时进入内存，轮流交替执行。并发执行的特点：间断性：交替执行就是走走停停失去了封闭性：程序不再独占系统资源不可再现性：程序执行有多种结果。并行执行同一时刻有多个程序执行，只能在多处理机上实现进程进程是研究并发方式下，程序的执行。进程的概念：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。进程实体：由程序段、相关数据段和PCB组成进程的特征并发性，多个进程在一段时间内同存于内存中同时运行动态性，进程由创建而产生，由调度而执行，由撤消而消亡。独立性，进程是能独立运行、资源分配、调度的基本单位。结构性，进程映像由程序、数据、栈和进程控制块(PCB)构成。异步性，进程按各自独立、不可预知的速度向前推进。进程的状态有三个状态：就绪状态：指程序已经处于准备好运行的状态。执行状态：指程序已经获得CPU，正在执行。阻塞状态：指程序的执行因为某些原因无法继续执行。进程控制块（PCB）用来描述进程的基本情况和活动过程，进而控制和管理进程。（类似于学籍、户口等）进程创建时会建立一个PCB，结束时会收回PCB进程控制块中的信息：进程标识符：包括内部标识符和外部标识符。处理机状态：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。进程控制信息：程序栈和数据地址，同步和通信机制，资源清单,链接指针。进程调度信息进程控制块中的组织方式线性方式链接方式索引方式进程控制进程控制用于创建、终止、阻塞和唤醒进程。进程控制由操作系统内核原语来实现。原语是由若干条指令组成，用于完成一定功能的一个过程，所有的指令要么全做，要么全不做。（一个函数）用户态：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。系统态（内核态）：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。进程的四个操作进程的创建引起进程创建的事件：用户执行应用程序。用户登录。启动服务。程序创建进程。进程创建的过程（必须要求是原语）：申请空白PCB为新进程分配资源，如内存空间等初始化PCB将进程插入就绪队列进程的终止引起进程终止的事件：正常结束。异常结束。外界干预。进程的终止过程：检查进程状态。有无子孙需要终止。归还进程全部资源。将PCB从进程中移除。进程的阻塞和进程的唤醒进程调度概念处理机调度的层次：高级调度低级调度中级调度引起进程调度的事件：进程终止。进程创建。进程阻塞。进程唤醒。外部设备中断。进程切换时需要保存和恢复现场。进程调度的方式抢占式调度：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。非抢占式调度：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（只有时间片用完才能调度）衡量调度算法指标面向用户（***）：平均周转时间：所有周转时间求平均。带权周转时间：一个程序的周转时间除以服务的时间。（&gt;=1）平均带权周转时间：对带权周转时间求平均。周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。面向系统：吞吐量：在单位时间内系统所完成的作业数。处理机利用率：在过去一段时间内CPU被占用的时间总和。各类资源的平衡利用率：保证系统所有的资源被合理利用。进程调度算法（计算***）先来先服务调度算法（***）先来的进程先抢到CPU，有利于长作业，不利于短作业短作业优先调度算法（***）在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。非抢占方式：抢占式：高优先权调度算法（***）按照优先权重分配CPU，优先数越小，优先权越大高响应比优先调度算法按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久响应比=等待时间/服务时间时间片轮转调度算法（***）按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。假设时间片为2。多级队列调度算法优先调度优先级高的多级反馈队列调度算法解决了低优先级队列长时间无法调度的问题线程为什么提出线程？进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。线程概念：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。如下图所示，每个线程都会有个栈，一共有三个线程：线程的特点：一个线程拥有少量的资源，记录在线程控制块中。轻型实体，线程基本上不拥有资源，或者是有较少的资源;一个进程的所有线程共享进程所拥有的全部资源。线程是处理机调度的基本单位，多个线程可以并发执行。线程与进程的比较：线程的实现方式：内核级线程：所有创建、切换等都需要内核的支持，开销较大（适合多处理器系统）用户级线程：可以不需要进入内核态创建，但是切换进程需要进入内核（开销小）组合方式：建立内核级线程与用户级线程的关系。题目练习","link":"https://xzzz2020.github.io/post/IyZhCzd1C/"},{"title":"第一章操作系统引论","content":"操作系统发展操作系统的功能处理机管理存储器管理（内存）设备管理（高效使用IO设备）文件管理操作系统接口操作系统的基本特征操作系统的作用设计目标操作系统结构练习题目操作系统发展无操作系统单道批处理系统多道批处理系统：多个程序交替使用CPU，目的是提高CPU的利用率分时系统：使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了时分复用技术实时系统：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对时间要求苛刻操作系统的功能处理机管理进程控制进程调度进程同步进程通信死锁存储器管理（内存）内存分配内存共享内存扩充内存保护设备管理（高效使用IO设备）设备处理缓冲管理设备分配设备的独立性设备的虚拟性文件管理文件读/写目录管理存储空间管理文件共享、存储性能优化、存储可靠性和数据一致性操作系统接口图形接口系统调用命令调用​操作系统的基本特征并发性：多个程序在同一时间间隔执行共享性：多个并发的程序共同使用计算机资源，提高计算机资源的利用率虚拟性：有时分复用和空分复用两种技术异步性：表现为多任务执行的无序性，主要应对阻塞操作系统的作用操作系统(OperatingSystem,OS)是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。是用户和计算机系统之间的接口是系统资源的管理者扩充计算机的功能，实现对计算机的抽象设计目标方便性有效性扩充性开放性操作系统结构无操作系统结构模块化结构层次结构微内核结构练习题目","link":"https://xzzz2020.github.io/post/ZBrN48x_g/"},{"title":"2020最新-Java面试","content":"学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：https://blog.csdn.net/qq_43040688/article/details/105819866这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。一.数据库1.1关系型数据库MySQL(已更新)推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句SQL语句学习链接基础部分https://blog.csdn.net/qq_43040688/article/details/105346357重点部分https://blog.csdn.net/qq_43040688/article/details/105348610扩展部分https://blog.csdn.net/qq_43040688/article/details/105381801接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构SQL高级部分链接MySQL体系结构和存储引擎介绍https://blog.csdn.net/qq_43040688/article/details/105393816InnoDB存储引擎https://blog.csdn.net/qq_43040688/article/details/105415093MySQL索引https://blog.csdn.net/qq_43040688/article/details/105419053MySQL创建高性能的索引https://blog.csdn.net/qq_43040688/article/details/105454477MySQL查询性能优化https://blog.csdn.net/qq_43040688/article/details/105456790MySQL锁https://blog.csdn.net/qq_43040688/article/details/105440448MySQL事务https://blog.csdn.net/qq_43040688/article/details/105441274MySQL备份https://blog.csdn.net/qq_43040688/article/details/105441944MySQL架构https://blog.csdn.net/qq_43040688/article/details/105450005MySQL高级特性https://blog.csdn.net/qq_43040688/article/details/105465192分库分表的高频面试题https://blog.csdn.net/qq_43040688/article/details/1055946531.2非关系型数据库Redis二、Java基础2.1Java虚拟机（已更新）虛拟机推荐《深入理解Java虚拟机》这本书，重点学习一下内存、垃圾回收、类加载机制这几部分内容。JVM内存结构链接JVM简介https://blog.csdn.net/qq_43040688/article/details/104964070程序计数器和虚拟机栈https://blog.csdn.net/qq_43040688/article/details/104970081本地方法栈和堆https://blog.csdn.net/qq_43040688/article/details/104972811方法区https://blog.csdn.net/qq_43040688/article/details/104982648直接内存https://blog.csdn.net/qq_43040688/article/details/1049960322.2Java并发（已更新）Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久Java并发基础学习Java并发，需要先掌握线程的一些基础知识这些基础知识的组合构成了后面的设计模式首先应该了解如何启动一个多线程，即使用Runnable、Callable、Thread；还需要了解线程启动后的生命周期，了解了不用实现方式的差别，最重要的研读Thread的源码，详情参考：Java多线程起步，Thread构造函数源码分析需要学习Thread常用API以及三种关闭线程的方式，详情参考：Thread的API需要了解this锁和class锁，详情参考：Java多线程之认识“锁”需要了解线程间的通讯，最基本的就是消费者和生产者模型，需要深入了解了wait、sleep、notify、nitifyAll的机制和差异，对于waitset要有个清晰的认识，详情参考：Java多线程之线程间的通讯需要尝试自定义了一个Boolean锁，了解了加锁和释放锁的过程，实现了获取正在阻塞的线程；需要了解线程运行时出现异常的处理方式，详情参考：自定义Boolean锁&amp;捕获线程中的异常需要学习了线程组的概念以及常用API，如interrupt，setDaemon，activeCount，enumerate，详情参考：线程组需要自定义了一个线程池，对线程池的处理机制有了较深的理解，详情参考：自定义线程池Java并发基础链接Java多线程起步https://blog.csdn.net/qq_43040688/article/details/103979628Thread构造函数源码分析https://blog.csdn.net/qq_43040688/article/details/105543926Thread的APIhttps://blog.csdn.net/qq_43040688/article/details/105747547Java多线程之认识“锁”https://blog.csdn.net/qq_43040688/article/details/105752943Java多线程之线程间的通讯https://blog.csdn.net/qq_43040688/article/details/105754406自定义Boolean锁&amp;捕获线程中的异常https://blog.csdn.net/qq_43040688/article/details/105771445线程组https://blog.csdn.net/qq_43040688/article/details/105774614自定义线程池https://blog.csdn.net/qq_43040688/article/details/105786243多线程的设计模式Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合以满足应用需求下面有十四个多线程的设计模式，帮助理解后面的JUC包。第一个设计模式是：观察者模式。需要定义一个主题，一个观察者。主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。详情参考：观察者模式第二个设计模式是：单例模式。解决方式有三种：第一种是doublecheck方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static类实现；第三种是利用enum类实现。详情参考：单例模式第三个设计模式是单线程执行模式。就是在同一时刻只能有一个对共享资源进行操作。详情参考：单线程执行设计模式第四个设计模式不可变对象设计模式。是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。详情参考：不可变对象设计模式第五个设计模式确保挂起设计模式。当线程在工作时，如果来了其他任务，将任务放入到队列中等待。详情参考：确保挂起设计模式第六个设计模式Balking设计模式。当工作已经执行过了，就直接return，防止重复的工作，提高效率。详情参考：Balking设计模式第七个设计模式生产者-消费者设计模式。如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。详情参考：生产者-消费者设计模式第七个设计模式读写锁的设计模式。读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能。详情参考：读写锁的设计模式第八个设计模式Thread-Per-Message。每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。详情参考：Thread-Per-Message第九个设计模式Worker设计模式。需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。详情参考：Worker设计模式第十个设计模式Future设计模式。通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。详情参考：Future设计模式第十一个设计模式两阶段终止设计模式。当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。详情参考：两阶段终止设计模式第十二个设计模式线程保险箱设计模式。利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。详情参考：线程保险箱设计模式和上下文设计模式第十三个设计模式ActiveObjects设计模式。接受异步调用的主动方法。可以主动异步的执行一些任务。详情参考：ActiveObjects设计模式第十四个设计模式CountDown设计模式。多个子任务执行，主任务等待子任务全部执行完，再执行详情参考：CountDown设计模式多线程的设计模式链接观察者模式https://blog.csdn.net/qq_43040688/article/details/105835544单例模式https://blog.csdn.net/qq_43040688/article/details/105798423单线程执行设计模式https://blog.csdn.net/qq_43040688/article/details/105856901不可变对象设计模式https://blog.csdn.net/qq_43040688/article/details/105865371确保挂起设计模式https://blog.csdn.net/qq_43040688/article/details/105886681Balking设计模式https://blog.csdn.net/qq_43040688/article/details/105890674生产者-消费者设计模式https://blog.csdn.net/qq_43040688/article/details/105891561读写锁的设计模式https://blog.csdn.net/qq_43040688/article/details/105857920Thread-Per-Messagehttps://blog.csdn.net/qq_43040688/article/details/105892219Worker设计模式https://blog.csdn.net/qq_43040688/article/details/105894685Future设计模式https://blog.csdn.net/qq_43040688/article/details/105868293两阶段终止设计模式https://blog.csdn.net/qq_43040688/article/details/105892777线程保险箱设计模式https://blog.csdn.net/qq_43040688/article/details/105887378上下文设计模式https://blog.csdn.net/qq_43040688/article/details/105888242ActiveObjects设计模式https://blog.csdn.net/qq_43040688/article/details/105895280CountDown设计模式https://blog.csdn.net/qq_43040688/article/details/105892054Java高并发与JVM的关系主要是学习waitset、JMM模型JMM模型中有四个内容，主要参看博客：Java多线程之内存模型三大特性。如果想学习更多，请学习JVM的部分。解决高速缓存中数据不一致性的问题——总线锁（效率低）、高速缓存一致性协议，英特尔高并发的三个要求——原子性、可见性、有序性happens-before指令重排序Java多线程之内存模型三大特性：https://blog.csdn.net/qq_43040688/article/details/105823532原子包CAS：乐观锁，CompareAndSwap。优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。缺点：在竞争激烈的情况下，浪费CUP资源。还有一个问题是ABA问题，解决方法是：加一个版本号。详情参考：CASUnSafe类内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式获取Unsafe需要通过反射Unsafe类的属性常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现详情参考：UnSafe类AtomicInteger和AtomicBoolean：是保证原子性的对象。利用的CAS详情参考：AtomicInteger和AtomicBooleanAtomicReference是一个利用CAS帮助对象保证原子性的但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：CAS详情参考：AtomicReference文章名称链接CAShttps://blog.csdn.net/qq_43040688/article/details/105914717AtomicIntegerhttps://blog.csdn.net/qq_43040688/article/details/105908835AtomicBooleanhttps://blog.csdn.net/qq_43040688/article/details/105917939AtomicReferencehttps://blog.csdn.net/qq_43040688/article/details/105918329UnSafe类https://blog.csdn.net/qq_43040688/article/details/105923421JUC工具包CountDownLatch通过一个计数器实现，计数器初始值就是线程的数量每当一个线程完成任务，就会使计数减一可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成详情见：CountDownLatchCyclicBarrier跟CountDownLatch的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点详情见：CyclicBarrierPhaserJDK1.7之后引用的，具有CyclicBarrier和CountDownLatch同时它的注册数是支持动态增加或减少（可以用于线程出现异常）当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复详情见：PhaserExchanger用于线程间交换数据需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题详情见：ExchangerSemaphore是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问详情见：SemaphoreReentrantLock支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞需要手动的释放锁，try...finally...相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高是一个Java类，具有更多的功能，同时可以自由的扩展详情请见：ReentrantLock读写锁将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能是悲观锁，可能读的线程太多，写的线程迟迟难以执行详情请见：读写锁StampedLock解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据详情请见：StampedLock三种锁的比较synchronizedStampedLockLock是JVM的的内置锁，每个JDK版本都会优化是一个Java类，可以更好的扩展是一个Java类，可以更好的扩展都是悲观锁提供了写的乐观锁都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁性能一般，因为有一个从用户态到内核态的过程性能最好，可以代替读写锁性能十分不稳定，在复杂的读写环境下，性能十分差详情请见：三种锁的比较ForkJoin基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行分为Fork和Join两个阶段，充分利用CPU资源详情请见：ForkJoin文章名称链接CountDownLatchhttps://blog.csdn.net/qq_43040688/article/details/105935307CyclicBarrierhttps://blog.csdn.net/qq_43040688/article/details/105937169Phaserhttps://blog.csdn.net/qq_43040688/article/details/106033183Exchangerhttps://blog.csdn.net/qq_43040688/article/details/105955788Semaphorehttps://blog.csdn.net/qq_43040688/article/details/105956731ReentrantLockhttps://blog.csdn.net/qq_43040688/article/details/105958719读写锁https://blog.csdn.net/qq_43040688/article/details/105975257StampedLockhttps://blog.csdn.net/qq_43040688/article/details/106026847三种锁的比较https://blog.csdn.net/qq_43040688/article/details/106032189ForkJoinhttps://blog.csdn.net/qq_43040688/article/details/106032309Exectors框架首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。ThreadPoolExecutor创建线程池有七大参数，特别重要有四种拒绝策略四种阻塞队列一些调试的API关闭线程池的注意事项详情请见：ThreadPoolExecutorExecutors用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：newCachedThreadPoolnewFixedThreadPoolnewScheduledThreadPoolnewSingleThreadExecutornewWorkStealingPool详情请见：ExecutorsCompletionService用来增强线程池，主要思想是：执行一批任务，先执行的，先获取结果实现的子类是：ExecutorCompletionService详情请见：CompletionServiceCompleableFuture可以进行串联的操作，即利用上一个任务的结果，执行下一个任务进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果可以不需要调用者主动获取结果，而进行回调执行一批任务时，获取的Future是按照任务完成的顺序创建CompleableFuture有多种方式，最多的是runAsync和supplyAsyncAPI分为组合方法、中转方法和终结方法详情请见：CompleableFuture文章名称链接ThreadPoolExecutorhttps://blog.csdn.net/qq_43040688/article/details/106041236Executorshttps://blog.csdn.net/qq_43040688/article/details/106046629CompletionServicehttps://blog.csdn.net/qq_43040688/article/details/106058225CompleableFuturehttps://blog.csdn.net/qq_43040688/article/details/106061776","link":"https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/"},{"title":"RocketMQ监控平台（附网盘链接）","content":"RocketMQ有一个对其扩展的开源项目incubator-rocketmq-externals，这个项目中有一个子模块叫rocketmq-console，这个便是管理控制台项目了，先将incubator-rocketmq-externals拉到本地，因为我们需要自己对rocketmq-console进行编译打包运行。在linux环境下，使用nohubjava-jarxxxx&amp;启动，为了防止端口冲突，已经修改其端口为9999链接：https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA提取码：jpg03.5.2下载并编译打包gitclonehttps://github.com/apache/rocketmq-externalscdrocketmq-consolemvncleanpackage-Dmaven.test.skip=true注意：打包前在rocketmq-console中配置namesrv集群地址：rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876启动rocketmq-console：java-jarrocketmq-console-ng-1.0.0.jar启动成功后，我们就可以通过浏览器访问http://localhost:8080进入控制台界面了，如下图：","link":"https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/"},{"title":"⚡️Build a blog platform","content":"在学习技术的过程中，博客是一个总结的过程，十分重要。该文章主要介绍如何搭建一个属于自己的个人博客，点击查看博主博客关于本博客Gridea主题评论评论管理系统博客撰写关于本博客本博客基于github和gitee的静态页，国内用户推荐使用gitee，访问速度更快。如果在学习过程中，出现了什么问题，可以在下方评论，博主会收到的。技术概要如下：博客框架采用的是Gridea主题基于bitcron-pro评论系统使用的Valine评论管理系统使用的Valine-Admin博客使用Typora编写图片上传采用的是PicGO+腾讯COSGrideaGridea是一个博客管理软件，支持Windos和Mac，十分好用，页面也比较好看，但是目前不支持gitee，所以需要写一段代码自己提交。页面如下：下载地址：https://gridea.dev/由于下载速度的原因，提供百度网盘下载0.9.2版本：链接：https://pan.baidu.com/s/1lgQGgiCrVRpvdeeCkaHqSg提取码：73ne下载完成后，先使用github搭建，如果同步成功即可完成。学习文档：https://www.jianshu.com/p/6ddc767b1569想要在gitee快速搭建，首先需要在gitee搭建一个仓库，参考：https://blog.csdn.net/qq_36667170/article/details/79318578下面步骤需要会Git！！！！每次推送到github的博客都是在这个目录下C:\\Users\\正好\\Documents\\Gridea\\output，只需要将这个目下的文件，除了.git文件下外所用的文件覆盖到你本地gitee的仓库。然后需要对这些文件递归调用将其中github的地址替换成gitee，博主使用Java写了一个工具，需要将里面的目录地址修改即可，百度网盘下载地址：链接：https://pan.baidu.com/s/1lg770AMzhgSG_U4SQ5kWRA提取码：n2n7将下图的代码变成你gitee的文件夹即可，逻辑就是遍历文件夹，读取每个文件替换语句。但是我把图片、CSS、JS的文件夹屏蔽了，防止造成影响。接着就是Git提交到gitee仓库，然后重新部署gitee的pages的服务。进入提示的网站地址，刷新一下浏览器就出来了。主题博主对其中的搜索算法以及随机色彩算法进行了改进，如果需要可以联系博主目前使用的主题基于这个项目：https://github.com/qyxtim/bitcron-progit下来后，将bitcron-pro文件夹，放到Gridea的主题目录，如C:\\Users\\正好\\Documents\\Gridea\\themes但是该主题不支持Valine评论，所以对其需要进行一些修改，在下面会有介绍。评论评论是基于Valine的，这有一篇博客可以学习：https://ioliu.cn/2017/add-valine-comments-to-your-blog/由于bitcron-pro不支持该评论Valine但是支持Gitalk，可以通过修改代码实现。需要修改的文件目录，博主本机上是：C:\\Users\\正好\\Documents\\Gridea\\themes\\bitcron-pro\\templates\\_blocks下面的gitalk.ejs将里面所有内容删除，添加下面一段：&lt;!--评论显示区，请插入合适的位置--&gt;&lt;divid=&quot;comment&quot;&gt;&lt;/div&gt;&lt;!--Leancloud操作库:--&gt;&lt;scriptsrc=&quot;//cdn1.lncld.net/static/js/3.6.1/av-min.js&quot;&gt;&lt;/script&gt;&lt;!--Valine的核心代码库--&gt;&lt;scriptsrc=&quot;//cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;newValine({el:'#comment',appId:'??????????',appKey:'?????????',placeholder:'ヾﾉ≧∀≦)o快来评论一下吧!',avatar:''});&lt;/script&gt;appId和appKey需要在LeanCloud管理页面查看：配置完成记得在Gridea的Gitalk页面单击一下保存，就会应用到博客上。评论管理系统Valine自带一个Valine-Admain的开源项目，会在评论时，给博主予以提醒，需要基于LeanCloud实现。目前LeanCloud不再提供免费的二级域名，所以最好在阿里云或者腾讯云买一个，在各个地方都用的到需要参考的文章：https://blog.csdn.net/u012208219/article/details/106883083后台页面如下所示：邮件提醒页面：当前LeanCloud定时唤醒任务执行时会提示：因流控原因，通过定时任务唤醒体验版实例失败，建议升级至标准版云引擎实例避免休眠参考这篇文章建立监控：https://blog.csdn.net/Lott0419/article/details/106819895博客撰写博主使用的Typora，但是使用这个写博客图片是保存到本地的，所以就需要利用PicGo+图床上传到网络中Typora0.9.86百度网盘下载：链接：https://pan.baidu.com/s/1aO3jyACQYvBubAjq2QhpGg提取码：920iPicGo2.3.0百度网盘下载：链接：https://pan.baidu.com/s/1wqfzmSt-s9yoa4jstOYnUw提取码：rnu8然后就是需要配置PicGo，如果想要使用腾讯COS当图床，参考这篇文章：https://zhuanlan.zhihu.com/p/119250383，当然还可以使用gitee仓库，不过对象存储真心不贵。Gridea可以提供背景图库，我这边有几个网站推荐，都是免费的图片下载网站：http://www.polayoutu.com/collectionshttps://www.hippopx.com/zhhttps://unsplash.com/","link":"https://xzzz2020.github.io/post/Build_blog/"}]}