{"posts":[{"title":"JavaSE基础知识面试考点总结","content":"一、概述1.JDK版本2.Java语言特性3.Java的加载与执行过程4.JVM、JDK和JRE的区别二、Java语言基础1.八种基本类型2.字符编码3.类型转换4.运算符5.控制语句6.方法三、面向对象1.面向过程与面向对象的区别2.面向对象特征封装继承多态抽象3.参数传递4.关键字this关键字：super关键字static关键字final关键字5.代码块静态代码块实例语句块6.类的继承7.static、构造方法和父子类的调用顺序8.抽象类和接口（***）抽象类接口9.类之间的关系10.Object类equalsfinalize11.访问控制权限12内部类实例内部类静态内部类局部内部类匿名内部类四、异常1.异常的体系2.说出几个常见的异常3.异常处理该文章是博主采集于各大博文，用于复习和总结相关知识点，将会持续的收集和更新。一、概述1.JDK版本目前只维护两个JDK版本，一个是8，一个是11（2018年）2.Java语言特性可移植性，跨平台，因为Java有一个JVM虚拟机，虚拟机负责执行字节码文件健壮性，具有GC，有自动垃圾回收机制3.Java的加载与执行过程T.java（源文件）通过javac命令变成字节码文件字节码文件通过类加载器加载到JVM中JVM屏蔽了和操作系统打交道的操作4.JVM、JDK和JRE的区别Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”的关键所在。JDK是JavaDevelopmentKit，它是功能齐全的JavaSDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。JRE是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。二、Java语言基础1.八种基本类型八种基本数据类型：byte、short、int、long、float、double、boolean、char。一个字节等于8位IEE754标准（32位）：1位是符号位，8位是阶码用移码表示，23位尾数2.字符编码类型可以存放一个汉字，java中的char使用utf-16编码编码名称解释ASCII字符编码只支持英文字母、标点符号、数字字符等，ASCII码占用1个字节，所以ASCII码最多可以表示256个字符.小a97大A65,’0’是48ISO-8859-1有称latin-1,是国际化标准或组织ISO制定的，主要为了西欧语言中的字符编码，和ASCII兼容，仍不支持中文GB2312/GBK/GB18030主要是汉字编码，三种编码从容量上看是包含关系简体中文：GBK&lt;GB2312&lt;GB18030繁体中文：Big5【大五码】unicodeUnicode统一了全世界上的所有文字编码，unicode有几种实现：UTF-8,UTF-16,UTF-32java语言采用的是Unicode编码，所以在java中标识符也可以使用中文3.类型转换在java中基本类型可以相互转换，boolean类型比较特殊不可以转换成其他类型转换分为默认转换和强制转换:默认转换：容量小的类型会默认转换为容量大的类型byte--&gt;short--&gt;int--&gt;long--&gt;float--&gt;doublebyte、short、char之间计算不会互相转换，首先先转换成int强制转换：将容量大的类型转换成容量小的类型，需要进行强制转换注意：只要不超出范围可以将整型值直接赋值给byte，short，char在多种类型混合运算过程中，首先先将所有数据转换成容量最大的那种，再运算publicclassDataTypeTest08{publicstaticvoidmain(String[]args){longx=100L;inty=x;//编译不通过longa=2147483648L;intb=(int)a;System.out.println(b);//出现精度丢失问题，大类型--&gt;&gt;小类型会出现问题，输出-2147483648bytea=1000;//出现错误，1000超出了byte的范围longg=10;inth=g/3;//出现错误，多个数值在运算过程中，会转换成容量最大的类型byteh3=(byte)(int)g/3;//考察优先级，将g先转换成int，再强转成byte，再除以3得到int，赋值错误byteh4=(byte)(int)(g/3);//正确的byteh5=(byte)g/3;//考察优先级，先转换成byte，再运算byteh6=(byte)(g/3);//正确shorth7=(short)(g/3);//正确shorti=10;bytej=5;shortk=i+j;//错误的，short和byte运算，首先会转换成int再运算}}4.运算符短路与和逻辑与的区别？短路与比逻辑与智能，短路与效率高。短路或和逻辑或的区别？短路或：左边的算子结果是true，右边的表达式不执行，发生短路a+=3和a=a+3;是一样的吗？结论(重点)：扩展赋值运算符不改变运算结果的类型。初始类型和最终运算结果类型完全相同。publicclassOperatorTest09{publicstaticvoidmain(String[]args){byteb=10;//编译错误//b=b+3;//修改b=(byte)(b+3);System.out.println(b);//13b+=3;System.out.println(b);//16b+=10000;//等同于b=(byte)(b+10000);System.out.println(b);//32}}5.控制语句switch语句switch也称为多重分支，具体格式如下switch(表达式){case值1：语句break;case值2：语句break;default：语句Break;}说明：表达式的值只能为：char、byte、short、int类型（JDK7以后支持String），boolean、long、float、double都是非法的break语句可以省略,但会出现switch穿透default语句也可以省略，一般不建议省略，并且放置在最后需求：假定系统给定学生的考试成绩，考试成绩可以带有小数。假定成绩是合法的[0-100]，请根据学生考试成绩判断该学生成绩等级：[90-100]A[80-90)B[70-80)C[60-70)D[0-60)E以上业务只能使用switch语句完成，不允许使用if语句。publicclassSwitchTest04{publicstaticvoidmain(String[]args){//考试成绩合法doublescore=100;//开始判断intgrade=(int)(score/10);//case条件不能为浮点数switch(grade){case10:System.out.println(&quot;A&quot;);break;case9:System.out.println(&quot;A&quot;);break;case8:System.out.println(&quot;B&quot;);break;case7:System.out.println(&quot;C&quot;);break;case6:System.out.println(&quot;D&quot;);break;default:System.out.println(&quot;E&quot;);}//重点：case是可以合并的switch(grade){case10:case9:System.out.println(&quot;A&quot;);break;case8:System.out.println(&quot;B&quot;);break;case7:System.out.println(&quot;C&quot;);break;case6:System.out.println(&quot;D&quot;);break;default:System.out.println(&quot;E&quot;);}}}for语句for(;false;){//会出现编译错误，因为无法访问System.out.println(&quot;呵呵&quot;);}for(;true;){//死循环System.out.println(&quot;哈哈&quot;);}6.方法方法的返回值问题：publicclassMethodTest07{//缺少返回语句，程序编译时无法判断是否能走到else，无法编译通过publicstaticintm1(){booleanflag=true;if(flag){return1;}}//正确publicstaticintm2(){booleanflag=true;if(flag){return1;}else{return0;}}//编译错误publicstaticintm3(){booleanflag=false;if(flag){//return1;//return后不能接任何语句System.out.println(&quot;??????????&quot;);}System.out.println(&quot;??????????&quot;);return0;System.out.println(&quot;??????????&quot;);}}三、面向对象1.面向过程与面向对象的区别面向过程：面向过程性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。2.面向对象特征封装封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。关于继承如下3点请记住：子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。（以后介绍）。多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。抽象抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。3.参数传递所有基本数据类型的都是值传递，其他类型的为址传递4.关键字this关键字：this关键字指的是当前调用的对象，只能用在构造函数和实例方法内部，还可以应用在成员变量的声明上，static标识的方法里是不能使用this的。作用：代码复用。super关键字调用父类的构造方法没有显示地调用super();父类的无参构造方法也执行必须将super放到子类的构造函数的第一语句来调用父类的构造方法调用父类的成员方法需要注意：super只能应用在成员方法和构造方法中，不能应用在静态方法中（和this是一样的），如果在构造方法中使用必须放在第一行为什么会有super关键字？因为子类必须要调用父类的构造方法，先把父类构造完成，因为子类依赖于父类，没有父，也就没有子有时需要在子类中显示的调用父类的成员方法那么我们以前为什么没有看到super，而且我们也有继承，如：Student继承了Person？因为子类中我们没有显示的调用父类构造方法，那么他会默认调用父类的无参构造方法，此种情况下如果父类中没有无参构造方法，那么编译时将会失败注意构造方法不存在覆盖的概念，构造方法可以重载static关键字可以用来修饰它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。final关键字final表示不可改变的含义采用final修饰的类不能被继承采用final修饰的方法不能被覆盖采用final修饰的变量不能被修改final修饰的变量必须显示初始化局部变量：一旦赋值不能重新赋值成员变量：不能采用系统默认值，必须手动赋值如果修饰的引用，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的构造方法不能被final修饰会影响JAVA类的初始化:final定义的静态常量调用时不会执行static代码块等相关语句，这是由java虚拟机规定的。我们不需要了解的很深，有个概念就可以了修饰引用变量：final修饰引用变量，主要修饰的是变量的地址，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的publicclassFinalTest05{publicstaticvoidmain(String[]args){Personp1=newPerson();//可以赋值p1.name=&quot;张三&quot;;System.out.println(p1.name);finalPersonp2=newPerson();p2.name=&quot;李四&quot;;System.out.println(p2.name);//不能编译通过//p2采用final修饰，主要限制了p2指向堆区中的地址不能修改(也就是p2只能指向一个对象)//p2指向的对象的属性是可以修改的p2=newPerson();}}classPerson{Stringname;}final和static联合修饰实例变量==常量（尽量使用一个静态工具类抽取出常量）常量名要求全部大写[规范]常量都是publicstaticfinal的常量在类加载的时候完成初始化，存储在JVM的方法区中常量是值不可改变的变量5.代码块静态属性和静态代码块按照代码顺序执行，实例代码块和成员属性同理静态代码块使用static关键字可以定义静态语句块，静态语句块具有以下特点：静态语句块在类加载时执行，在main方法执行之前就已经执行了。类只加载一次，所以静态语句块也是只执行一次一个类中可以编写多个静态语句块，执行顺序是：自上而下依次执行。静态语句块的使用时机：当程序需要在类加载的时候就做一些事情，可以在静态语句块中来实现实例语句块实例语句块和静态代码块没有关系，实例语句块有以下特点：实例语句块在构造方法执行之前执行，构造函数执行一次，实例语句块对应执行一次。每调用一次构造函数之前就会执行一次实例语句块实例语句块可以编写多个，也是按照自上而下的顺序依次执行。实例语句块使用时机：当程序需要在对象初始化时刻就做一些事情，可以在实例语句块中实现//静态语句块static{System.out.println(1);}//实例语句块{System.out.println(1);}6.类的继承如何实现Java多继承？继承特征：继承是面向对象的重要概念，软件中的继承和现实中的继承概念是一样的继承是实现软件可重用性的重要手段，如：A继承B，A就拥有了B的所有特性，如现实世界中的儿子继承父亲的财产，儿子不用努力就有了财产，这就是重用性Java中只支持类的单继承，也就是说A只能继承B，A不能同时继承CJava中的继承使用extends关键字，语法格式：[修饰符]class子类extends父类{}方法的重载的条件方法名相同方法的参数类型，个数，顺序至少有一个不同方法的返回类型可以不同（不依靠返回类型来区分重载）方法的修饰符可以不同，因为方法重载和修饰符没有任何关系方法重载只出现在同一个类中方法的覆盖(Override)的条件：必须要有继承关系覆盖只能出现在子类中，如果没有继承关系，不存在覆盖，只存在重载在子类中被覆盖的方法，必须和父类中的方法完全一样，也就是方法名，返回类型、参数列表，完全一样子类方法的访问权限不能小于父类方法的访问权限子类方法不能抛出比父类方法更多的异常，但可以抛出父类方法异常的子异常父类的静态方法不能被子类覆盖父类的私有方法不能覆盖覆盖是针对成员方法，而非属性为什么需要覆盖？就是要改变父类的行为。方法重写之后，“子类对象”执行的一定是重写之后的方法，也体现了就近原则7.static、构造方法和父子类的调用顺序要点：静态的代码块一定比构造方法先执行如果都是静态代码，一个类里面，按照先后顺序执行，父子之间，父类静态代码块先执行静态代码只会执行一次，多次new新的对象，构造方法，非静态代码块会多次执行classParent{static{System.out.println(&quot;父类的静态块&quot;);}privatestaticStringstaticStr=getStaticStr();privateStringstr=getStr();{System.out.println(&quot;父类的实例块&quot;);}publicParent(){System.out.println(&quot;父类的构造方法&quot;);}privatestaticStringgetStaticStr(){System.out.println(&quot;父类的静态属性初始化&quot;);returnnull;}privateStringgetStr(){System.out.println(&quot;父类的实例属性初始化&quot;);returnnull;}}classChildextendsParent{privatestaticStringstaticStr=getStaticStr();static{System.out.println(&quot;子类的静态块&quot;);}{System.out.println(&quot;子类的实例块&quot;);}publicChild(){System.out.println(&quot;子类的构造方法&quot;);}privateStringstr=getStr();privatestaticStringgetStaticStr(){System.out.println(&quot;子类的静态属性初始化&quot;);returnnull;}privateStringgetStr(){System.out.println(&quot;子类的实例属性初始化&quot;);returnnull;}}publicclassTest{publicstaticvoidmain(String[]args){newChild();}}分析：首先先加载类到JVM的方法区中，则先加载静态的内容，比如静态代码块和静态属性，并且先加载父类，且按照代码顺序加载接着加载对象到堆内存中，先加载父类的实例语句块和实例属性，按照父类优先，根据代码顺序加载，最后加载构造方法执行结果：父类的静态块父类的静态属性初始化子类的静态属性初始化子类的静态块父类的实例属性初始化父类的实例块父类的构造方法子类的实例块子类的实例属性初始化子类的构造方法8.抽象类和接口（***）抽象类看我们以前示例中的Person、Student和Employee，从我们使用的角度来看主要对Student和Employee进行实例化，Person中主要包含了一些公共的属性和方法，而Person我们通常不会实例化，所以我们可以把它定义成抽象的：在java中采用abstract关键字定义的类就是抽象类，采用abstract关键字定义的方法就是抽象方法抽象的方法只需在抽象类中，提供声明，不需要实现如果一个类中含有抽象方法，那么这个类必须定义成抽象类，一个抽象类不一定含有抽象方法如果这个类是抽象的，那么这个类被子类继承，抽象方法必须被重写。如果在子类中不复写该抽象方法，那么必须将此类再次声明为抽象类抽象的类是不能实例化的，就像现实世界中人其实是抽象的，张三、李四才是具体的抽象类不能被final修饰抽象方法不能被final修饰，因为抽象方法就是被子类实现的抽象类中可以包含方法实现，可以将一些公共的代码放到抽象类中，另外在抽象类中可以定义一些抽象的方法，这样就会存在一个约束，而子类必须实现我们定义的方法，如：teacher必须实现printInfo方法，Student也必须实现printInfo方法，方法名称不能修改，必须为printInfo，这样就能实现多态的机制，有了多态的机制，我们在运行期就可以动态的调用子类的方法。所以在运行期可以灵活的互换实现。抽象类和普通类的区别？抽象类普通类不能被实例化，也就是使用new关键字可以被实例化权限限定于Public和Protected，因为需要子类去继承抽象类JDK1.8以前，抽象类的方法默认访问权限为protectedJDK1.8时，抽象类的方法默认访问权限变为default没有权限限制如果一个类继承抽象类，则必须实现抽象类的抽象方法如果没有实现抽象方法，则该类必须定义成抽象类不强制实现父类的方法接口注：JDK1.8以后，接口里可以有静态方法和方法体了。接口我们可以看作是抽象类的一种特殊情况，在接口中只能定义抽象的方法和常量(完全抽象)接口中的方法默认都是publicabstract的(可以省略写)，不能更改接口中的变量默认都是publicstaticfinal的(省略不写)，不能更改，所以必须显示的初始化注意：接口里的所有数据都是public修饰的！如果一个非抽象的类实现了接口，那么接口中所有的方法必须实现一类可以实现多个接口，接口和接口之间支持也是多继承的,但接口之间不能实现在java中接口其实描述了类需要做的事情，类要遵循接口的定义来做事，使用接口到底有什么本质的好处？可以归纳为两点：采用接口明确的声明了它所能提供的服务解决了Java单继承的问题接口和抽象类的区别？接口抽象类不能被实例化不能被实例化需要被子类实现，并实现接口的方法需要被子类继承，并实现抽象方法只能做方法的声明（JDK1.8之后允许方法体）可以做方法的声明，也可以做方法的实现如果子类不能实现接口中的所有方法，则该类只能是抽象类如果子类不能实现抽象类的所有抽象，则该类只能是抽象类属性只能是静态的常量没有限制接口与接口之间可以多继承只能单继承9.类之间的关系泛化关系类与类之间的继承以及接口与接口之间的继承实现关系类对接口的实现关联关系一个类中属性是另个类publicclass学生{private班级班级;//getter/setter}publicclass班级{}聚合关系是关联关系的一种，有着较强的关联关系在java中一个类是整体，使用对象数组包含另个类；另个类属于某个整体publicclass汽车{private轮胎集合轮胎；//getter/setter}publicclass轮胎{private汽车汽车;//getter/setter}依赖关系依赖关系是比关联关系弱的关系，在java语言中体现为返回值，参数，局部变量和静态方法调用publicclassTest{publicstaticvoidmain(String[]args){Personperson=newPerson();}}classPerson{}10.Object类Object类是所有Java类的根基类如果在类的声明中未使用extends关键字指明其基类，则默认基类为Object类equalsequals的源码是这样写的：publicbooleanequals(Objectobj){//this-s1//obj-s2return(this==obj);}所以，默认情况下比较的是地址值，但是可以让我们覆写该方法，实现对象的比较。如何覆写equals方法？首先为了提高效率，需要用==判断是否是同一个对象，如果是直接返回true接着为了提高健壮性，判断是否对象是否是该类的一个对象，如果是，需要对其向下转型最后是比较的逻辑publicclassObjectDemo{publicstaticvoidmain(Stringargs[]){Studentstudent1=newStudent(&quot;生命壹号&quot;,22,&quot;成都&quot;);Studentstudent2=newStudent(&quot;生命壹号&quot;,22,&quot;成都&quot;);System.out.println(student1==student2);System.out.println(student1.equals(student2));}}classStudent{privateStringname;privateintage;privateStringaddress;publicStudent(Stringname,intage,Stringaddress){this.name=name;this.age=age;this.address=address;}//重写Object类中的equals方法（比较两个对象的值是否相等）publicbooleanequals(Objectobj){//为了提高效率：如果两个内存地址相等，那么一定是指向同一个对内存中的对象，就无需比较两个对象的属性值（自己跟自己比，没啥意义嘛）if(this==obj){returntrue;}//为了提供程序的健壮性//我先判断一下，obj是不是学生的一个对象，如果是，再做向下转型，如果不是，直接返回false。//这个时候，我们要判断的是对象是否是某个类的对象?//记住一个格式：对象名instanceof类名。表示：判断该对象是否是该类的一个对象if(!(objinstanceofStudent)){returnfalse;}//如果是就继续Students=(Student)obj;//强制转换，即向下转型（毕竟Object类型没有具体的对象属性）returnthis.name.equals(s.name)&amp;&amp;this.age==s.age&amp;&amp;this.address.equals(s.address);//判断两个对象的属性值是否相等}}==与equals()区别？==equals()等号比较的是值，特别是比较引用类型，比较的是引用的内存地址的那个值默认源码使用的是==，但是可以通过覆写该方法，实现对象的比较对于基本数据的包装类型（Byte,Short,Character，Integer，Float,Double，Long,Boolean）除了Float和Double之外，其他的六种都是实现了常量池的，因此对于这些数据类型而言，一般我们也可以直接通过==来判断是否相等publicclassTest{publicstaticvoidmain(String[]args){Integera=127;Integerb=127;System.out.println(a==b);//trueIntegerc=128;Integerd=128;System.out.println(c==d);//false}}因为Integer在常量池中的存储范围为[-128,127]，127在这范围内，因此是直接存储于常量池的，而128不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以m，n分别指向了两个不同的对象地址，故而导致了不相等。finalize当垃圾收集器将要收集某个垃圾对象时将会调用finalize，建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行JVM当看到对象类含有finalize函数，会将该对象交给FinalizerThread处理，但是处理的时间不确定。11.访问控制权限范围由大到小的排序：public&gt;protected&gt;缺省&gt;private对类的修饰只有public和缺省，内部类除外修饰符类的内部同一个包中子类任何地方publicYYYYprotectedYYYN缺省YYNNprivateYNNN总结为一句话：private修饰的只能类的内部调用；缺省的可以在一个包中调用；protected扩展到了子类中，比如继承某个类，则可以使用那个类的属性和方法；public可以在任何地方访问。12内部类分为四种内部类：实例内部类：在类的内部定义的普通类静态内部类：在类的内部定义的静态类局部内部类：在方法中定义的普通类匿名内部类：方法使用中定义的普通类，主要用来实现接口实例内部类特点：创建实例内部类，外部类的实例必须已经创建实例内部类会持有外部类的引用，可以直接访问外部类的属性不允许有静态声明publicclassOuterClass{//静态变量privatestaticStrings1=&quot;静态变量&quot;;//实例变量privateStrings2=&quot;实例变量&quot;;//实例内部类publicclassInnerClass{//编译错误，实例内部类中不允许有静态的声明publicstaticvoidm1(){}//实例方法publicvoidm2(){System.out.println(s1);System.out.println(s2);}}//入口publicstaticvoidmain(String[]args){OuterClassoc=newOuterClass();InnerClassinnerClass=oc.newInnerClass();//??innerClass.m2();}}静态内部类特点：静态内部类不会持有外部的类的引用创建时可以不用创建外部类，在静态内部类中只能直接访问外部类中所有的静态数据。静态内部类等同于静态变量publicclassOuterClass{//静态变量privatestaticStrings1=&quot;静态变量&quot;;//实例变量privateStrings2=&quot;实例变量&quot;;//静态内部类//静态内部类可以使用任何一个访问控制权限修饰符修饰。protectedstaticclassInnerClass{//静态方法publicstaticvoidm1(){System.out.println(s1);//System.out.println(s2);}//实例方法publicvoidm2(){System.out.println(s1);//System.out.println(s2);}}//入口publicstaticvoidmain(String[]args){OuterClass.InnerClass.m1();//外部类.可以省略InnerClassinnerClass=newOuterClass.InnerClass();innerClass.m2();}}局部内部类局部内部类等同于局部变量局部内部类是在方法体中声明的类，该类只能在方法体中使用局部内部类不能使用public、protected、private修饰局部内部类访问本地变量的时候，方法中的参数需要使用final修饰publicclassOuterClass{privateinta=100;//局部变量在内部类中使用必须采用final修饰publicvoidmethod1(finalinttemp){classInner3{inti1=10;//可以访问外部类的成员变量inti2=a;inti3=temp;}//使用内部类Inner3inner3=newInner3();System.out.println(inner3.i1);System.out.println(inner3.i3);}publicstaticvoidmain(String[]args){OuterClassout=newOuterClass();out.method1(300);}}匿名内部类是一种特殊的内部类，该类没有名字通过new关键字创建，并加上方法体主要用于实现接口publicclassTest{publicstaticvoidmain(String[]args){//在方法中实现接口newThread(newRunnable(){@Overridepublicvoidrun(){}}).run();}}四、异常任意的异常都是在运行时发生的！！！1.异常的体系所有的异常都是Throwable的子类Thorwable有两个直接子类Error和ExceptionError:在Java中只要Error发生了就一种结果——退出JVM，例如StackOverErrorException的直接子类：Exception的直接子类叫做编译时异常、受控异常、检查异常。它虽然叫做编译时异常，但是它不是发生在编译阶段的异常，之所以叫做编译时异常是因为编译时异常要求必须在程序编译的阶段就手动的处理，如果不处理这些异常的话，程序无法编译通过。对于编译时异常有两种手段处理，一是trycatch捕获，一是throws抛出RuntimeException的直接子类：RuntimeException的直接子类叫做运行时异常、非受控异常、非检查异常。这种异常不要求在程序编译阶段处理，编译也可以通过比如说除0异常自定义异常：JDK提供的异常不能够满足要求的情况下用户可以自己自定义异常，可以根据实际情况选择继承Exception或者RuntimeException两种形式。2.说出几个常见的异常ErrorStackOverError（堆溢出）OutOfMemoryError（内存溢出）受控异常IOException（IO异常）SQLException（SQL异常）ClassNotFoundException（找不到指定的类异常）不受控异常NullPointerException（空指针异常）ArithmeticException（算术异常）ArrayIndexOutOfBoundsException（数组下表越界异常）3.异常处理异常的捕获应该从小到大一般有两种方式try...catch...finally....thorws抛给调用者finally在任何情况下都会执行，除非JVM挂掉，通常在finally里关闭资源publicclassExceptionTest12{publicstaticvoidmain(String[]args){intr=method1();//输出为：100？50？System.out.println(r);//输出是50}privatestaticintmethod1(){inta=10;try{a=50;returna;//直接返回值}finally{a=100;//该语句也会执行，只是a已经返回}}}throws和throw的区别？throwsthrowthorws是声明异常thorws是声明异常用在函数上用在函数内部","link":"https://xzzz2020.github.io/post/amjJC-n_8/"},{"title":"秒杀策略（缓存+消息队列）","content":"该项目为仅供个人学习使用！！！个人博客地址：https://blog.csdn.net/qq_43040688个人网站地址：http://www.xzzz2020.cn/一、项目简介二、技术栈三、详细实现3.1分布式Session3.2页面缓存+URL缓存3.3对象级缓存3.4核心接口优化3.5接口安全优化四、项目实践中遇到的问题4.1秒杀成功商品订单数超过预订数值4.2一个用户的多个请求导致秒杀成功秒杀多次4.3使用了缓存依然会大量访问数据库五、接下来的优化思路一、项目简介该项目主要学习常用的高并发优化技术，并发的瓶颈往往在数据库，采用缓存和消息队列对接口进行优化减少对数据优化，掌握面对高并发场景下的设计思路：以SpringBoot为主线的技术栈，使用了Mybatis+Druid，采用前后端分离架构整个项目基于商品的秒杀接口，设计登录、商品展示以及订单展示等一系列的功能接口高并发的优化主要利用Redis实现页面缓存+URL缓存+对象缓存，利用前后端分离实现页面静态化以及整合RabbitMQ实现异步下单的优化。QPS优化至少两倍用户登录信息使用Cookie+Redis实现分布式Session，使用拦截器+自定义参数解析器，获取用户信息。解决了不同服务器之间出现的缓存不一致或者服务器宕机Session消失的问题接口安全实现了秒杀接口地址隐藏+数学公式验证码+利用Redis实现接口防刷。防止机器人对于核心业务的攻击利用Jmeter模拟5000个用户，使用1万个线程，对商品展示接口和秒杀接口进行压测。商品展示接口优化前QPS：584.8，优化后QPS：2085.9；秒杀接口优化前QPS：351.8，优化后QPS：2242.7二、技术栈前端BootstrapAjaxthymeleaf后端SpringBootMybatisDruidJedisfastjson数据库MySQLRedis中间件RabbitMQ测试Jmeter三、详细实现3.1分布式Session常用的有三种分布式Session解决方案：服务器之间Session共享、Session绑定、Cookie+缓存。本项目使用的就是Cookie+缓存的方式。下面将介绍这几种方式：服务器之间Session共享：使用一台作为用户的登录服务器，当用户登录成功之后，会将session写到当前服务器上，我们通过脚本或者守护进程将session同步到其他服务器上，这时当用户跳转到其他服务器，session一致，也就不用再次登录。缺陷：速度慢，同步session有延迟性，可能导致跳转服务器之后，session未同步。而且单向同步时，登录服务器宕机，整个系统都不能正常运行。Session绑定：基于nginx的ip-hash策略，可以对客户端和服务器进行绑定，同一个客户端就只能访问该服务器，无论客户端发送多少次请求都被同一个服务器处理缺陷：容易造成单点故障，如果有一台服务器宕机，那么该台服务器上的session信息将会丢失前端不能有负载均衡，如果有，session绑定将会出问题Cookie+缓存将用户信息保存在Redis上，将键值放在Cookie中传递给浏览器，浏览器再下一次的访问中就会携带该Cookie。此时利用拦截器+自定义参数解析器解析用户的Cookie，从缓存中获取数据传递给方法。部分代码如下：利用Cookie+加缓存保存用户信息/***分布式Session的思路是将数据存放在Redis中*将数据的key放在cookie中发送给用户*用户会携带cookie访问*获取期中的token，从redis中获取*每次访问都会生成一个新的，延长有效期*/privatevoidaddCookie(HttpServletResponseresponse,Stringtoken,MiaoshaUseruser){//生成Cookie//生成一个随机字符串token，去掉&quot;-&quot;//将token+加上Redis通用缓存Key，保存在redis中redisService.set(MiaoshaUserKey.getByToken(),token,user);//生成Cookie，只将token存放在cookie,防止用户获取其他用户信息Cookiecookie=newCookie(COOKIE_NAME_TOKEN,token);//将Cookie的时间和Redis缓存时间一直cookie.setMaxAge(MiaoshaUserKey.getByToken().expireSeconds());//将Cookie存放在根目录cookie.setPath(&quot;/&quot;);////将Cookie返回给浏览器response.addCookie(cookie);}3.2页面缓存+URL缓存页面缓存和URL缓存主要差异在于URL缓存会根据URL的变化，数据会有所不同，如某个商品的详细信息、视频的详细信息等。故只介绍商品列表页面缓存技术：页面缓存当客户的请求到达后端时，先去redis中查询缓存，如果缓存中找不到，则进行数据库逻辑操作，然后渲染，存入缓存并返回给前端如果在缓存中找到了则直接返回给前端。存储在Redis缓存中的页面需要设置超时时间，缓存的时间长度根据页面数据变化频繁程度适当调整。目前大多数页面缓存都是在60~120秒，少数几乎不变化的可以调整到5分钟!部分代码实现：商品列表的Controller层@RequestMapping(value=&quot;/to_list&quot;,produces=&quot;text/html&quot;)@ResponseBodypublicStringtoGoods(Modelmodel,MiaoshaUseruser,finalHttpServletRequestrequest,finalHttpServletResponseresponse){//取缓存Stringhtml;html=redisService.get(GoodsKey.getGoodsList(),&quot;&quot;,String.class);if(html!=null){//如果缓存有这个页面returnhtml;}else{//如果没有这个页面//访问数据库获取商品数据List&lt;GoodsVo&gt;goodsList=goodsService.listGoodsVo();if(user!=null){//如果有用户信息，则保存在Model中model.addAttribute(&quot;user&quot;,user);}//将商品数据保存在Model中model.addAttribute(&quot;goodsList&quot;,goodsList);//手动渲染SpringWebContextspringWebContext=newSpringWebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap(),context);html=viewResolver.getTemplateEngine().process(&quot;goods_list&quot;,springWebContext);if(!StringUtils.isEmpty(html)){//保存到缓存，缓存时间只有60秒，不宜过长redisService.set(GoodsKey.getGoodsList(),&quot;&quot;,html);}//返回到浏览器returnhtml;}}接下来使用Jmeter启动1万个线程进行压测：优化前，可以看的吞吐量达到584.8优化后，可以看的吞吐量达到2085.93.3对象级缓存相比页面缓存是更细粒度缓存。在实际项目中，不会大规模使用页面缓存，因为涉及到分页，一般只缓存前面1-2页。对象缓存就是当用到用户数据的时候，可以从缓存中取出。需要注意两个问题：一旦数据发生更改，一定要将缓存失效Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存部分代码实现：保存用户信息/***这个是对象级的缓存*从缓存中取出用户信息*&lt;p&gt;*和页面缓存最大的区别是：1.时间是永久的2.当对象发生更新时，需删除或者更新缓存*&lt;p&gt;*从这里可以看出，Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存*/publicMiaoshaUsergetById(longid){//取缓存MiaoshaUseruser;user=redisService.get(MiaoshaUserKey.getById(),&quot;:&quot;+id,MiaoshaUser.class);if(user!=null){returnuser;}else{//取数据库，加入到缓存中user=miaoshaUserDao.getById(id);redisService.set(MiaoshaUserKey.getById(),&quot;:&quot;+id,user);returnuser;}}3.4核心接口优化核心的业务接口优化主要思路是：使用利用Redis保存商品库存的数量、用户的秒杀成功的订单信息和商品是否秒杀完的标记，这样请求更多的访问缓存，减少对数据库的压力若用户秒杀成功，利用RabbitMQ实现异步下单，服务器控制访问数据库的压力，让用户暂时等待，这样可以优化用户的体验，防止出现服务器宕机等问题部分代码如下所示：秒杀接口Controller@RequestMapping(value=&quot;/{path}/do_miaosha&quot;,method=RequestMethod.POST)@ResponseBodypublicResult&lt;Integer&gt;do_miaosha(MiaoshaUseruser,@RequestParam(&quot;goodsId&quot;)longgoodsId,@PathVariable(&quot;path&quot;)Stringpath){//判断用户是否登录，如果没用登录，则传递提示信息if(user==null){returnResult.error(CodeMsg.SESSION_ERROR);}//隐藏了访问接口，需要验证pathif(StringUtils.isEmpty(path)){returnResult.error(CodeMsg.REQUEST_ILLEGAL);}booleancheck=miaoshaService.checkPath(path,user.getId(),goodsId);if(!check){returnResult.error(CodeMsg.REQUEST_ILLEGAL);}//判断是否秒杀到了MiaoshaOrderorder=orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(),goodsId);//如果能够获取订单，说明该用户已经秒杀到商品if(order!=null){returnResult.error(CodeMsg.REPEATE_MIAO_SHA);}//判断是否秒杀已经结束Booleanover=localOverMap.get(goodsId);if(over){returnResult.error(CodeMsg.MIAO_SHA_OVER);}//预减库存longstock=redisService.decr(GoodsKey.getMiaoGoodsStock(),&quot;:&quot;+goodsId);if(stock&lt;0){//如果发现库存不足，则将秒杀结束的标记置成truelocalOverMap.put(goodsId,true);returnResult.error(CodeMsg.MIAO_SHA_OVER);}//保存信息MiaoshaMessagemiaoshaMessage=newMiaoshaMessage();miaoshaMessage.setGoodsId(goodsId);miaoshaMessage.setUser(user);//入队，实现异步下单mqSender.sendMiaoshaMessage(miaoshaMessage);//返回客户端订单处理中returnResult.success(0);//排队中}消息的发送者publicvoidsendMiaoshaMessage(MiaoshaMessagemiaoshaMessage){//将数据序列化字符串Stringstr=SerializableUtil.beanToString(miaoshaMessage);//发送消息amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE,str);}消息的接收者@RabbitListener(queues=MQConfig.MIAOSHA_QUEUE)publicvoidmiaoshaReceive(Stringmessage){//将消息反序列化MiaoshaMessagemiaoshaMessage=SerializableUtil.stringToBean(message,MiaoshaMessage.class);//获取用户MiaoshaUseruser=miaoshaMessage.getUser();//获取用户idlonggoodsId=miaoshaMessage.getGoodsId();//再次判断库存是否足够GoodsVogoods=goodsService.getGoodsVoByGoodsId(goodsId);IntegerstockCount=goods.getStockCount();//如果库存不足，则直接返回if(stockCount&lt;=0){return;}//减库存下订单写入订单一个事务中miaoshaService.miaosha(user,goods);}订单的处理@TransactionalpublicOrderInfomiaosha(MiaoshaUseruser,GoodsVogoods){//减库存booleansuccess=goodsService.reduceStock(goods);if(success){//下订单returnorderService.creatOrder(user,goods);}else{//如果库存不足，设置商品已经卖完setGoodsOver(goods.getId());}returnnull;}/***设置商品已经卖完*/privatevoidsetGoodsOver(Longid){redisService.set(MiaoshaKey.getMiaoshaOver(),&quot;:&quot;+id,true);}接下来使用Jmeter启动1万个线程，模拟5000个用户进行压测：优化前，可以看的吞吐量达到351.8优化后，可以看的吞吐量达到2242.73.5接口安全优化接口的安全优化主要的防止恶意用户的访问，以及减少瞬时用户的并发量接口隐藏由于前端的代码在浏览器，所以可以轻易的获取到核心业务的接口解决：地址是在客户端动态生成的，前端需要先获取地址信息，然后在发送给服务器，服务器会对浏览器的地址进行处理并和真实的地址进行比较数学问题验证码验证码主要防止机器人的大量访问，以及将用户的请求分散开，避免集中的下单解决：服务器生成验证码，通过前端输入进行验证接口防刷恶意用户可能会大量的访问服务器，给服务器造成压力解决：利用缓存，保存一定时间的访问数，如果超过一定限制，则直接拒绝访问四、项目实践中遇到的问题4.1秒杀成功商品订单数超过预订数值问题分析：该问题主要因为在高并发下，线程不安全导致的在判断是否秒杀成功时，多个用户通过了判断，然后才减少了库存问题解决：MySQL数据库在更新数据时，会自动加锁在SQL语句中减少库存时，判断库存是否大于0，如果不是则执行失败，订单回滚4.2一个用户的多个请求导致秒杀成功秒杀多次问题分析：由于采用的异步下单，在该用户订单没有完成时，则可能会出现一个用户同时下多个订单问题解决：设计数据库表时，多设计一个秒杀的订单，和普通的订单分离在秒杀订单上，user_id采用唯一索引4.3使用了缓存依然会大量访问数据库问题分析：由于为了简便，在Service上面统统加了@Transactional注解，会导致所有的方法启用事务此时即使使用了缓存，也依然会访问数据库，最终造成数据库压力过大问题解决：只在需要事务的方法上使用@Transactiona注解，提高性能五、接下来的优化思路静态资源优化CDN加速Nginx水平扩展","link":"https://xzzz2020.github.io/post/k_uLsJY6w/"},{"title":"贪心策略","content":"简介贪心的特点实际例子1.硬币支付问题2.小船渡河问题3.区间调度问题（二维数组排序）4.区间选点5.区间覆盖问题6.字典序最小问题7.乘船问题总结简介无论是DFS还是BFS都是遍历解空间动态规划和贪心算法都是一种递推算法，运用局部最优解来推到全局最优解是对遍历解空间的一种优化当问题具有最优子结构的时候，可以用动归，而贪心是动归的特例。贪心的特点只看眼前。根据某种规则，不断的选取当前策略，最终找到最优解主要需要不断的举例，去猜测出一个贪心策略。注意：当前最优的未必是整体最优实际例子1.硬币支付问题硬币问题有1元,5元,10元,50元,100元,500元的硬币各c1,c5,c10,c50,c100,c500枚.现在要用这些硬币来支付A元,最少需要多少枚硬币?假定本题至少存在一种支付方案.0≤ci≤10^90≤A≤10^9输入:第一行有六个数字,分别代表从小到大6种面值的硬币的个数第二行为A,代表需支付的A元样例:输入321302620输出6/***尽量先用大面值,因为不用大面值,将使用更多的小面值硬币,一定得不到最优解*/publicclassMain{staticint[]cin=newint[6];publicstaticvoidmain(String[]args)throwsInterruptedException{Scannerscanner=newScanner(System.in);intmoney;intans=0;for(inti=0;i&lt;6;i++){cin[i]=scanner.nextInt();}int[]coins=newint[]{1,5,10,50,100,500};money=scanner.nextInt();for(inti=5;i&gt;=0;i--){intx=money/coins[i];//金额有多少个coins[i]intt=Math.min(cin[i],x);//当前面值的硬币有cin[i]个ans+=t;money-=t*coins[i];}System.out.println(ans);}}2.小船渡河问题N个人过河，船每次最多只能坐两个人，船载每个人过河的所需时间不同，问最快的过河时间。有N个人要渡河，但是只有一艘船，船上每次最多只能载两个人，渡河的速度由两个人中较慢的那个决定，小船来回载人直到所有人都渡河，求最短的渡河时间。输入的每种情况的第一行包含N，第二行包含N个整数，表示每个人过河的时间。每个案例前面都有一个空行。不会有超过1000人，没有人会花超过100秒的时间穿越。对于每个测试用例，打印一行，其中包含所有N个人过河所需的总秒数。SampleInput1412510SampleOutput17可以发现，4个人以上时，前四轮都是将最慢的两个渡过河。publicclassCase02_POJ_1700{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intT=sc.nextInt();for(inti=0;i&lt;T;i++){intn=sc.nextInt();int[]speed=newint[n];for(intj=0;j&lt;n;j++){speed[j]=sc.nextInt();}//排序Arrays.sort(speed);f(n,speed);}}/***speed已经排序**@paramn*@paramspeed*/privatestaticvoidf(intn,int[]speed){intleft=n;intans=0;while(left&gt;0){if(left==1){//只有1人ans+=speed[0];break;}elseif(left==2){//只有两人ans+=speed[1];break;}elseif(left==3){//有三人ans+=speed[2]+speed[0]+speed[1];break;}else{//通过两种策略来回两趟，渡过最慢的两个人//1，2出发，1返回，最后两名出发，2返回ints1=speed[1]+speed[0]+speed[left-1]+speed[1];//1，3出发，1返回，1，4出发，1返回，1，2过河ints2=speed[left-1]+speed[left-2]+2*speed[0];ans+=Math.min(s1,s2);left-=2;//左侧是渡河的起点，left代表左侧的剩余人数}}System.out.println(ans);}3.区间调度问题（二维数组排序）有n项工作,每项工作分别在si时间开始,在ti时间结束.对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.此外,参与工作的时间段不能重复(即使是开始的瞬间和结束的瞬间的重叠也是不允许的).你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?1≤n≤1000001≤si≤ti≤10^9输入:第一行:n第二行:n个整数空格隔开,代表n个工作的开始时间第三行:n个整数空格隔开,代表n个工作的结束时间样例输入:513168352910样例输出:3说明:选取工作1,3,5面向对象的排序思想：将不同的维度，比如说身高、体重、年龄，进行打包。将对象的一些操作打包到一起，操作可以直接影响数据。//贪心策略：选择结束时间最早的publicclassCase03_区间调度问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intn=sc.nextInt();int[]s=newint[n];int[]t=newint[n];//建立开始时间和终止时间的打包对象Job[]jobs=newJob[n];for(inti=0;i&lt;n;i++){s[i]=sc.nextInt();}for(inti=0;i&lt;n;i++){t[i]=sc.nextInt();}for(inti=0;i&lt;n;i++){jobs[i]=newJob(s[i],t[i]);}Arrays.sort(jobs);//此时数据按照终止时间和开始时间由小到大排序intres=f(n,jobs);System.out.println(res);}privatestaticintf(intn,Job[]jobs){intcnt=1;inty=jobs[0].t;//先选择最小的终止时间for(inti=0;i&lt;n;i++){//选择下一个终止时间最早的if(jobs[i].s&gt;y){cnt++;y=jobs[i].t;}}returncnt;}/***必须实现排序规则*/privatestaticclassJobimplementsComparable&lt;Job&gt;{ints;intt;publicJob(ints,intt){this.s=s;this.t=t;}//排序规则@OverridepublicintcompareTo(Jobother){intx=this.t-other.t;if(x==0)//如果终止的时间相同，则比较开始时间returnthis.s-other.s;elsereturnx;}}}4.区间选点题意:有n个如下形式的条件:aibici,表示在区间[ai,bi]内至少要选择ci个整数点.（不同区间内含的点可以是同一个）问你满足n个条件的情况下,最少需要选多少个点?SampleInput5373810368113110111SampleOutput6publicclassCase04_区间选点问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intn=sc.nextInt();Interval[]intervals=newInterval[n];for(inti=0;i&lt;n;i++){intervals[i]=newInterval(sc.nextInt(),sc.nextInt(),sc.nextInt());}Arrays.sort(intervals);//按区间右端点排序intmax=intervals[n-1].t;//右端最大值int[]axis=newint[max+1];//标记数轴上的点是否已经被选中for(inti=0;i&lt;n;i++){//1.查阅区间中有多少个点ints=intervals[i].s;//起点intt=intervals[i].t;//终点intcnt=sum(axis,s,t);//找到这个区间已经选点的数量，sums[t]-sums[s-1];//效率低//2.如果不够，从区间右端开始标记，遇标记过的就跳过intervals[i].c-=cnt;//需要新增的点的数量while(intervals[i].c&gt;0){if(axis[t]==0){//从区间终点开始选点axis[t]=1;//updateSums(t,sums);//更新前缀和intervals[i].c--;//进一步减少需要新增的点的数量t--;}else{//这个点已经被选过了，不选择重复的点t--;}}}System.out.println(sum(axis,0,max));}/***统计数轴axis上s-t区间已经有多少个点被选中*@paramaxis*@params*@paramt*@return*/privatestaticintsum(int[]axis,ints,intt){intsum=0;for(inti=s;i&lt;=t;i++){sum+=axis[i];}returnsum;}privatestaticclassIntervalimplementsComparable&lt;Interval&gt;{ints;//起点intt;//终点intc;//区间需求publicInterval(ints,intt,intc){this.s=s;this.t=t;this.c=c;}//按照终点由小到大排序@OverridepublicintcompareTo(Intervalother){intx=this.t-other.t;if(x==0)returnthis.s-other.s;elsereturnx;}}}5.区间覆盖问题如果给定一堆线段，给定一个区间，看最少需要几个线段才能完全覆盖这个区间。解决思路：设区间起点为start，终点为end，所需线段数目为ans首先线段中的终点，小于区间的起点，则该线段肯定无法覆盖同理如果区间的终点，大于线段的起点，则也一定无法覆盖接着就需要保存线段终点大于等于区间起点且线段起点小于等于区间终点的线段对上面的线段根据起点的大小排序接着此时的寻找线段起点小于start同时终点最远的线段，并该终点设置为新的start，将ans+1重复上述步骤直到找到终点大于end的题目：给出n条线段，以及最大长度m，问最少需要多少条才能覆盖1-m这个区间，当无法全部覆盖的时候输出-1SampleInput3101736610SampleOutput2publicclassCase05_区间覆盖问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intN=sc.nextInt();intT=sc.nextInt();Job[]jobs=newJob[N];for(inti=0;i&lt;N;i++){jobs[i]=newJob(sc.nextInt(),sc.nextInt());}Arrays.sort(jobs);intstart=1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右intend=1;intans=1;for(inti=0;i&lt;N;i++){ints=jobs[i].s;intt=jobs[i].t;if(i==0&amp;&amp;s&gt;1)break;//第一个起点比区间起点小，则一定无法覆盖if(s&lt;=start){//当前区间有可能覆盖startend=Math.max(t,end);//寻找起点小于start同时终点最远的线段}else{//说明已经没有线段再比start小，开始下一个区间ans++;//上一个目标覆盖已经达成，计数加1start=end+1;//更新起点，设置一个新的覆盖目标if(s&lt;=start){end=Math.max(t,end);}else{//当前的起点如果比end大，则后面的都一定大，无法继续覆盖break;}}if(end&gt;=T){//当前的end超越了线段的右侧，则不需要继续判断了break;}}if(end&lt;T)//如果没有覆盖System.out.println(-1);elseSystem.out.println(ans);}privatestaticclassJobimplementsComparable&lt;Job&gt;{ints;intt;publicJob(ints,intt){this.s=s;this.t=t;}/**按照区间起点排序*/@OverridepublicintcompareTo(Jobother){intx=this.s-other.s;if(x==0)returnthis.t-other.t;elsereturnx;}}}6.字典序最小问题字典序最小问题给一个定长为N的字符串S,构造一个字符串T,长度也为N。起初，T是一个空串，随后反复进行下列任意操作从S的头部删除一个字符，加到T的尾部从S的尾部删除一个字符，加到T的尾部目标是最后生成的字符串T的字典序尽可能小1≤N≤2000字符串S只包含大写英文字母输入：字符串S输出：字符串TpublicclassCase06_字典序最小问题{publicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);intN=sc.nextInt();StringBuilderss=newStringBuilder();//字符输入小技巧for(inti=0;i&lt;N;i++){ss.append(sc.next());}//Strings=sc.nextLine();f(ss.toString());}privatestaticvoidf(Strings){Strings1=newStringBuilder(s).reverse().toString();//字符串翻转，intN=s.length();StringBuilderrs=newStringBuilder();while(rs.length()&lt;N){//这样就可以直接比较两个字符串的头，相当于一个取头一个取尾if(s.compareTo(s1)&lt;=0){//这是个字符串字典比较的小技巧rs.append(s.charAt(0));s=s.substring(1);}else{rs.append(s1.charAt(0));s1=s1.substring(1);}}}7.乘船问题有n个人，第i个人重量为wi。每艘船的最大载重量均为C，且最多只能乘两个人。用最少的船装载所有人。贪心策略：考虑最轻的人i，如果每个人都无法和他一起坐船（重量和超过C），则唯一的方案是每个人坐一艘否则，他应该选择能和他一起坐船的人中最重的一个j求需要船的数量publicclassCase07_乘船问题{publicstaticvoidmain(String[]args){int[]w={1,2,3,4,5,6,7,8,9,10};intn=w.length;intc=10;Arrays.sort(w);intcntOfPerson=n;intcntOfBoat=0;intp1=0;intp2=n-1;while(cntOfPerson&gt;0){if(p1+p2&gt;c){//如果最大的和当前最小的不能在一艘船，则一定需要自己一艘船p2--;cntOfPerson--;cntOfBoat++;}else{p1++;p2--;cntOfPerson-=2;cntOfBoat++;}}System.out.println(cntOfBoat);}}总结本质是一种DFS的剪枝法选择的是当下最优的策略","link":"https://xzzz2020.github.io/post/-Soxdr6Ou/"},{"title":"第七章操作系统接口","content":"命令接口实现系统调用命令接口实现分为下图所示的两个模块实现：终端处理程序，接收键盘的输入，并将命令执行的结果回显在显示器上，功能包括：字符接收字符缓冲回送显示屏幕编辑特殊字符的处理命令解释程序，从.输入缓冲区中取出数据，然后识别命令、执行命令,最后把结果放到输出缓冲区中。系统调用什么是系统调用？系统调用是操作系统提供给应用程序的一-种过程调用，保护操作系统程序不被用户，程序破坏。系统调用是操作系统的程序接口。系统调用与一般的过程调用不同：系统调用处理程序运行在内核态，而一般的过程调用运行在用户态;系统调用需要借助软中断实现，而--般过程调用不需要;系统调用从内核返回时，要进行决策是否运行调度算法，而一般过程调用不需要;系统调用可以嵌套调用，但调用深度有一定的限制，而一般过程调用没有深度限制;","link":"https://xzzz2020.github.io/post/KpZgrFFRY/"},{"title":"第六章文件管理","content":"文件及其逻辑结构顺序文件索引文件索引顺序文件直接文件和哈希文件目录的要求文件的物理结构（***）连续分配链接分配索引分配空闲空间管理空闲表法空闲链表法位视图法（***）成组链表法文件系统软件模型对象及其属性对对象操纵和管理的软件集合文件系统接口文件共享课本习题题目练习文件及其逻辑结构文件概念：由创建者所定义、具有文件名的一组相关元素的集合，可分为结构文件和无结构文件两种。文件逻辑结构概念：文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性，又称为文件组织。顺序文件顺序文件由数据依次排列组成。顺序文件可分为串结构文件和有序结构文件。、串结构文件按记录存入文件的时间先后排列。有序结构按关键字值大小排列。顺序文件又分为定长记录文件和变长记录文件。索引文件若顺序文件是变长记录文件，可按记录号或关键字为每条记录建立一个索引文件，存储记录在顺序文件中的位置信息。索引文件是定长的文件。索引顺序文件索引文件太长会要求更多的I/O次数，直接影响了文件的读/写效率。索引顺序文件先对顺序文件按记录号或关键字排序分组，然后对组的第一个记录索引。直接文件和哈希文件直接文件是一种特殊的哈希文件,记录关键字值决定了记录在顺序文件中的位置。哈希文件则由关键字值通过哈希函数计算获得记录在顺序文件中的位置。目录的要求实现“按名存取”。提高对目录的检索速度。文件共享。允许文件重名。文件的物理结构（***）概念：文件的物理结构指文件的外存分配组织管理方式文件占用的外存空间以块或簇等逻辑单位计量连续分配文件数据连续存储可以提高存取速度，但限制了文件动态增长。链接分配隐式链接，链接指针包含在给文件分配的块中，目录中仅包含文件的起始块和结束块(或长度)。链接指针分散在多个块中，不利于安全措施的实现显示链接：将所有的链接信息提取放到文件分配表中索引分配在链接分配中，文件块链接指针离散存储,造成文件占用块号解析效率不高。索引分配方式就是将块号集中存放。单级索引（一级索引）用一个块来记录文件占用的所有块号,我们称之为索引块二级索引因为一个索引块的大小有限，但是多级索引需要检索多次，会影响性能混合索引(直接地址、-级索引、两级索引、三级索引方式)空闲空间管理空闲表法若干连续的空闲块组合成一个空闲区。空闲表法将所有的空闲区记录在一张表里，包括项号、起始空闲块号、空闲块数等。空闲链表法空闲链表法是以空闲块或空闲区为结点构成一个链表结构。位视图法（***）用一位二进制表示，1代表已分配，0代表空闲。块号从0开始，BitsOfLine是一行有多少位，如char类型为8位block=lineXBitsOfLine+columnline=block/BitsOfLinecolumn=block%BitsOfLine成组链表法用树的结构表示文件系统软件模型对象及其属性文件系统对象超级块对象文件目录索引结点数据块对对象操纵和管理的软件集合对文件的读/写对目录文件的读/写对磁盘空闲空间的管理将文件的逻辑地址转换为物理地址对文件的保护与共享;文件系统接口基于文件名(路径)、文件逻辑地址(相对于文件起始地址的偏移)给用户提供各种操作。常用的文件操作有，创建文件、删除文件、读文件、写文件、设置文件读1写位置、打开文件、关闭文件等。文件共享基于索引结点的共享方式基于符号链的共享方式课本习题11在UNIX中，如果一个盘块的大小为1KB，每个盘块号占4个字节，即每块可放256个地址。请转换下列文件的字节偏移量为物理地址。⑴9999；⑵18000；⑶420000答：首先将逻辑文件的字节偏移量转换为逻辑块号和块内偏移量,就是将[字节偏移量]/[盘块大小]，商为逻辑块号，余数是块内偏移量。在FCB中，第0-9个地址为直接地址，第10个为一次间接地址，第11个地址为二次间接地址，第12个地址为三次间接地址。再将文件的逻辑块号转换为物理块号。使用多重索引结构，在索引节点中根据逻辑块号通过直接索引或间接索引找到对应的物理块号。9999/1024=9余783，则逻辑块号为9，直接索引第9个地址得到物理块号，块内偏移地址为783。18000/1024=17余592，则逻辑块号为10&lt;17&lt;10+256，通过一次间接索引在第10个地址可得到物理块号，块内偏移地址为592。420000/1024=410余160，则逻辑块号为10+256&lt;410，通过二次间接索引在第11个地址可得到一次间址，再由此得到二次间址，再找到物理块号，其块内偏移地址160。某操作系统磁盘文件空间共500块，若用字长为32位的位示图管理磁盘空间，试问：（1）位示图需要多少字？（2）第i字第j位对应的块号是多少？（3）给出申请/归还一块的工作流程。答：（1）位示图需要的字数计算：INT（500/32）=16个字。（2）块号b=(i-1)*32+j（3）申请的过程：顺序扫描位示图、找到空闲块并分配、修改位示图map[i,j]=1。归还的过程：找到回收盘块在位示图中的行和列，修改位示图map[i,j]=0。题目练习","link":"https://xzzz2020.github.io/post/7ZUXXwU1m/"},{"title":"第五章设备管理","content":"设备分类I/O设备控制方式程序查询方式通道控制方式DMA方式（直接存储器访问方式）中断方式I/O系统的软件模型及功能设备独立性软件Spooling缓冲管理四种缓冲策略设备分配磁盘调度算法（会计算***）先来先服务最短寻道时间扫描算法（电梯调度算法）循环扫描算法题目练习设备分类按信息交换单位分类：块设备：数据传送以块为单位，传输速率较高，可寻址;I/O访问常采用DMA方式。字符设备：数据传送以字符为单位，传输速率较低，不可寻址;I/0访问常采用中断方式。按设备的的共享属性分类：独占设备：一段时间内只允许一个进程使用，属于临界资源。共享设备：在一-段时间，允许多个进程同时访问，共享设备必须是可寻址和可随机访问的设备。虚拟设备：将一台独占设备变换为若干个逻辑设备,如虚拟存储器、虚拟终端。I/O设备控制方式程序查询方式不停的检查设备的状态，造成CPU资源的浪费，优点是比较简单通道控制方式通道程序由一系列通道指令构成，包含以下信息：操作码：读、写、控制等;内存地址：读写内存的始址;计数：指令的读写字节数;通道程序示例：通道程序结束位P，1表示通道指令是通道程序的最后一条指令。记录结束位Record,0表示通道指令与下一条通道指令所处理的数据块属于同--个记录，1表示通道指令所处理的数据块是记录的最后一块数据。DMA方式（直接存储器访问方式）DMA方式以块为单位传送数据，仅在数据块传送前和传送结束时,才需要处理机干预。包含四类寄存器：数据寄存器：缓存从设备到内存，或从内存到设备的数据;数据计数寄存器：存储要读/写的字节数;内存地址寄存器：存放内存起始地址;.控制/状态寄存器：接收处理机发来的1/O命令或有关控制信息，以及设备发送的状态信息;中断方式驱动程序向处理机发出启动I/O设备指令后阻塞，处理机转向处理其它工作。设备完成数据传送后，I/O控制器向处理机发送中断请求。处理机收到中断请求信号转向中断处理程序，中断处理程序将数据寄存器中的数据送到指定内存单元，并唤醒阻塞进程。I/O系统的软件模型及功能设备独立性软件设备独立性指应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备概念，在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。设备独立性软件的功能：向用户层(或文件层)软件提供统一接口。执行设备的公有操作，如逻辑设备名映射为物理设备名、独立设备的分配与回收、对设备进行保护、缓冲管理、差错控制、提供独立于物理设备的逻辑块。设备独立性实现：构建一个逻辑设备表，实现逻辑设备名到物理设备名的映射Spooling在联机情况下实现的同时输入/输出操作称为Spooling，或称为假脱机操作,即数据的输入、输出不再由外围控制机管理,而改为进程执行。Spooling系统的组成：输入进程SPi和输出进程SPo输入和输出缓冲区输入和输出井Spooling系统应用--共享打印机：将所有打印请求挂在打印机请求队列上。把打印数据放入到输出井上。打印机驱动进程依次完成打印机请求队列上的任务。Spooling系统的特点：提高了I/O速度。将独占设备改造成共享设备。实现了设备的虚拟化。缓冲管理目的：减少低速设备对高速的干扰。四种缓冲策略1.单缓冲由于处理机与I/O设备的并行性，用户进程对一块缓冲区数据的处理时间等价于Max(C，T)+M。需要注意的是传送和计算或输入无法同时计算此时生产者是设备，消费者是用户进程，生产者和消费者都只有一个，不存在互斥2.双缓冲数据被采集到缓冲区和数据从缓冲区传送到用户进程空间再被计算可以并行执行;用户进程对一块缓冲区数据的处理时间等价于Max(C、T);如果C&gt;T,则CPU可以连续地工作;如果C&lt;T,则I/0设备可以连续地工作;双缓冲适用于I/O设备与用户进程速度基本匹配的场合;此时设备输入数据和用户进程取数据可以同时进行3.循环缓冲适用于I/O设备与用户进程速度差异较大的场合循环缓冲的使用：GetBuf过程，从循环缓冲中获取一个满缓冲区或一个空缓冲区;ReleaseBuf过程，向循环缓冲中释放一个空缓冲区或一个满缓冲区;4.缓冲池（***）三种缓冲队列空缓冲队列emq输入缓冲队列inq,装满输入数据输出缓冲队列outq,装满输出数据四种缓冲区收容输入数据缓冲区hin提取输入数据缓冲区sin收容输出数据缓冲区hout提取输出数据缓冲区sout设备分配安全分配：进程发出I/0请求后，便进入阻塞状态,直到I/O操作完成时才被唤醒。摒弃&quot;请求和保持”死锁必要条件之一，缺点是进程进展缓慢。不安全分配：进程发出I/O请求后仍继续运行，需要时又发出第二C个、第三个I/O请求等，效率高，缺点是可能造成死锁。磁盘调度算法（会计算***）注意：每次寻道都会改变当前所在磁道先来先服务按照请求顺序进行寻道最短寻道时间每次寻找离当前磁道最近的请求，会导致饥饿现象，默写请求可能很久都难以调度扫描算法（电梯调度算法）磁头可以朝着增加的方向移动也会朝着减少的方向移动，可以避免饥饿现象的发生先寻找离当前磁头最近的磁道且需要比当前磁道大当不存在比当前磁道更大的时候，磁头需要调转方向，朝着减少的方向移动.循环扫描算法改进：当移动到不存在比当前磁道更大的时候，不再调转方向，从0开始继续寻找题目练习","link":"https://xzzz2020.github.io/post/mxhiqNcFj/"},{"title":"第四章存储器管理","content":"程序的链接与装入程序的装入程序的链接连续存储分配方式单一连续分配固定分区分配方式动态分区分配（***）基本分页存储管理方式页表地址变换机构（***）基本分段存储管理方式段表地址变换机构（***）分页和分段的主要区别虚拟存储器（***）虚拟存储器实现方法的硬件支持分页请求系统分段请求系统页面置换算法（***）最佳置换算法（理想化）先进先出页面置换算法最近最久未使用置换算法（LRU）clock置换算法简单clock置换算法（最近未访问页面置换算法）改进型clock置换算法最近最少未使用（LFU）练习题目程序的链接与装入程序的装入目的：是将代码装入内存准备执行绝对装入方式可重定位装入方式：动态运行时的装入方式：增加一个重定位寄存器，通过硬件完成地址的修正。真实地址等于逻辑地址+重定位寄存器上的地址程序的链接目的：将目标模块相对独立的地址空间合并成一个地址空间。​静态链接方式对相对地址进行修改变换外部调用符号装入时动态链接运行时动态链接连续存储分配方式目的：给每一个程序分配一片连续的存储空间，容量为程序运行时所需的最大空间。指标：碎片率，越小越好。单一连续分配内存分为系统区和用户区用户区一次只能装入一个程序运行系统区装入操作系统固定分区分配方式将内存划分成固定数目的区域，如图所示：为了实现内存的管理，需要建立固定分区表（数组实现）：程序的大小和分区大小不能完全匹配，所以需要分配大于等于程序大小的内存，分区中浪费的空间称为内碎片动态分区分配（***）操作系统不预设固定数目分区，按照程序内存需求为其划分，内存中分区数目动态变化。数据结构：分配算法：首次适应算法：空闲分区以地址递增的顺序排列，每次从链首开始顺序查找，直到找到一个大小能满足要求的空闲分区为止。然后再按照程序的要求大小，从该空闲分区中划分出一块内存空间给请求者，余下的空闲部分仍留在空闲链表中。特点是低端或高端地址空间被频繁使用。循环首次适应算法：在首次适应算法的基础上，每次查找时从上次找到空闲分区的下一个空闲分区开始查找。特点是空闲分区使用均匀，但是会缺乏大的空闲分区。最佳适应算法：能满足要求、又是最小的空闲分区分配给作业，避免&quot;大材小用”。特点:分区按照大小顺序排列。最差适应算法：每次从空闲分区中选择最大的空闲分区分配给程序，以便切割剩余的空闲分区空间更大。切割操作会产生一些空间过小，总是不会分配给程序，这些空间被称作外碎片。###可重定位分区分配紧凑：通过移动程序，将外碎片合并一个大的空闲分区基本分页存储管理方式离散分配的基本单位是页页表解决了逻辑地址到物理地址的转换的问题：将程序逻辑地址空间划分成固定大小的页面;内存划分成等大小的页框;页表实现页面到页框的索引;页表项个数由程序的逻辑地址空间决定，页表项位数由页框起始物理地址位数决定。记录了页面和页框号（每个页框的起始地址）的对应关系，如下图所示：页表存储了页框的起始物理地址，需要一个连续的存储空间实现随机访问，对于逻辑地址相当于页号+页内偏移。地址变换机构（***）先让页号与页表基址相加得到页框号再让页框号与页内偏移相加得到物理地址基本分段存储管理方式离散分配的基本单位是端采用二维逻辑地址结构，由段号加段内偏移构成段表地址变换机构（***）分页和分段的主要区别页是信息的物理单位；段是信息的逻辑单位。页大小固定；段大小不固定。分页采用一维线性逻辑地址，分段采用二维逻辑地址。虚拟存储器（***）概念：虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器，其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度,每位成本接近外存。虚拟存储器实现方法的硬件支持分页请求系统请求分页的页表机制缺页中断机构地址变换机构分段请求系统请求分段的端表机制缺段中断机构地址变换机构页面置换算法（***）页面中断：发生页面的置换最佳置换算法（理想化）置换以后永不使用或者最长时间不使用的页面发生3次缺页中断和页面中断先进先出页面置换算法淘汰最先进入的页面，即选择在内存中驻留时间最久的页面予以淘汰。最近最久未使用置换算法（LRU）选择最近最久未使用的页面予以淘汰，即当前使用次数最少的页面。实现方式：利用栈保存当前使用的各个页面的页面号,每当进程访问某页面时，便将该页面的页面号从栈中弹出，并将它压入栈顶。因此，栈底是最近最久未使用的页面。使用寄存器，每一次访问都会在寄存器加一，每次置换选择寄存器中次数最少的页面clock置换算法简单clock置换算法（最近未访问页面置换算法）将所有的页面组成一个循环链表,并为每个页面添加一个访问位A。当一个页面被访问时，将其A位设置为1。置换过程是从pointer开始，若该页面的A位为1,将其设置为0,并使pointer指向下一个页面，直到找到A位为0的页面;若该页面的A位为0，则将其置换出内存，并用换入的页面占用换出页面的页框，使pointer指向下一个页面。如果第一轮没有找到，则执行第二轮，由于第一轮将所有页面的A都设置为0，则一定能在第二轮找到改进型clock置换算法增加一个修改为M，页面状态可以分为四类：1类(A=0，M=0)，未访问未修改;2类(A=0，M=1)，未访问.已修改;3类(A=1，M=0)，已访问未修改;4类(A=1,M=1)，已访问已修改;置换过程：从pointer开始寻找1类页面，直到找到1类页面结束，或者扫描完一遍进入第II步。从pointer开始寻找2类页面，直到找到2类页面结束，或者扫描完一遍进入第I步。在本步每扫描完一个页面，须将页面的访问位修改为0。重复l和II。(一定可以找到置换的页。)最近最少未使用（LFU）在最近时期内选择使用次数最少的页面作为淘汰页练习题目","link":"https://xzzz2020.github.io/post/HB2L7VswF/"},{"title":"第三章进程同步与死锁","content":"进程同步信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥利用信号量实现前驱关系资源的分配同步的问题进程间通信死锁的相关概念处理死锁的基本方法预防死锁避免死锁（***）银行家算法（***）检测死锁解除死锁练习题目进程同步临界资源：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源临界区：每个进程中访问临界资源的代码实现互斥的结构：硬件实现：关中断：让处理机始终执行一个程序，不进行程序的切换指令同步应该遵循的规则：空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。忙则等待：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;前驱图：若想执行S2，则需要先执行S1。信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥实现算法：符合：空闲让进，忙则等待和有限等待利用信号量实现前驱关系资源的分配申请资源时需要执行P操作，释放资源时执行V操作同步的问题生产者-消费者问题哲学家进餐问题读者-写者问题进程间通信低级通信：信号量机制高级通讯：共享存储器系统、消息传递系统、管道通信。死锁的相关概念可抢占资源：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。不可抢占的资源：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。死锁的定义：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。产生死锁的原因：竞争不可抢占资源引发死锁。竞争可消耗资源引发死锁。进程推进顺序不当引发死锁。处理死锁的基本方法预防死锁破坏“请求和保持条件”破坏“不可抢占条件”破坏“循环等待条件”：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，必须按照从1到4或者从4到1的顺序申请。避免死锁（***）安全状态：安全状态，是指系统能按某种顺序(P1,P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,直到满足每个进程对资源的最大需求，使每个进程都可以顺利地完成。不安全状态：如果系统无法找到这样一个安全序列，称系统处于不安全状态。要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态银行家算法（***）先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。寻找安全序列的方式只有两种：每次都从最上面开始；按照从上到下顺序循环应用：如果单向顺序，查找安全序列的流程为：判断P0，返现剩余资源不能满足。判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。P0、P1结束，直接跳过。判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。P0、P1、P2、P3结束，直接跳过。判断P4，发现满足，则释放P4分配的资源。最终的安全序列为：P1、P3、P0、P2、P4。确认分配。此时找不到安全序列，拒绝分配。检测死锁解除死锁练习题目","link":"https://xzzz2020.github.io/post/vUwZiOAP9/"},{"title":"第二章处理机管理","content":"程序的执行方式顺序方式（*）并发执行（***）并行执行进程进程的特征进程的状态进程控制块（PCB）进程控制进程的四个操作进程的创建进程的终止进程的阻塞和进程的唤醒进程调度概念进程调度的方式衡量调度算法指标进程调度算法（计算***）先来先服务调度算法（***）短作业优先调度算法（***）高优先权调度算法（***）高响应比优先调度算法时间片轮转调度算法（***）多级队列调度算法多级反馈队列调度算法线程题目练习程序的执行方式顺序方式（*）内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着严格的先后次序顺序执行的特点：顺序性：程序执行有着明确的先后顺序封闭性：程序运行时独占所有资源可再现性：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同问题：无法满足高性能并发执行（***）并发指一段时间内执行多个程序。多个程序同时进入内存，轮流交替执行。并发执行的特点：间断性：交替执行就是走走停停失去了封闭性：程序不再独占系统资源不可再现性：程序执行有多种结果。并行执行同一时刻有多个程序执行，只能在多处理机上实现进程进程是研究并发方式下，程序的执行。进程的概念：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。进程实体：由程序段、相关数据段和PCB组成进程的特征并发性，多个进程在一段时间内同存于内存中同时运行动态性，进程由创建而产生，由调度而执行，由撤消而消亡。独立性，进程是能独立运行、资源分配、调度的基本单位。结构性，进程映像由程序、数据、栈和进程控制块(PCB)构成。异步性，进程按各自独立、不可预知的速度向前推进。进程的状态有三个状态：就绪状态：指程序已经处于准备好运行的状态。执行状态：指程序已经获得CPU，正在执行。阻塞状态：指程序的执行因为某些原因无法继续执行。进程控制块（PCB）用来描述进程的基本情况和活动过程，进而控制和管理进程。（类似于学籍、户口等）进程创建时会建立一个PCB，结束时会收回PCB进程控制块中的信息：进程标识符：包括内部标识符和外部标识符。处理机状态：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。进程控制信息：程序栈和数据地址，同步和通信机制，资源清单,链接指针。进程调度信息进程控制块中的组织方式线性方式链接方式索引方式进程控制进程控制用于创建、终止、阻塞和唤醒进程。进程控制由操作系统内核原语来实现。原语是由若干条指令组成，用于完成一定功能的一个过程，所有的指令要么全做，要么全不做。（一个函数）用户态：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。系统态（内核态）：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。进程的四个操作进程的创建引起进程创建的事件：用户执行应用程序。用户登录。启动服务。程序创建进程。进程创建的过程（必须要求是原语）：申请空白PCB为新进程分配资源，如内存空间等初始化PCB将进程插入就绪队列进程的终止引起进程终止的事件：正常结束。异常结束。外界干预。进程的终止过程：检查进程状态。有无子孙需要终止。归还进程全部资源。将PCB从进程中移除。进程的阻塞和进程的唤醒进程调度概念处理机调度的层次：高级调度低级调度中级调度引起进程调度的事件：进程终止。进程创建。进程阻塞。进程唤醒。外部设备中断。进程切换时需要保存和恢复现场。进程调度的方式抢占式调度：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。非抢占式调度：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（只有时间片用完才能调度）衡量调度算法指标面向用户（***）：平均周转时间：所有周转时间求平均。带权周转时间：一个程序的周转时间除以服务的时间。（&gt;=1）平均带权周转时间：对带权周转时间求平均。周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。面向系统：吞吐量：在单位时间内系统所完成的作业数。处理机利用率：在过去一段时间内CPU被占用的时间总和。各类资源的平衡利用率：保证系统所有的资源被合理利用。进程调度算法（计算***）先来先服务调度算法（***）先来的进程先抢到CPU，有利于长作业，不利于短作业短作业优先调度算法（***）在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。非抢占方式：抢占式：高优先权调度算法（***）按照优先权重分配CPU，优先数越小，优先权越大高响应比优先调度算法按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久响应比=等待时间/服务时间时间片轮转调度算法（***）按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。假设时间片为2。多级队列调度算法优先调度优先级高的多级反馈队列调度算法解决了低优先级队列长时间无法调度的问题线程为什么提出线程？进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。线程概念：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。如下图所示，每个线程都会有个栈，一共有三个线程：线程的特点：一个线程拥有少量的资源，记录在线程控制块中。轻型实体，线程基本上不拥有资源，或者是有较少的资源;一个进程的所有线程共享进程所拥有的全部资源。线程是处理机调度的基本单位，多个线程可以并发执行。线程与进程的比较：线程的实现方式：内核级线程：所有创建、切换等都需要内核的支持，开销较大（适合多处理器系统）用户级线程：可以不需要进入内核态创建，但是切换进程需要进入内核（开销小）组合方式：建立内核级线程与用户级线程的关系。题目练习","link":"https://xzzz2020.github.io/post/IyZhCzd1C/"},{"title":"第一章操作系统引论","content":"操作系统发展操作系统的功能处理机管理存储器管理（内存）设备管理（高效使用IO设备）文件管理操作系统接口操作系统的基本特征操作系统的作用设计目标操作系统结构练习题目操作系统发展无操作系统单道批处理系统多道批处理系统：多个程序交替使用CPU，目的是提高CPU的利用率分时系统：使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了时分复用技术实时系统：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对时间要求苛刻操作系统的功能处理机管理进程控制进程调度进程同步进程通信死锁存储器管理（内存）内存分配内存共享内存扩充内存保护设备管理（高效使用IO设备）设备处理缓冲管理设备分配设备的独立性设备的虚拟性文件管理文件读/写目录管理存储空间管理文件共享、存储性能优化、存储可靠性和数据一致性操作系统接口图形接口系统调用命令调用​操作系统的基本特征并发性：多个程序在同一时间间隔执行共享性：多个并发的程序共同使用计算机资源，提高计算机资源的利用率虚拟性：有时分复用和空分复用两种技术异步性：表现为多任务执行的无序性，主要应对阻塞操作系统的作用操作系统(OperatingSystem,OS)是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。是用户和计算机系统之间的接口是系统资源的管理者扩充计算机的功能，实现对计算机的抽象设计目标方便性有效性扩充性开放性操作系统结构无操作系统结构模块化结构层次结构微内核结构练习题目","link":"https://xzzz2020.github.io/post/ZBrN48x_g/"},{"title":"2020最新-Java面试","content":"学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：https://blog.csdn.net/qq_43040688/article/details/105819866这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。一.数据库1.1关系型数据库MySQL(已更新)推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句SQL语句学习链接基础部分https://blog.csdn.net/qq_43040688/article/details/105346357重点部分https://blog.csdn.net/qq_43040688/article/details/105348610扩展部分https://blog.csdn.net/qq_43040688/article/details/105381801接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构SQL高级部分链接MySQL体系结构和存储引擎介绍https://blog.csdn.net/qq_43040688/article/details/105393816InnoDB存储引擎https://blog.csdn.net/qq_43040688/article/details/105415093MySQL索引https://blog.csdn.net/qq_43040688/article/details/105419053MySQL创建高性能的索引https://blog.csdn.net/qq_43040688/article/details/105454477MySQL查询性能优化https://blog.csdn.net/qq_43040688/article/details/105456790MySQL锁https://blog.csdn.net/qq_43040688/article/details/105440448MySQL事务https://blog.csdn.net/qq_43040688/article/details/105441274MySQL备份https://blog.csdn.net/qq_43040688/article/details/105441944MySQL架构https://blog.csdn.net/qq_43040688/article/details/105450005MySQL高级特性https://blog.csdn.net/qq_43040688/article/details/105465192分库分表的高频面试题https://blog.csdn.net/qq_43040688/article/details/1055946531.2非关系型数据库Redis二、Java基础2.1Java虚拟机（已更新）虛拟机推荐《深入理解Java虚拟机》这本书，重点学习一下内存、垃圾回收、类加载机制这几部分内容。JVM内存结构链接JVM简介https://blog.csdn.net/qq_43040688/article/details/104964070程序计数器和虚拟机栈https://blog.csdn.net/qq_43040688/article/details/104970081本地方法栈和堆https://blog.csdn.net/qq_43040688/article/details/104972811方法区https://blog.csdn.net/qq_43040688/article/details/104982648直接内存https://blog.csdn.net/qq_43040688/article/details/1049960322.2Java并发（已更新）Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久Java并发基础学习Java并发，需要先掌握线程的一些基础知识这些基础知识的组合构成了后面的设计模式首先应该了解如何启动一个多线程，即使用Runnable、Callable、Thread；还需要了解线程启动后的生命周期，了解了不用实现方式的差别，最重要的研读Thread的源码，详情参考：Java多线程起步，Thread构造函数源码分析需要学习Thread常用API以及三种关闭线程的方式，详情参考：Thread的API需要了解this锁和class锁，详情参考：Java多线程之认识“锁”需要了解线程间的通讯，最基本的就是消费者和生产者模型，需要深入了解了wait、sleep、notify、nitifyAll的机制和差异，对于waitset要有个清晰的认识，详情参考：Java多线程之线程间的通讯需要尝试自定义了一个Boolean锁，了解了加锁和释放锁的过程，实现了获取正在阻塞的线程；需要了解线程运行时出现异常的处理方式，详情参考：自定义Boolean锁&amp;捕获线程中的异常需要学习了线程组的概念以及常用API，如interrupt，setDaemon，activeCount，enumerate，详情参考：线程组需要自定义了一个线程池，对线程池的处理机制有了较深的理解，详情参考：自定义线程池Java并发基础链接Java多线程起步https://blog.csdn.net/qq_43040688/article/details/103979628Thread构造函数源码分析https://blog.csdn.net/qq_43040688/article/details/105543926Thread的APIhttps://blog.csdn.net/qq_43040688/article/details/105747547Java多线程之认识“锁”https://blog.csdn.net/qq_43040688/article/details/105752943Java多线程之线程间的通讯https://blog.csdn.net/qq_43040688/article/details/105754406自定义Boolean锁&amp;捕获线程中的异常https://blog.csdn.net/qq_43040688/article/details/105771445线程组https://blog.csdn.net/qq_43040688/article/details/105774614自定义线程池https://blog.csdn.net/qq_43040688/article/details/105786243多线程的设计模式Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合以满足应用需求下面有十四个多线程的设计模式，帮助理解后面的JUC包。第一个设计模式是：观察者模式。需要定义一个主题，一个观察者。主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。详情参考：观察者模式第二个设计模式是：单例模式。解决方式有三种：第一种是doublecheck方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static类实现；第三种是利用enum类实现。详情参考：单例模式第三个设计模式是单线程执行模式。就是在同一时刻只能有一个对共享资源进行操作。详情参考：单线程执行设计模式第四个设计模式不可变对象设计模式。是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。详情参考：不可变对象设计模式第五个设计模式确保挂起设计模式。当线程在工作时，如果来了其他任务，将任务放入到队列中等待。详情参考：确保挂起设计模式第六个设计模式Balking设计模式。当工作已经执行过了，就直接return，防止重复的工作，提高效率。详情参考：Balking设计模式第七个设计模式生产者-消费者设计模式。如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。详情参考：生产者-消费者设计模式第七个设计模式读写锁的设计模式。读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能。详情参考：读写锁的设计模式第八个设计模式Thread-Per-Message。每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。详情参考：Thread-Per-Message第九个设计模式Worker设计模式。需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。详情参考：Worker设计模式第十个设计模式Future设计模式。通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。详情参考：Future设计模式第十一个设计模式两阶段终止设计模式。当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。详情参考：两阶段终止设计模式第十二个设计模式线程保险箱设计模式。利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。详情参考：线程保险箱设计模式和上下文设计模式第十三个设计模式ActiveObjects设计模式。接受异步调用的主动方法。可以主动异步的执行一些任务。详情参考：ActiveObjects设计模式第十四个设计模式CountDown设计模式。多个子任务执行，主任务等待子任务全部执行完，再执行详情参考：CountDown设计模式多线程的设计模式链接观察者模式https://blog.csdn.net/qq_43040688/article/details/105835544单例模式https://blog.csdn.net/qq_43040688/article/details/105798423单线程执行设计模式https://blog.csdn.net/qq_43040688/article/details/105856901不可变对象设计模式https://blog.csdn.net/qq_43040688/article/details/105865371确保挂起设计模式https://blog.csdn.net/qq_43040688/article/details/105886681Balking设计模式https://blog.csdn.net/qq_43040688/article/details/105890674生产者-消费者设计模式https://blog.csdn.net/qq_43040688/article/details/105891561读写锁的设计模式https://blog.csdn.net/qq_43040688/article/details/105857920Thread-Per-Messagehttps://blog.csdn.net/qq_43040688/article/details/105892219Worker设计模式https://blog.csdn.net/qq_43040688/article/details/105894685Future设计模式https://blog.csdn.net/qq_43040688/article/details/105868293两阶段终止设计模式https://blog.csdn.net/qq_43040688/article/details/105892777线程保险箱设计模式https://blog.csdn.net/qq_43040688/article/details/105887378上下文设计模式https://blog.csdn.net/qq_43040688/article/details/105888242ActiveObjects设计模式https://blog.csdn.net/qq_43040688/article/details/105895280CountDown设计模式https://blog.csdn.net/qq_43040688/article/details/105892054Java高并发与JVM的关系主要是学习waitset、JMM模型JMM模型中有四个内容，主要参看博客：Java多线程之内存模型三大特性。如果想学习更多，请学习JVM的部分。解决高速缓存中数据不一致性的问题——总线锁（效率低）、高速缓存一致性协议，英特尔高并发的三个要求——原子性、可见性、有序性happens-before指令重排序Java多线程之内存模型三大特性：https://blog.csdn.net/qq_43040688/article/details/105823532原子包CAS：乐观锁，CompareAndSwap。优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。缺点：在竞争激烈的情况下，浪费CUP资源。还有一个问题是ABA问题，解决方法是：加一个版本号。详情参考：CASUnSafe类内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式获取Unsafe需要通过反射Unsafe类的属性常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现详情参考：UnSafe类AtomicInteger和AtomicBoolean：是保证原子性的对象。利用的CAS详情参考：AtomicInteger和AtomicBooleanAtomicReference是一个利用CAS帮助对象保证原子性的但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：CAS详情参考：AtomicReference文章名称链接CAShttps://blog.csdn.net/qq_43040688/article/details/105914717AtomicIntegerhttps://blog.csdn.net/qq_43040688/article/details/105908835AtomicBooleanhttps://blog.csdn.net/qq_43040688/article/details/105917939AtomicReferencehttps://blog.csdn.net/qq_43040688/article/details/105918329UnSafe类https://blog.csdn.net/qq_43040688/article/details/105923421JUC工具包CountDownLatch通过一个计数器实现，计数器初始值就是线程的数量每当一个线程完成任务，就会使计数减一可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成详情见：CountDownLatchCyclicBarrier跟CountDownLatch的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点详情见：CyclicBarrierPhaserJDK1.7之后引用的，具有CyclicBarrier和CountDownLatch同时它的注册数是支持动态增加或减少（可以用于线程出现异常）当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复详情见：PhaserExchanger用于线程间交换数据需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题详情见：ExchangerSemaphore是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问详情见：SemaphoreReentrantLock支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞需要手动的释放锁，try...finally...相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高是一个Java类，具有更多的功能，同时可以自由的扩展详情请见：ReentrantLock读写锁将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能是悲观锁，可能读的线程太多，写的线程迟迟难以执行详情请见：读写锁StampedLock解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据详情请见：StampedLock三种锁的比较synchronizedStampedLockLock是JVM的的内置锁，每个JDK版本都会优化是一个Java类，可以更好的扩展是一个Java类，可以更好的扩展都是悲观锁提供了写的乐观锁都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁性能一般，因为有一个从用户态到内核态的过程性能最好，可以代替读写锁性能十分不稳定，在复杂的读写环境下，性能十分差详情请见：三种锁的比较ForkJoin基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行分为Fork和Join两个阶段，充分利用CPU资源详情请见：ForkJoin文章名称链接CountDownLatchhttps://blog.csdn.net/qq_43040688/article/details/105935307CyclicBarrierhttps://blog.csdn.net/qq_43040688/article/details/105937169Phaserhttps://blog.csdn.net/qq_43040688/article/details/106033183Exchangerhttps://blog.csdn.net/qq_43040688/article/details/105955788Semaphorehttps://blog.csdn.net/qq_43040688/article/details/105956731ReentrantLockhttps://blog.csdn.net/qq_43040688/article/details/105958719读写锁https://blog.csdn.net/qq_43040688/article/details/105975257StampedLockhttps://blog.csdn.net/qq_43040688/article/details/106026847三种锁的比较https://blog.csdn.net/qq_43040688/article/details/106032189ForkJoinhttps://blog.csdn.net/qq_43040688/article/details/106032309Exectors框架首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。ThreadPoolExecutor创建线程池有七大参数，特别重要有四种拒绝策略四种阻塞队列一些调试的API关闭线程池的注意事项详情请见：ThreadPoolExecutorExecutors用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：newCachedThreadPoolnewFixedThreadPoolnewScheduledThreadPoolnewSingleThreadExecutornewWorkStealingPool详情请见：ExecutorsCompletionService用来增强线程池，主要思想是：执行一批任务，先执行的，先获取结果实现的子类是：ExecutorCompletionService详情请见：CompletionServiceCompleableFuture可以进行串联的操作，即利用上一个任务的结果，执行下一个任务进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果可以不需要调用者主动获取结果，而进行回调执行一批任务时，获取的Future是按照任务完成的顺序创建CompleableFuture有多种方式，最多的是runAsync和supplyAsyncAPI分为组合方法、中转方法和终结方法详情请见：CompleableFuture文章名称链接ThreadPoolExecutorhttps://blog.csdn.net/qq_43040688/article/details/106041236Executorshttps://blog.csdn.net/qq_43040688/article/details/106046629CompletionServicehttps://blog.csdn.net/qq_43040688/article/details/106058225CompleableFuturehttps://blog.csdn.net/qq_43040688/article/details/106061776","link":"https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/"},{"title":"RocketMQ监控平台（附网盘链接）","content":"RocketMQ有一个对其扩展的开源项目incubator-rocketmq-externals，这个项目中有一个子模块叫rocketmq-console，这个便是管理控制台项目了，先将incubator-rocketmq-externals拉到本地，因为我们需要自己对rocketmq-console进行编译打包运行。在linux环境下，使用nohubjava-jarxxxx&amp;启动，为了防止端口冲突，已经修改其端口为9999链接：https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA提取码：jpg03.5.2下载并编译打包gitclonehttps://github.com/apache/rocketmq-externalscdrocketmq-consolemvncleanpackage-Dmaven.test.skip=true注意：打包前在rocketmq-console中配置namesrv集群地址：rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876启动rocketmq-console：java-jarrocketmq-console-ng-1.0.0.jar启动成功后，我们就可以通过浏览器访问http://localhost:8080进入控制台界面了，如下图：","link":"https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/"},{"title":"⚡️Build a blog platform","content":"在学习技术的过程中，博客是一个总结的过程，十分重要。该文章主要介绍如何搭建一个属于自己的个人博客，点击查看博主博客关于本博客Gridea主题评论评论管理系统博客撰写关于本博客本博客基于github和gitee的静态页，国内用户推荐使用gitee，访问速度更快。如果在学习过程中，出现了什么问题，可以在下方评论，博主会收到的。技术概要如下：博客框架采用的是Gridea主题基于bitcron-pro评论系统使用的Valine评论管理系统使用的Valine-Admin博客使用Typora编写图片上传采用的是PicGO+腾讯COSGrideaGridea是一个博客管理软件，支持Windos和Mac，十分好用，页面也比较好看，但是目前不支持gitee，所以需要写一段代码自己提交。页面如下：下载地址：https://gridea.dev/由于下载速度的原因，提供百度网盘下载0.9.2版本：链接：https://pan.baidu.com/s/1lgQGgiCrVRpvdeeCkaHqSg提取码：73ne下载完成后，先使用github搭建，如果同步成功即可完成。学习文档：https://www.jianshu.com/p/6ddc767b1569想要在gitee快速搭建，首先需要在gitee搭建一个仓库，参考：https://blog.csdn.net/qq_36667170/article/details/79318578下面步骤需要会Git！！！！每次推送到github的博客都是在这个目录下C:\\Users\\正好\\Documents\\Gridea\\output，只需要将这个目下的文件，除了.git文件下外所用的文件覆盖到你本地gitee的仓库。然后需要对这些文件递归调用将其中github的地址替换成gitee，博主使用Java写了一个工具，需要将里面的目录地址修改即可，百度网盘下载地址：链接：https://pan.baidu.com/s/1lg770AMzhgSG_U4SQ5kWRA提取码：n2n7将下图的代码变成你gitee的文件夹即可，逻辑就是遍历文件夹，读取每个文件替换语句。但是我把图片、CSS、JS的文件夹屏蔽了，防止造成影响。接着就是Git提交到gitee仓库，然后重新部署gitee的pages的服务。进入提示的网站地址，刷新一下浏览器就出来了。主题目前使用的主题基于这个项目：https://github.com/qyxtim/bitcron-progit下来后，将bitcron-pro文件夹，放到Gridea的主题目录，如C:\\Users\\正好\\Documents\\Gridea\\themes但是该主题不支持Valine评论，所以对其需要进行一些修改，在下面会有介绍。评论评论是基于Valine的，这有一篇博客可以学习：https://ioliu.cn/2017/add-valine-comments-to-your-blog/由于bitcron-pro不支持该评论Valine但是支持Gitalk，可以通过修改代码实现。需要修改的文件目录，博主本机上是：C:\\Users\\正好\\Documents\\Gridea\\themes\\bitcron-pro\\templates\\_blocks下面的gitalk.ejs将里面所有内容删除，添加下面一段：&lt;!--评论显示区，请插入合适的位置--&gt;&lt;divid=&quot;comment&quot;&gt;&lt;/div&gt;&lt;!--Leancloud操作库:--&gt;&lt;scriptsrc=&quot;//cdn1.lncld.net/static/js/3.6.1/av-min.js&quot;&gt;&lt;/script&gt;&lt;!--Valine的核心代码库--&gt;&lt;scriptsrc=&quot;//cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;newValine({el:'#comment',appId:'??????????',appKey:'?????????',placeholder:'ヾﾉ≧∀≦)o快来评论一下吧!',avatar:''});&lt;/script&gt;appId和appKey需要在LeanCloud管理页面查看：配置完成记得在Gridea的Gitalk页面单击一下保存，就会应用到博客上。评论管理系统Valine自带一个Valine-Admain的开源项目，会在评论时，给博主予以提醒，需要基于LeanCloud实现。目前LeanCloud不再提供免费的二级域名，所以最好在阿里云或者腾讯云买一个，在各个地方都用的到需要参考的文章：https://blog.csdn.net/u012208219/article/details/106883083后台页面如下所示：邮件提醒页面：当前LeanCloud定时唤醒任务执行时会提示：因流控原因，通过定时任务唤醒体验版实例失败，建议升级至标准版云引擎实例避免休眠参考这篇文章建立监控：https://blog.csdn.net/Lott0419/article/details/106819895博客撰写博主使用的Typora，但是使用这个写博客图片是保存到本地的，所以就需要利用PicGo+图床上传到网络中Typora0.9.86百度网盘下载：链接：https://pan.baidu.com/s/1aO3jyACQYvBubAjq2QhpGg提取码：920iPicGo2.3.0百度网盘下载：链接：https://pan.baidu.com/s/1wqfzmSt-s9yoa4jstOYnUw提取码：rnu8然后就是需要配置PicGo，如果想要使用腾讯COS当图床，参考这篇文章：https://zhuanlan.zhihu.com/p/119250383，当然还可以使用gitee仓库，不过对象存储真心不贵。Gridea可以提供背景图库，我这边有几个网站推荐，都是免费的图片下载网站：http://www.polayoutu.com/collectionshttps://www.hippopx.com/zhhttps://unsplash.com/","link":"https://xzzz2020.github.io/post/Build_blog/"}]}