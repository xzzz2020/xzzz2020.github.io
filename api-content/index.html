{"posts":[{"title":"2020最新-Java面试","content":"学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：https://blog.csdn.net/qq_43040688/article/details/105819866这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。一.数据库1.1关系型数据库MySQL(已更新)推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句SQL语句学习链接基础部分https://blog.csdn.net/qq_43040688/article/details/105346357重点部分https://blog.csdn.net/qq_43040688/article/details/105348610扩展部分https://blog.csdn.net/qq_43040688/article/details/105381801接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构SQL高级部分链接MySQL体系结构和存储引擎介绍https://blog.csdn.net/qq_43040688/article/details/105393816InnoDB存储引擎https://blog.csdn.net/qq_43040688/article/details/105415093MySQL索引https://blog.csdn.net/qq_43040688/article/details/105419053MySQL创建高性能的索引https://blog.csdn.net/qq_43040688/article/details/105454477MySQL查询性能优化https://blog.csdn.net/qq_43040688/article/details/105456790MySQL锁https://blog.csdn.net/qq_43040688/article/details/105440448MySQL事务https://blog.csdn.net/qq_43040688/article/details/105441274MySQL备份https://blog.csdn.net/qq_43040688/article/details/105441944MySQL架构https://blog.csdn.net/qq_43040688/article/details/105450005MySQL高级特性https://blog.csdn.net/qq_43040688/article/details/105465192分库分表的高频面试题https://blog.csdn.net/qq_43040688/article/details/1055946531.2非关系型数据库Redis二、Java基础2.1Java虚拟机（已更新）虛拟机推荐《深入理解Java虚拟机》这本书，重点学习一下内存、垃圾回收、类加载机制这几部分内容。JVM内存结构链接JVM简介https://blog.csdn.net/qq_43040688/article/details/104964070程序计数器和虚拟机栈https://blog.csdn.net/qq_43040688/article/details/104970081本地方法栈和堆https://blog.csdn.net/qq_43040688/article/details/104972811方法区https://blog.csdn.net/qq_43040688/article/details/104982648直接内存https://blog.csdn.net/qq_43040688/article/details/1049960322.2Java并发（已更新）Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久Java并发基础学习Java并发，需要先掌握线程的一些基础知识这些基础知识的组合构成了后面的设计模式首先应该了解如何启动一个多线程，即使用Runnable、Callable、Thread；还需要了解线程启动后的生命周期，了解了不用实现方式的差别，最重要的研读Thread的源码，详情参考：Java多线程起步，Thread构造函数源码分析需要学习Thread常用API以及三种关闭线程的方式，详情参考：Thread的API需要了解this锁和class锁，详情参考：Java多线程之认识“锁”需要了解线程间的通讯，最基本的就是消费者和生产者模型，需要深入了解了wait、sleep、notify、nitifyAll的机制和差异，对于waitset要有个清晰的认识，详情参考：Java多线程之线程间的通讯需要尝试自定义了一个Boolean锁，了解了加锁和释放锁的过程，实现了获取正在阻塞的线程；需要了解线程运行时出现异常的处理方式，详情参考：自定义Boolean锁&amp;捕获线程中的异常需要学习了线程组的概念以及常用API，如interrupt，setDaemon，activeCount，enumerate，详情参考：线程组需要自定义了一个线程池，对线程池的处理机制有了较深的理解，详情参考：自定义线程池Java并发基础链接Java多线程起步https://blog.csdn.net/qq_43040688/article/details/103979628Thread构造函数源码分析https://blog.csdn.net/qq_43040688/article/details/105543926Thread的APIhttps://blog.csdn.net/qq_43040688/article/details/105747547Java多线程之认识“锁”https://blog.csdn.net/qq_43040688/article/details/105752943Java多线程之线程间的通讯https://blog.csdn.net/qq_43040688/article/details/105754406自定义Boolean锁&amp;捕获线程中的异常https://blog.csdn.net/qq_43040688/article/details/105771445线程组https://blog.csdn.net/qq_43040688/article/details/105774614自定义线程池https://blog.csdn.net/qq_43040688/article/details/105786243多线程的设计模式Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合以满足应用需求下面有十四个多线程的设计模式，帮助理解后面的JUC包。第一个设计模式是：观察者模式。需要定义一个主题，一个观察者。主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。详情参考：观察者模式第二个设计模式是：单例模式。解决方式有三种：第一种是doublecheck方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static类实现；第三种是利用enum类实现。详情参考：单例模式第三个设计模式是单线程执行模式。就是在同一时刻只能有一个对共享资源进行操作。详情参考：单线程执行设计模式第四个设计模式不可变对象设计模式。是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。详情参考：不可变对象设计模式第五个设计模式确保挂起设计模式。当线程在工作时，如果来了其他任务，将任务放入到队列中等待。详情参考：确保挂起设计模式第六个设计模式Balking设计模式。当工作已经执行过了，就直接return，防止重复的工作，提高效率。详情参考：Balking设计模式第七个设计模式生产者-消费者设计模式。如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。详情参考：生产者-消费者设计模式第七个设计模式读写锁的设计模式。读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能。详情参考：读写锁的设计模式第八个设计模式Thread-Per-Message。每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。详情参考：Thread-Per-Message第九个设计模式Worker设计模式。需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。详情参考：Worker设计模式第十个设计模式Future设计模式。通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。详情参考：Future设计模式第十一个设计模式两阶段终止设计模式。当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。详情参考：两阶段终止设计模式第十二个设计模式线程保险箱设计模式。利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。详情参考：线程保险箱设计模式和上下文设计模式第十三个设计模式ActiveObjects设计模式。接受异步调用的主动方法。可以主动异步的执行一些任务。详情参考：ActiveObjects设计模式第十四个设计模式CountDown设计模式。多个子任务执行，主任务等待子任务全部执行完，再执行详情参考：CountDown设计模式多线程的设计模式链接观察者模式https://blog.csdn.net/qq_43040688/article/details/105835544单例模式https://blog.csdn.net/qq_43040688/article/details/105798423单线程执行设计模式https://blog.csdn.net/qq_43040688/article/details/105856901不可变对象设计模式https://blog.csdn.net/qq_43040688/article/details/105865371确保挂起设计模式https://blog.csdn.net/qq_43040688/article/details/105886681Balking设计模式https://blog.csdn.net/qq_43040688/article/details/105890674生产者-消费者设计模式https://blog.csdn.net/qq_43040688/article/details/105891561读写锁的设计模式https://blog.csdn.net/qq_43040688/article/details/105857920Thread-Per-Messagehttps://blog.csdn.net/qq_43040688/article/details/105892219Worker设计模式https://blog.csdn.net/qq_43040688/article/details/105894685Future设计模式https://blog.csdn.net/qq_43040688/article/details/105868293两阶段终止设计模式https://blog.csdn.net/qq_43040688/article/details/105892777线程保险箱设计模式https://blog.csdn.net/qq_43040688/article/details/105887378上下文设计模式https://blog.csdn.net/qq_43040688/article/details/105888242ActiveObjects设计模式https://blog.csdn.net/qq_43040688/article/details/105895280CountDown设计模式https://blog.csdn.net/qq_43040688/article/details/105892054Java高并发与JVM的关系主要是学习waitset、JMM模型JMM模型中有四个内容，主要参看博客：Java多线程之内存模型三大特性。如果想学习更多，请学习JVM的部分。解决高速缓存中数据不一致性的问题——总线锁（效率低）、高速缓存一致性协议，英特尔高并发的三个要求——原子性、可见性、有序性happens-before指令重排序Java多线程之内存模型三大特性：https://blog.csdn.net/qq_43040688/article/details/105823532原子包CAS：乐观锁，CompareAndSwap。优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。缺点：在竞争激烈的情况下，浪费CUP资源。还有一个问题是ABA问题，解决方法是：加一个版本号。详情参考：CASUnSafe类内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式获取Unsafe需要通过反射Unsafe类的属性常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现详情参考：UnSafe类AtomicInteger和AtomicBoolean：是保证原子性的对象。利用的CAS详情参考：AtomicInteger和AtomicBooleanAtomicReference是一个利用CAS帮助对象保证原子性的但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：CAS详情参考：AtomicReference文章名称链接CAShttps://blog.csdn.net/qq_43040688/article/details/105914717AtomicIntegerhttps://blog.csdn.net/qq_43040688/article/details/105908835AtomicBooleanhttps://blog.csdn.net/qq_43040688/article/details/105917939AtomicReferencehttps://blog.csdn.net/qq_43040688/article/details/105918329UnSafe类https://blog.csdn.net/qq_43040688/article/details/105923421JUC工具包CountDownLatch通过一个计数器实现，计数器初始值就是线程的数量每当一个线程完成任务，就会使计数减一可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成详情见：CountDownLatchCyclicBarrier跟CountDownLatch的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点详情见：CyclicBarrierPhaserJDK1.7之后引用的，具有CyclicBarrier和CountDownLatch同时它的注册数是支持动态增加或减少（可以用于线程出现异常）当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复详情见：PhaserExchanger用于线程间交换数据需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题详情见：ExchangerSemaphore是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问详情见：SemaphoreReentrantLock支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞需要手动的释放锁，try...finally...相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高是一个Java类，具有更多的功能，同时可以自由的扩展详情请见：ReentrantLock读写锁将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能是悲观锁，可能读的线程太多，写的线程迟迟难以执行详情请见：读写锁StampedLock解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据详情请见：StampedLock三种锁的比较synchronizedStampedLockLock是JVM的的内置锁，每个JDK版本都会优化是一个Java类，可以更好的扩展是一个Java类，可以更好的扩展都是悲观锁提供了写的乐观锁都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁性能一般，因为有一个从用户态到内核态的过程性能最好，可以代替读写锁性能十分不稳定，在复杂的读写环境下，性能十分差详情请见：三种锁的比较ForkJoin基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行分为Fork和Join两个阶段，充分利用CPU资源详情请见：ForkJoin文章名称链接CountDownLatchhttps://blog.csdn.net/qq_43040688/article/details/105935307CyclicBarrierhttps://blog.csdn.net/qq_43040688/article/details/105937169Phaserhttps://blog.csdn.net/qq_43040688/article/details/106033183Exchangerhttps://blog.csdn.net/qq_43040688/article/details/105955788Semaphorehttps://blog.csdn.net/qq_43040688/article/details/105956731ReentrantLockhttps://blog.csdn.net/qq_43040688/article/details/105958719读写锁https://blog.csdn.net/qq_43040688/article/details/105975257StampedLockhttps://blog.csdn.net/qq_43040688/article/details/106026847三种锁的比较https://blog.csdn.net/qq_43040688/article/details/106032189ForkJoinhttps://blog.csdn.net/qq_43040688/article/details/106032309Exectors框架首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。ThreadPoolExecutor创建线程池有七大参数，特别重要有四种拒绝策略四种阻塞队列一些调试的API关闭线程池的注意事项详情请见：ThreadPoolExecutorExecutors用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：newCachedThreadPoolnewFixedThreadPoolnewScheduledThreadPoolnewSingleThreadExecutornewWorkStealingPool详情请见：ExecutorsCompletionService用来增强线程池，主要思想是：执行一批任务，先执行的，先获取结果实现的子类是：ExecutorCompletionService详情请见：CompletionServiceCompleableFuture可以进行串联的操作，即利用上一个任务的结果，执行下一个任务进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果可以不需要调用者主动获取结果，而进行回调执行一批任务时，获取的Future是按照任务完成的顺序创建CompleableFuture有多种方式，最多的是runAsync和supplyAsyncAPI分为组合方法、中转方法和终结方法详情请见：CompleableFuture文章名称链接ThreadPoolExecutorhttps://blog.csdn.net/qq_43040688/article/details/106041236Executorshttps://blog.csdn.net/qq_43040688/article/details/106046629CompletionServicehttps://blog.csdn.net/qq_43040688/article/details/106058225CompleableFuturehttps://blog.csdn.net/qq_43040688/article/details/106061776","link":"https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/"},{"title":"RocketMQ监控平台（附网盘链接）","content":"RocketMQ有一个对其扩展的开源项目incubator-rocketmq-externals，这个项目中有一个子模块叫rocketmq-console，这个便是管理控制台项目了，先将incubator-rocketmq-externals拉到本地，因为我们需要自己对rocketmq-console进行编译打包运行。在linux环境下，使用nohubjava-jarxxxx&amp;启动，为了防止端口冲突，已经修改其端口为9999链接：https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA提取码：jpg03.5.2下载并编译打包gitclonehttps://github.com/apache/rocketmq-externalscdrocketmq-consolemvncleanpackage-Dmaven.test.skip=true注意：打包前在rocketmq-console中配置namesrv集群地址：rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876启动rocketmq-console：java-jarrocketmq-console-ng-1.0.0.jar启动成功后，我们就可以通过浏览器访问http://localhost:8080进入控制台界面了，如下图：","link":"https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/"}]}