{"posts":[{"title":"第三章进程同步与死锁","content":"进程同步临界资源：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源临界区：每个进程中访问临界资源的代码实现互斥的结构：硬件实现：关中断：让处理机始终执行一个程序，不进行程序的切换指令同步应该遵循的规则：空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。忙则等待：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;前驱图：若想执行S2，则需要先执行S1。信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥实现算法：符合：空闲让进，忙则等待和有限等待利用信号量实现前驱关系资源的分配申请资源时需要执行P操作，释放资源时执行V操作同步的问题生产者-消费者问题哲学家进餐问题读者-写者问题进程间通信低级通信：信号量机制高级通讯：共享存储器系统、消息传递系统、管道通信。死锁的相关概念可抢占资源：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。不可抢占的资源：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。死锁的定义：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。产生死锁的原因：竞争不可抢占资源引发死锁。竞争可消耗资源引发死锁。进程推进顺序不当引发死锁。处理死锁的基本方法预防死锁破坏“请求和保持条件”破坏“不可抢占条件”破坏“循环等待条件”：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，必须按照从1到4或者从4到1的顺序申请。避免死锁（***）安全状态：安全状态，是指系统能按某种顺序(P1,P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,直到满足每个进程对资源的最大需求，使每个进程都可以顺利地完成。不安全状态：如果系统无法找到这样一个安全序列，称系统处于不安全状态。要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态银行家算法（***）先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。寻找安全序列的方式只有两种：每次都从最上面开始；按照从上到下顺序循环应用：如果单向顺序，查找安全序列的流程为：判断P0，返现剩余资源不能满足。判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。P0、P1结束，直接跳过。判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。P0、P1、P2、P3结束，直接跳过。判断P4，发现满足，则释放P4分配的资源。最终的安全序列为：P1、P3、P0、P2、P4。确认分配。此时找不到安全序列，拒绝分配。检测死锁解除死锁练习题目","link":"https://xzzz2020.github.io/post/vUwZiOAP9/"},{"title":"第二章处理机管理","content":"程序的执行方式顺序方式（*）内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着严格的先后次序顺序执行的特点：顺序性：程序执行有着明确的先后顺序封闭性：程序运行时独占所有资源可再现性：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同问题：无法满足高性能并发执行（***）并发指一段时间内执行多个程序。多个程序同时进入内存，轮流交替执行。并发执行的特点：间断性：交替执行就是走走停停失去了封闭性：程序不再独占系统资源不可再现性：程序执行有多种结果。并行执行同一时刻有多个程序执行，只能在多处理机上实现进程进程是研究并发方式下，程序的执行。进程的概念：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。进程实体：由程序段、相关数据段和PCB组成进程的状态有三个状态：就绪状态：指程序已经处于准备好运行的状态。执行状态：指程序已经获得CPU，正在执行。阻塞状态：指程序的执行因为某些原因无法继续执行。进程控制块（PCB）用来描述进程的基本情况和活动过程，进而控制和管理进程。（类似于学籍、户口等）进程创建时会建立一个PCB，结束时会收回PCB进程控制块中的信息：进程标识符：包括内部标识符和外部标识符。处理机状态：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。进程控制信息：程序栈和数据地址，同步和通信机制，资源清单,链接指针。进程调度信息进程控制块中的组织方式线性方式链接方式索引方式进程控制进程控制用于创建、终止、阻塞和唤醒进程。进程控制由操作系统内核原语来实现。原语是由若干条指令组成，用于完成一定功能的一个过程，所有的指令要么全做，要么全不做。（一个函数）用户态：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。系统态（内核态）：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。进程的四个操作进程的创建引起进程创建的事件：用户执行应用程序。用户登录。启动服务。程序创建进程。进程创建的过程（必须要求是原语）：申请空白PCB为新进程分配资源，如内存空间等初始化PCB将进程插入就绪队列进程的终止引起进程终止的事件：正常结束。异常结束。外界干预。进程的终止过程：检查进程状态。有无子孙需要终止。归还进程全部资源。将PCB从进程中移除。进程的阻塞和进程的唤醒进程调度概念处理机调度的层次：高级调度低级调度中级调度引起进程调度的事件：进程终止。进程创建。进程阻塞。进程唤醒。外部设备中断。进程切换时需要保存和恢复现场。进程调度的方式抢占式调度：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。非抢占式调度：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（只有时间片用完才能调度）衡量调度算法指标面向用户（***）：平均周转时间：所有周转时间求平均。带权周转时间：一个程序的周转时间除以服务的时间。（&gt;=1）平均带权周转时间：对带权周转时间求平均。周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。面向系统：吞吐量：在单位时间内系统所完成的作业数。处理机利用率：在过去一段时间内CPU被占用的时间总和。各类资源的平衡利用率：保证系统所有的资源被合理利用。进程调度算法（计算）先来先服务调度算法（FCFS）先来的进程先抢到CPU，有利于长作业，不利于短作业短作业优先调度算法在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。非抢占方式：抢占式：高优先权调度算法按照优先权重分配CPU，优先数越小，优先权越大高响应比优先调度算法按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久响应比=等待时间/服务时间时间片轮转调度算法按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。假设时间片为2。多级队列调度算法优先调度优先级高的多级反馈队列调度算法解决了低优先级队列长时间无法调度的问题线程为什么提出线程？进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。线程概念：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。如下图所示，每个线程都会有个栈，一共有三个线程：线程的特点：一个线程拥有少量的资源，记录在线程控制块中。轻型实体，线程基本上不拥有资源，或者是有较少的资源;一个进程的所有线程共享进程所拥有的全部资源。线程是处理机调度的基本单位，多个线程可以并发执行。线程与进程的比较：线程的实现方式：内核级线程：所有创建、切换等都需要内核的支持，开销较大（适合多处理器系统）用户级线程：可以不需要进入内核态创建，但是切换进程需要进入内核（开销小）组合方式：建立内核级线程与用户级线程的关系。题目练习","link":"https://xzzz2020.github.io/post/IyZhCzd1C/"},{"title":"第一章操作系统引论","content":"操作系统发展无操作系统单道批处理系统多道批处理系统分时系统：使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了时分复用技术现代操作系统：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对时间要求苛刻操作系统的功能处理机管理进程控制进程调度进程同步进程通信死锁存储器管理（内存）内存分配内存共享内存扩充内存保护设备管理（高效使用IO设备）设备处理缓冲管理设备分配设备的独立性设备的虚拟性文件管理文件读/写目录管理存储空间管理文件共享、存储性能优化、存储可靠性和数据一致性操作系统接口图形接口系统调用命令调用​操作系统的基本特征并发性：多个程序在同一时间间隔执行共享性：多个并发的程序共同使用计算机资源，提高计算机资源的利用率虚拟性：有时分复用和空分复用两种技术异步性：表现为多任务执行的无序性，主要应对阻塞操作系统的作用操作系统(OperatingSystem,OS)是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。是用户和计算机系统之间的接口是系统资源的管理者扩充计算机的功能，实现对计算机的抽象设计目标方便性有效性扩充性开放性操作系统结构无操作系统结构模块化结构层次结构微内核结构练习题目","link":"https://xzzz2020.github.io/post/ZBrN48x_g/"},{"title":"2020最新-Java面试","content":"学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：https://blog.csdn.net/qq_43040688/article/details/105819866这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。一.数据库1.1关系型数据库MySQL(已更新)推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句SQL语句学习链接基础部分https://blog.csdn.net/qq_43040688/article/details/105346357重点部分https://blog.csdn.net/qq_43040688/article/details/105348610扩展部分https://blog.csdn.net/qq_43040688/article/details/105381801接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构SQL高级部分链接MySQL体系结构和存储引擎介绍https://blog.csdn.net/qq_43040688/article/details/105393816InnoDB存储引擎https://blog.csdn.net/qq_43040688/article/details/105415093MySQL索引https://blog.csdn.net/qq_43040688/article/details/105419053MySQL创建高性能的索引https://blog.csdn.net/qq_43040688/article/details/105454477MySQL查询性能优化https://blog.csdn.net/qq_43040688/article/details/105456790MySQL锁https://blog.csdn.net/qq_43040688/article/details/105440448MySQL事务https://blog.csdn.net/qq_43040688/article/details/105441274MySQL备份https://blog.csdn.net/qq_43040688/article/details/105441944MySQL架构https://blog.csdn.net/qq_43040688/article/details/105450005MySQL高级特性https://blog.csdn.net/qq_43040688/article/details/105465192分库分表的高频面试题https://blog.csdn.net/qq_43040688/article/details/1055946531.2非关系型数据库Redis二、Java基础2.1Java虚拟机（已更新）虛拟机推荐《深入理解Java虚拟机》这本书，重点学习一下内存、垃圾回收、类加载机制这几部分内容。JVM内存结构链接JVM简介https://blog.csdn.net/qq_43040688/article/details/104964070程序计数器和虚拟机栈https://blog.csdn.net/qq_43040688/article/details/104970081本地方法栈和堆https://blog.csdn.net/qq_43040688/article/details/104972811方法区https://blog.csdn.net/qq_43040688/article/details/104982648直接内存https://blog.csdn.net/qq_43040688/article/details/1049960322.2Java并发（已更新）Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久Java并发基础学习Java并发，需要先掌握线程的一些基础知识这些基础知识的组合构成了后面的设计模式首先应该了解如何启动一个多线程，即使用Runnable、Callable、Thread；还需要了解线程启动后的生命周期，了解了不用实现方式的差别，最重要的研读Thread的源码，详情参考：Java多线程起步，Thread构造函数源码分析需要学习Thread常用API以及三种关闭线程的方式，详情参考：Thread的API需要了解this锁和class锁，详情参考：Java多线程之认识“锁”需要了解线程间的通讯，最基本的就是消费者和生产者模型，需要深入了解了wait、sleep、notify、nitifyAll的机制和差异，对于waitset要有个清晰的认识，详情参考：Java多线程之线程间的通讯需要尝试自定义了一个Boolean锁，了解了加锁和释放锁的过程，实现了获取正在阻塞的线程；需要了解线程运行时出现异常的处理方式，详情参考：自定义Boolean锁&amp;捕获线程中的异常需要学习了线程组的概念以及常用API，如interrupt，setDaemon，activeCount，enumerate，详情参考：线程组需要自定义了一个线程池，对线程池的处理机制有了较深的理解，详情参考：自定义线程池Java并发基础链接Java多线程起步https://blog.csdn.net/qq_43040688/article/details/103979628Thread构造函数源码分析https://blog.csdn.net/qq_43040688/article/details/105543926Thread的APIhttps://blog.csdn.net/qq_43040688/article/details/105747547Java多线程之认识“锁”https://blog.csdn.net/qq_43040688/article/details/105752943Java多线程之线程间的通讯https://blog.csdn.net/qq_43040688/article/details/105754406自定义Boolean锁&amp;捕获线程中的异常https://blog.csdn.net/qq_43040688/article/details/105771445线程组https://blog.csdn.net/qq_43040688/article/details/105774614自定义线程池https://blog.csdn.net/qq_43040688/article/details/105786243多线程的设计模式Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合以满足应用需求下面有十四个多线程的设计模式，帮助理解后面的JUC包。第一个设计模式是：观察者模式。需要定义一个主题，一个观察者。主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。详情参考：观察者模式第二个设计模式是：单例模式。解决方式有三种：第一种是doublecheck方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static类实现；第三种是利用enum类实现。详情参考：单例模式第三个设计模式是单线程执行模式。就是在同一时刻只能有一个对共享资源进行操作。详情参考：单线程执行设计模式第四个设计模式不可变对象设计模式。是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。详情参考：不可变对象设计模式第五个设计模式确保挂起设计模式。当线程在工作时，如果来了其他任务，将任务放入到队列中等待。详情参考：确保挂起设计模式第六个设计模式Balking设计模式。当工作已经执行过了，就直接return，防止重复的工作，提高效率。详情参考：Balking设计模式第七个设计模式生产者-消费者设计模式。如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。详情参考：生产者-消费者设计模式第七个设计模式读写锁的设计模式。读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能。详情参考：读写锁的设计模式第八个设计模式Thread-Per-Message。每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。详情参考：Thread-Per-Message第九个设计模式Worker设计模式。需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。详情参考：Worker设计模式第十个设计模式Future设计模式。通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。详情参考：Future设计模式第十一个设计模式两阶段终止设计模式。当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。详情参考：两阶段终止设计模式第十二个设计模式线程保险箱设计模式。利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。详情参考：线程保险箱设计模式和上下文设计模式第十三个设计模式ActiveObjects设计模式。接受异步调用的主动方法。可以主动异步的执行一些任务。详情参考：ActiveObjects设计模式第十四个设计模式CountDown设计模式。多个子任务执行，主任务等待子任务全部执行完，再执行详情参考：CountDown设计模式多线程的设计模式链接观察者模式https://blog.csdn.net/qq_43040688/article/details/105835544单例模式https://blog.csdn.net/qq_43040688/article/details/105798423单线程执行设计模式https://blog.csdn.net/qq_43040688/article/details/105856901不可变对象设计模式https://blog.csdn.net/qq_43040688/article/details/105865371确保挂起设计模式https://blog.csdn.net/qq_43040688/article/details/105886681Balking设计模式https://blog.csdn.net/qq_43040688/article/details/105890674生产者-消费者设计模式https://blog.csdn.net/qq_43040688/article/details/105891561读写锁的设计模式https://blog.csdn.net/qq_43040688/article/details/105857920Thread-Per-Messagehttps://blog.csdn.net/qq_43040688/article/details/105892219Worker设计模式https://blog.csdn.net/qq_43040688/article/details/105894685Future设计模式https://blog.csdn.net/qq_43040688/article/details/105868293两阶段终止设计模式https://blog.csdn.net/qq_43040688/article/details/105892777线程保险箱设计模式https://blog.csdn.net/qq_43040688/article/details/105887378上下文设计模式https://blog.csdn.net/qq_43040688/article/details/105888242ActiveObjects设计模式https://blog.csdn.net/qq_43040688/article/details/105895280CountDown设计模式https://blog.csdn.net/qq_43040688/article/details/105892054Java高并发与JVM的关系主要是学习waitset、JMM模型JMM模型中有四个内容，主要参看博客：Java多线程之内存模型三大特性。如果想学习更多，请学习JVM的部分。解决高速缓存中数据不一致性的问题——总线锁（效率低）、高速缓存一致性协议，英特尔高并发的三个要求——原子性、可见性、有序性happens-before指令重排序Java多线程之内存模型三大特性：https://blog.csdn.net/qq_43040688/article/details/105823532原子包CAS：乐观锁，CompareAndSwap。优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。缺点：在竞争激烈的情况下，浪费CUP资源。还有一个问题是ABA问题，解决方法是：加一个版本号。详情参考：CASUnSafe类内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式获取Unsafe需要通过反射Unsafe类的属性常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现详情参考：UnSafe类AtomicInteger和AtomicBoolean：是保证原子性的对象。利用的CAS详情参考：AtomicInteger和AtomicBooleanAtomicReference是一个利用CAS帮助对象保证原子性的但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：CAS详情参考：AtomicReference文章名称链接CAShttps://blog.csdn.net/qq_43040688/article/details/105914717AtomicIntegerhttps://blog.csdn.net/qq_43040688/article/details/105908835AtomicBooleanhttps://blog.csdn.net/qq_43040688/article/details/105917939AtomicReferencehttps://blog.csdn.net/qq_43040688/article/details/105918329UnSafe类https://blog.csdn.net/qq_43040688/article/details/105923421JUC工具包CountDownLatch通过一个计数器实现，计数器初始值就是线程的数量每当一个线程完成任务，就会使计数减一可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成详情见：CountDownLatchCyclicBarrier跟CountDownLatch的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点详情见：CyclicBarrierPhaserJDK1.7之后引用的，具有CyclicBarrier和CountDownLatch同时它的注册数是支持动态增加或减少（可以用于线程出现异常）当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复详情见：PhaserExchanger用于线程间交换数据需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题详情见：ExchangerSemaphore是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问详情见：SemaphoreReentrantLock支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞需要手动的释放锁，try...finally...相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高是一个Java类，具有更多的功能，同时可以自由的扩展详情请见：ReentrantLock读写锁将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能是悲观锁，可能读的线程太多，写的线程迟迟难以执行详情请见：读写锁StampedLock解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据详情请见：StampedLock三种锁的比较synchronizedStampedLockLock是JVM的的内置锁，每个JDK版本都会优化是一个Java类，可以更好的扩展是一个Java类，可以更好的扩展都是悲观锁提供了写的乐观锁都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁性能一般，因为有一个从用户态到内核态的过程性能最好，可以代替读写锁性能十分不稳定，在复杂的读写环境下，性能十分差详情请见：三种锁的比较ForkJoin基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行分为Fork和Join两个阶段，充分利用CPU资源详情请见：ForkJoin文章名称链接CountDownLatchhttps://blog.csdn.net/qq_43040688/article/details/105935307CyclicBarrierhttps://blog.csdn.net/qq_43040688/article/details/105937169Phaserhttps://blog.csdn.net/qq_43040688/article/details/106033183Exchangerhttps://blog.csdn.net/qq_43040688/article/details/105955788Semaphorehttps://blog.csdn.net/qq_43040688/article/details/105956731ReentrantLockhttps://blog.csdn.net/qq_43040688/article/details/105958719读写锁https://blog.csdn.net/qq_43040688/article/details/105975257StampedLockhttps://blog.csdn.net/qq_43040688/article/details/106026847三种锁的比较https://blog.csdn.net/qq_43040688/article/details/106032189ForkJoinhttps://blog.csdn.net/qq_43040688/article/details/106032309Exectors框架首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。ThreadPoolExecutor创建线程池有七大参数，特别重要有四种拒绝策略四种阻塞队列一些调试的API关闭线程池的注意事项详情请见：ThreadPoolExecutorExecutors用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：newCachedThreadPoolnewFixedThreadPoolnewScheduledThreadPoolnewSingleThreadExecutornewWorkStealingPool详情请见：ExecutorsCompletionService用来增强线程池，主要思想是：执行一批任务，先执行的，先获取结果实现的子类是：ExecutorCompletionService详情请见：CompletionServiceCompleableFuture可以进行串联的操作，即利用上一个任务的结果，执行下一个任务进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果可以不需要调用者主动获取结果，而进行回调执行一批任务时，获取的Future是按照任务完成的顺序创建CompleableFuture有多种方式，最多的是runAsync和supplyAsyncAPI分为组合方法、中转方法和终结方法详情请见：CompleableFuture文章名称链接ThreadPoolExecutorhttps://blog.csdn.net/qq_43040688/article/details/106041236Executorshttps://blog.csdn.net/qq_43040688/article/details/106046629CompletionServicehttps://blog.csdn.net/qq_43040688/article/details/106058225CompleableFuturehttps://blog.csdn.net/qq_43040688/article/details/106061776","link":"https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/"},{"title":"RocketMQ监控平台（附网盘链接）","content":"RocketMQ有一个对其扩展的开源项目incubator-rocketmq-externals，这个项目中有一个子模块叫rocketmq-console，这个便是管理控制台项目了，先将incubator-rocketmq-externals拉到本地，因为我们需要自己对rocketmq-console进行编译打包运行。在linux环境下，使用nohubjava-jarxxxx&amp;启动，为了防止端口冲突，已经修改其端口为9999链接：https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA提取码：jpg03.5.2下载并编译打包gitclonehttps://github.com/apache/rocketmq-externalscdrocketmq-consolemvncleanpackage-Dmaven.test.skip=true注意：打包前在rocketmq-console中配置namesrv集群地址：rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876启动rocketmq-console：java-jarrocketmq-console-ng-1.0.0.jar启动成功后，我们就可以通过浏览器访问http://localhost:8080进入控制台界面了，如下图：","link":"https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/"}]}