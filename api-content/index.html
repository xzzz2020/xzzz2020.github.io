{"posts":[{"title":"第七章操作系统接口","content":"命令接口实现系统调用命令接口实现分为下图所示的两个模块实现：终端处理程序，接收键盘的输入，并将命令执行的结果回显在显示器上，功能包括：字符接收字符缓冲回送显示屏幕编辑特殊字符的处理命令解释程序，从.输入缓冲区中取出数据，然后识别命令、执行命令,最后把结果放到输出缓冲区中。系统调用什么是系统调用？系统调用是操作系统提供给应用程序的一-种过程调用，保护操作系统程序不被用户，程序破坏。系统调用是操作系统的程序接口。系统调用与一般的过程调用不同：系统调用处理程序运行在内核态，而一般的过程调用运行在用户态;系统调用需要借助软中断实现，而--般过程调用不需要;系统调用从内核返回时，要进行决策是否运行调度算法，而一般过程调用不需要;系统调用可以嵌套调用，但调用深度有一定的限制，而一般过程调用没有深度限制;","link":"https://xzzz2020.github.io/post/KpZgrFFRY/"},{"title":"第六章文件管理","content":"文件及其逻辑结构顺序文件索引文件索引顺序文件直接文件和哈希文件目录的要求文件的物理结构（***）连续分配链接分配索引分配空闲空间管理空闲表法空闲链表法位视图法（***）成组链表法文件系统软件模型对象及其属性对对象操纵和管理的软件集合文件系统接口文件共享课本习题题目练习文件及其逻辑结构文件概念：由创建者所定义、具有文件名的一组相关元素的集合，可分为结构文件和无结构文件两种。文件逻辑结构概念：文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性，又称为文件组织。顺序文件顺序文件由数据依次排列组成。顺序文件可分为串结构文件和有序结构文件。、串结构文件按记录存入文件的时间先后排列。有序结构按关键字值大小排列。顺序文件又分为定长记录文件和变长记录文件。索引文件若顺序文件是变长记录文件，可按记录号或关键字为每条记录建立一个索引文件，存储记录在顺序文件中的位置信息。索引文件是定长的文件。索引顺序文件索引文件太长会要求更多的I/O次数，直接影响了文件的读/写效率。索引顺序文件先对顺序文件按记录号或关键字排序分组，然后对组的第一个记录索引。直接文件和哈希文件直接文件是一种特殊的哈希文件,记录关键字值决定了记录在顺序文件中的位置。哈希文件则由关键字值通过哈希函数计算获得记录在顺序文件中的位置。目录的要求实现“按名存取”。提高对目录的检索速度。文件共享。允许文件重名。文件的物理结构（***）概念：文件的物理结构指文件的外存分配组织管理方式文件占用的外存空间以块或簇等逻辑单位计量连续分配文件数据连续存储可以提高存取速度，但限制了文件动态增长。链接分配隐式链接，链接指针包含在给文件分配的块中，目录中仅包含文件的起始块和结束块(或长度)。链接指针分散在多个块中，不利于安全措施的实现显示链接：将所有的链接信息提取放到文件分配表中索引分配在链接分配中，文件块链接指针离散存储,造成文件占用块号解析效率不高。索引分配方式就是将块号集中存放。单级索引（一级索引）用一个块来记录文件占用的所有块号,我们称之为索引块二级索引因为一个索引块的大小有限，但是多级索引需要检索多次，会影响性能混合索引(直接地址、-级索引、两级索引、三级索引方式)空闲空间管理空闲表法若干连续的空闲块组合成一个空闲区。空闲表法将所有的空闲区记录在一张表里，包括项号、起始空闲块号、空闲块数等。空闲链表法空闲链表法是以空闲块或空闲区为结点构成一个链表结构。位视图法（***）用一位二进制表示，1代表已分配，0代表空闲。块号从0开始，BitsOfLine是一行有多少位，如char类型为8位block=lineXBitsOfLine+columnline=block/BitsOfLinecolumn=block%BitsOfLine成组链表法用树的结构表示文件系统软件模型对象及其属性文件系统对象超级块对象文件目录索引结点数据块对对象操纵和管理的软件集合对文件的读/写对目录文件的读/写对磁盘空闲空间的管理将文件的逻辑地址转换为物理地址对文件的保护与共享;文件系统接口基于文件名(路径)、文件逻辑地址(相对于文件起始地址的偏移)给用户提供各种操作。常用的文件操作有，创建文件、删除文件、读文件、写文件、设置文件读1写位置、打开文件、关闭文件等。文件共享基于索引结点的共享方式基于符号链的共享方式课本习题11在UNIX中，如果一个盘块的大小为1KB，每个盘块号占4个字节，即每块可放256个地址。请转换下列文件的字节偏移量为物理地址。⑴9999；⑵18000；⑶420000答：首先将逻辑文件的字节偏移量转换为逻辑块号和块内偏移量,就是将[字节偏移量]/[盘块大小]，商为逻辑块号，余数是块内偏移量。在FCB中，第0-9个地址为直接地址，第10个为一次间接地址，第11个地址为二次间接地址，第12个地址为三次间接地址。再将文件的逻辑块号转换为物理块号。使用多重索引结构，在索引节点中根据逻辑块号通过直接索引或间接索引找到对应的物理块号。9999/1024=9余783，则逻辑块号为9，直接索引第9个地址得到物理块号，块内偏移地址为783。18000/1024=17余592，则逻辑块号为10&lt;17&lt;10+256，通过一次间接索引在第10个地址可得到物理块号，块内偏移地址为592。420000/1024=410余160，则逻辑块号为10+256&lt;410，通过二次间接索引在第11个地址可得到一次间址，再由此得到二次间址，再找到物理块号，其块内偏移地址160。某操作系统磁盘文件空间共500块，若用字长为32位的位示图管理磁盘空间，试问：（1）位示图需要多少字？（2）第i字第j位对应的块号是多少？（3）给出申请/归还一块的工作流程。答：（1）位示图需要的字数计算：INT（500/32）=16个字。（2）块号b=(i-1)*32+j（3）申请的过程：顺序扫描位示图、找到空闲块并分配、修改位示图map[i,j]=1。归还的过程：找到回收盘块在位示图中的行和列，修改位示图map[i,j]=0。题目练习","link":"https://xzzz2020.github.io/post/7ZUXXwU1m/"},{"title":"第五章设备管理","content":"设备分类I/O设备控制方式程序查询方式通道控制方式DMA方式（直接存储器访问方式）中断方式I/O系统的软件模型及功能设备独立性软件Spooling缓冲管理四种缓冲策略设备分配磁盘调度算法（会计算***）先来先服务最短寻道时间扫描算法（电梯调度算法）循环扫描算法题目练习设备分类按信息交换单位分类：块设备：数据传送以块为单位，传输速率较高，可寻址;I/O访问常采用DMA方式。字符设备：数据传送以字符为单位，传输速率较低，不可寻址;I/0访问常采用中断方式。按设备的的共享属性分类：独占设备：一段时间内只允许一个进程使用，属于临界资源。共享设备：在一-段时间，允许多个进程同时访问，共享设备必须是可寻址和可随机访问的设备。虚拟设备：将一台独占设备变换为若干个逻辑设备,如虚拟存储器、虚拟终端。I/O设备控制方式程序查询方式不停的检查设备的状态，造成CPU资源的浪费，优点是比较简单通道控制方式通道程序由一系列通道指令构成，包含以下信息：操作码：读、写、控制等;内存地址：读写内存的始址;计数：指令的读写字节数;通道程序示例：通道程序结束位P，1表示通道指令是通道程序的最后一条指令。记录结束位Record,0表示通道指令与下一条通道指令所处理的数据块属于同--个记录，1表示通道指令所处理的数据块是记录的最后一块数据。DMA方式（直接存储器访问方式）DMA方式以块为单位传送数据，仅在数据块传送前和传送结束时,才需要处理机干预。包含四类寄存器：数据寄存器：缓存从设备到内存，或从内存到设备的数据;数据计数寄存器：存储要读/写的字节数;内存地址寄存器：存放内存起始地址;.控制/状态寄存器：接收处理机发来的1/O命令或有关控制信息，以及设备发送的状态信息;中断方式驱动程序向处理机发出启动I/O设备指令后阻塞，处理机转向处理其它工作。设备完成数据传送后，I/O控制器向处理机发送中断请求。处理机收到中断请求信号转向中断处理程序，中断处理程序将数据寄存器中的数据送到指定内存单元，并唤醒阻塞进程。I/O系统的软件模型及功能设备独立性软件设备独立性指应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备概念，在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。设备独立性软件的功能：向用户层(或文件层)软件提供统一接口。执行设备的公有操作，如逻辑设备名映射为物理设备名、独立设备的分配与回收、对设备进行保护、缓冲管理、差错控制、提供独立于物理设备的逻辑块。设备独立性实现：构建一个逻辑设备表，实现逻辑设备名到物理设备名的映射Spooling在联机情况下实现的同时输入/输出操作称为Spooling，或称为假脱机操作,即数据的输入、输出不再由外围控制机管理,而改为进程执行。Spooling系统的组成：输入进程SPi和输出进程SPo输入和输出缓冲区输入和输出井Spooling系统应用--共享打印机：将所有打印请求挂在打印机请求队列上。把打印数据放入到输出井上。打印机驱动进程依次完成打印机请求队列上的任务。Spooling系统的特点：提高了I/O速度。将独占设备改造成共享设备。实现了设备的虚拟化。缓冲管理目的：减少低速设备对高速的干扰。四种缓冲策略1.单缓冲由于处理机与I/O设备的并行性，用户进程对一块缓冲区数据的处理时间等价于Max(C，T)+M。需要注意的是传送和计算或输入无法同时计算此时生产者是设备，消费者是用户进程，生产者和消费者都只有一个，不存在互斥2.双缓冲数据被采集到缓冲区和数据从缓冲区传送到用户进程空间再被计算可以并行执行;用户进程对一块缓冲区数据的处理时间等价于Max(C、T);如果C&gt;T,则CPU可以连续地工作;如果C&lt;T,则I/0设备可以连续地工作;双缓冲适用于I/O设备与用户进程速度基本匹配的场合;此时设备输入数据和用户进程取数据可以同时进行3.循环缓冲适用于I/O设备与用户进程速度差异较大的场合循环缓冲的使用：GetBuf过程，从循环缓冲中获取一个满缓冲区或一个空缓冲区;ReleaseBuf过程，向循环缓冲中释放一个空缓冲区或一个满缓冲区;4.缓冲池（***）三种缓冲队列空缓冲队列emq输入缓冲队列inq,装满输入数据输出缓冲队列outq,装满输出数据四种缓冲区收容输入数据缓冲区hin提取输入数据缓冲区sin收容输出数据缓冲区hout提取输出数据缓冲区sout设备分配安全分配：进程发出I/0请求后，便进入阻塞状态,直到I/O操作完成时才被唤醒。摒弃&quot;请求和保持”死锁必要条件之一，缺点是进程进展缓慢。不安全分配：进程发出I/O请求后仍继续运行，需要时又发出第二C个、第三个I/O请求等，效率高，缺点是可能造成死锁。磁盘调度算法（会计算***）注意：每次寻道都会改变当前所在磁道先来先服务按照请求顺序进行寻道最短寻道时间每次寻找离当前磁道最近的请求，会导致饥饿现象，默写请求可能很久都难以调度扫描算法（电梯调度算法）磁头可以朝着增加的方向移动也会朝着减少的方向移动，可以避免饥饿现象的发生先寻找离当前磁头最近的磁道且需要比当前磁道大当不存在比当前磁道更大的时候，磁头需要调转方向，朝着减少的方向移动.循环扫描算法改进：当移动到不存在比当前磁道更大的时候，不再调转方向，从0开始继续寻找题目练习","link":"https://xzzz2020.github.io/post/mxhiqNcFj/"},{"title":"第四章存储器管理","content":"程序的链接与装入程序的装入程序的链接连续存储分配方式单一连续分配固定分区分配方式动态分区分配（***）基本分页存储管理方式页表地址变换机构（***）基本分段存储管理方式段表地址变换机构（***）分页和分段的主要区别虚拟存储器（***）虚拟存储器实现方法的硬件支持分页请求系统分段请求系统页面置换算法（***）最佳置换算法（理想化）先进先出页面置换算法最近最久未使用置换算法（LRU）clock置换算法简单clock置换算法（最近未访问页面置换算法）改进型clock置换算法最近最少未使用（LFU）练习题目程序的链接与装入程序的装入目的：是将代码装入内存准备执行绝对装入方式可重定位装入方式：动态运行时的装入方式：增加一个重定位寄存器，通过硬件完成地址的修正。真实地址等于逻辑地址+重定位寄存器上的地址程序的链接目的：将目标模块相对独立的地址空间合并成一个地址空间。​静态链接方式对相对地址进行修改变换外部调用符号装入时动态链接运行时动态链接连续存储分配方式目的：给每一个程序分配一片连续的存储空间，容量为程序运行时所需的最大空间。指标：碎片率，越小越好。单一连续分配内存分为系统区和用户区用户区一次只能装入一个程序运行系统区装入操作系统固定分区分配方式将内存划分成固定数目的区域，如图所示：为了实现内存的管理，需要建立固定分区表（数组实现）：程序的大小和分区大小不能完全匹配，所以需要分配大于等于程序大小的内存，分区中浪费的空间称为内碎片动态分区分配（***）操作系统不预设固定数目分区，按照程序内存需求为其划分，内存中分区数目动态变化。数据结构：分配算法：首次适应算法：空闲分区以地址递增的顺序排列，每次从链首开始顺序查找，直到找到一个大小能满足要求的空闲分区为止。然后再按照程序的要求大小，从该空闲分区中划分出一块内存空间给请求者，余下的空闲部分仍留在空闲链表中。特点是低端或高端地址空间被频繁使用。循环首次适应算法：在首次适应算法的基础上，每次查找时从上次找到空闲分区的下一个空闲分区开始查找。特点是空闲分区使用均匀，但是会缺乏大的空闲分区。最佳适应算法：能满足要求、又是最小的空闲分区分配给作业，避免&quot;大材小用”。特点:分区按照大小顺序排列。最差适应算法：每次从空闲分区中选择最大的空闲分区分配给程序，以便切割剩余的空闲分区空间更大。切割操作会产生一些空间过小，总是不会分配给程序，这些空间被称作外碎片。###可重定位分区分配紧凑：通过移动程序，将外碎片合并一个大的空闲分区基本分页存储管理方式离散分配的基本单位是页页表解决了逻辑地址到物理地址的转换的问题：将程序逻辑地址空间划分成固定大小的页面;内存划分成等大小的页框;页表实现页面到页框的索引;页表项个数由程序的逻辑地址空间决定，页表项位数由页框起始物理地址位数决定。记录了页面和页框号（每个页框的起始地址）的对应关系，如下图所示：页表存储了页框的起始物理地址，需要一个连续的存储空间实现随机访问，对于逻辑地址相当于页号+页内偏移。地址变换机构（***）先让页号与页表基址相加得到页框号再让页框号与页内偏移相加得到物理地址基本分段存储管理方式离散分配的基本单位是端采用二维逻辑地址结构，由段号加段内偏移构成段表地址变换机构（***）分页和分段的主要区别页是信息的物理单位；段是信息的逻辑单位。页大小固定；段大小不固定。分页采用一维线性逻辑地址，分段采用二维逻辑地址。虚拟存储器（***）概念：虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器，其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度,每位成本接近外存。虚拟存储器实现方法的硬件支持分页请求系统请求分页的页表机制缺页中断机构地址变换机构分段请求系统请求分段的端表机制缺段中断机构地址变换机构页面置换算法（***）页面中断：发生页面的置换最佳置换算法（理想化）置换以后永不使用或者最长时间不使用的页面发生3次缺页中断和页面中断先进先出页面置换算法淘汰最先进入的页面，即选择在内存中驻留时间最久的页面予以淘汰。最近最久未使用置换算法（LRU）选择最近最久未使用的页面予以淘汰，即当前使用次数最少的页面。实现方式：利用栈保存当前使用的各个页面的页面号,每当进程访问某页面时，便将该页面的页面号从栈中弹出，并将它压入栈顶。因此，栈底是最近最久未使用的页面。使用寄存器，每一次访问都会在寄存器加一，每次置换选择寄存器中次数最少的页面clock置换算法简单clock置换算法（最近未访问页面置换算法）将所有的页面组成一个循环链表,并为每个页面添加一个访问位A。当一个页面被访问时，将其A位设置为1。置换过程是从pointer开始，若该页面的A位为1,将其设置为0,并使pointer指向下一个页面，直到找到A位为0的页面;若该页面的A位为0，则将其置换出内存，并用换入的页面占用换出页面的页框，使pointer指向下一个页面。如果第一轮没有找到，则执行第二轮，由于第一轮将所有页面的A都设置为0，则一定能在第二轮找到改进型clock置换算法增加一个修改为M，页面状态可以分为四类：1类(A=0，M=0)，未访问未修改;2类(A=0，M=1)，未访问.已修改;3类(A=1，M=0)，已访问未修改;4类(A=1,M=1)，已访问已修改;置换过程：从pointer开始寻找1类页面，直到找到1类页面结束，或者扫描完一遍进入第II步。从pointer开始寻找2类页面，直到找到2类页面结束，或者扫描完一遍进入第I步。在本步每扫描完一个页面，须将页面的访问位修改为0。重复l和II。(一定可以找到置换的页。)最近最少未使用（LFU）在最近时期内选择使用次数最少的页面作为淘汰页练习题目","link":"https://xzzz2020.github.io/post/HB2L7VswF/"},{"title":"第三章进程同步与死锁","content":"进程同步信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥利用信号量实现前驱关系资源的分配同步的问题进程间通信死锁的相关概念处理死锁的基本方法预防死锁避免死锁（***）银行家算法（***）检测死锁解除死锁练习题目进程同步临界资源：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源临界区：每个进程中访问临界资源的代码实现互斥的结构：硬件实现：关中断：让处理机始终执行一个程序，不进行程序的切换指令同步应该遵循的规则：空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。忙则等待：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;前驱图：若想执行S2，则需要先执行S1。信号量整型信号量记录性信号量（***）AND型信号量信号量的应用（***）利用信号量实现互斥实现算法：符合：空闲让进，忙则等待和有限等待利用信号量实现前驱关系资源的分配申请资源时需要执行P操作，释放资源时执行V操作同步的问题生产者-消费者问题哲学家进餐问题读者-写者问题进程间通信低级通信：信号量机制高级通讯：共享存储器系统、消息传递系统、管道通信。死锁的相关概念可抢占资源：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。不可抢占的资源：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。死锁的定义：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。产生死锁的原因：竞争不可抢占资源引发死锁。竞争可消耗资源引发死锁。进程推进顺序不当引发死锁。处理死锁的基本方法预防死锁破坏“请求和保持条件”破坏“不可抢占条件”破坏“循环等待条件”：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，必须按照从1到4或者从4到1的顺序申请。避免死锁（***）安全状态：安全状态，是指系统能按某种顺序(P1,P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,直到满足每个进程对资源的最大需求，使每个进程都可以顺利地完成。不安全状态：如果系统无法找到这样一个安全序列，称系统处于不安全状态。要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态银行家算法（***）先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。寻找安全序列的方式只有两种：每次都从最上面开始；按照从上到下顺序循环应用：如果单向顺序，查找安全序列的流程为：判断P0，返现剩余资源不能满足。判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。P0、P1结束，直接跳过。判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。P0、P1、P2、P3结束，直接跳过。判断P4，发现满足，则释放P4分配的资源。最终的安全序列为：P1、P3、P0、P2、P4。确认分配。此时找不到安全序列，拒绝分配。检测死锁解除死锁练习题目","link":"https://xzzz2020.github.io/post/vUwZiOAP9/"},{"title":"第二章处理机管理","content":"程序的执行方式顺序方式（*）并发执行（***）并行执行进程进程的特征进程的状态进程控制块（PCB）进程控制进程的四个操作进程的创建进程的终止进程的阻塞和进程的唤醒进程调度概念进程调度的方式衡量调度算法指标进程调度算法（计算***）先来先服务调度算法（***）短作业优先调度算法（***）高优先权调度算法（***）高响应比优先调度算法时间片轮转调度算法（***）多级队列调度算法多级反馈队列调度算法线程题目练习程序的执行方式顺序方式（*）内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着严格的先后次序顺序执行的特点：顺序性：程序执行有着明确的先后顺序封闭性：程序运行时独占所有资源可再现性：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同问题：无法满足高性能并发执行（***）并发指一段时间内执行多个程序。多个程序同时进入内存，轮流交替执行。并发执行的特点：间断性：交替执行就是走走停停失去了封闭性：程序不再独占系统资源不可再现性：程序执行有多种结果。并行执行同一时刻有多个程序执行，只能在多处理机上实现进程进程是研究并发方式下，程序的执行。进程的概念：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。进程实体：由程序段、相关数据段和PCB组成进程的特征并发性，多个进程在一段时间内同存于内存中同时运行动态性，进程由创建而产生，由调度而执行，由撤消而消亡。独立性，进程是能独立运行、资源分配、调度的基本单位。结构性，进程映像由程序、数据、栈和进程控制块(PCB)构成。异步性，进程按各自独立、不可预知的速度向前推进。进程的状态有三个状态：就绪状态：指程序已经处于准备好运行的状态。执行状态：指程序已经获得CPU，正在执行。阻塞状态：指程序的执行因为某些原因无法继续执行。进程控制块（PCB）用来描述进程的基本情况和活动过程，进而控制和管理进程。（类似于学籍、户口等）进程创建时会建立一个PCB，结束时会收回PCB进程控制块中的信息：进程标识符：包括内部标识符和外部标识符。处理机状态：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。进程控制信息：程序栈和数据地址，同步和通信机制，资源清单,链接指针。进程调度信息进程控制块中的组织方式线性方式链接方式索引方式进程控制进程控制用于创建、终止、阻塞和唤醒进程。进程控制由操作系统内核原语来实现。原语是由若干条指令组成，用于完成一定功能的一个过程，所有的指令要么全做，要么全不做。（一个函数）用户态：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。系统态（内核态）：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。进程的四个操作进程的创建引起进程创建的事件：用户执行应用程序。用户登录。启动服务。程序创建进程。进程创建的过程（必须要求是原语）：申请空白PCB为新进程分配资源，如内存空间等初始化PCB将进程插入就绪队列进程的终止引起进程终止的事件：正常结束。异常结束。外界干预。进程的终止过程：检查进程状态。有无子孙需要终止。归还进程全部资源。将PCB从进程中移除。进程的阻塞和进程的唤醒进程调度概念处理机调度的层次：高级调度低级调度中级调度引起进程调度的事件：进程终止。进程创建。进程阻塞。进程唤醒。外部设备中断。进程切换时需要保存和恢复现场。进程调度的方式抢占式调度：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。非抢占式调度：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（只有时间片用完才能调度）衡量调度算法指标面向用户（***）：平均周转时间：所有周转时间求平均。带权周转时间：一个程序的周转时间除以服务的时间。（&gt;=1）平均带权周转时间：对带权周转时间求平均。周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。面向系统：吞吐量：在单位时间内系统所完成的作业数。处理机利用率：在过去一段时间内CPU被占用的时间总和。各类资源的平衡利用率：保证系统所有的资源被合理利用。进程调度算法（计算***）先来先服务调度算法（***）先来的进程先抢到CPU，有利于长作业，不利于短作业短作业优先调度算法（***）在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。非抢占方式：抢占式：高优先权调度算法（***）按照优先权重分配CPU，优先数越小，优先权越大高响应比优先调度算法按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久响应比=等待时间/服务时间时间片轮转调度算法（***）按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。假设时间片为2。多级队列调度算法优先调度优先级高的多级反馈队列调度算法解决了低优先级队列长时间无法调度的问题线程为什么提出线程？进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。线程概念：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。如下图所示，每个线程都会有个栈，一共有三个线程：线程的特点：一个线程拥有少量的资源，记录在线程控制块中。轻型实体，线程基本上不拥有资源，或者是有较少的资源;一个进程的所有线程共享进程所拥有的全部资源。线程是处理机调度的基本单位，多个线程可以并发执行。线程与进程的比较：线程的实现方式：内核级线程：所有创建、切换等都需要内核的支持，开销较大（适合多处理器系统）用户级线程：可以不需要进入内核态创建，但是切换进程需要进入内核（开销小）组合方式：建立内核级线程与用户级线程的关系。题目练习","link":"https://xzzz2020.github.io/post/IyZhCzd1C/"},{"title":"第一章操作系统引论","content":"操作系统发展操作系统的功能处理机管理存储器管理（内存）设备管理（高效使用IO设备）文件管理操作系统接口操作系统的基本特征操作系统的作用设计目标操作系统结构练习题目操作系统发展无操作系统单道批处理系统多道批处理系统：多个程序交替使用CPU，目的是提高CPU的利用率**分时系统：**使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了时分复用技术实时系统：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对时间要求苛刻操作系统的功能处理机管理进程控制进程调度进程同步进程通信死锁存储器管理（内存）内存分配内存共享内存扩充内存保护设备管理（高效使用IO设备）设备处理缓冲管理设备分配设备的独立性设备的虚拟性文件管理文件读/写目录管理存储空间管理文件共享、存储性能优化、存储可靠性和数据一致性操作系统接口图形接口系统调用命令调用​操作系统的基本特征并发性：多个程序在同一时间间隔执行共享性：多个并发的程序共同使用计算机资源，提高计算机资源的利用率虚拟性：有时分复用和空分复用两种技术异步性：表现为多任务执行的无序性，主要应对阻塞操作系统的作用操作系统(OperatingSystem,OS)是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。是用户和计算机系统之间的接口是系统资源的管理者扩充计算机的功能，实现对计算机的抽象设计目标方便性有效性扩充性开放性操作系统结构无操作系统结构模块化结构层次结构微内核结构练习题目","link":"https://xzzz2020.github.io/post/ZBrN48x_g/"},{"title":"2020最新-Java面试","content":"学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：https://blog.csdn.net/qq_43040688/article/details/105819866这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。一.数据库1.1关系型数据库MySQL(已更新)推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句SQL语句学习链接基础部分https://blog.csdn.net/qq_43040688/article/details/105346357重点部分https://blog.csdn.net/qq_43040688/article/details/105348610扩展部分https://blog.csdn.net/qq_43040688/article/details/105381801接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构SQL高级部分链接MySQL体系结构和存储引擎介绍https://blog.csdn.net/qq_43040688/article/details/105393816InnoDB存储引擎https://blog.csdn.net/qq_43040688/article/details/105415093MySQL索引https://blog.csdn.net/qq_43040688/article/details/105419053MySQL创建高性能的索引https://blog.csdn.net/qq_43040688/article/details/105454477MySQL查询性能优化https://blog.csdn.net/qq_43040688/article/details/105456790MySQL锁https://blog.csdn.net/qq_43040688/article/details/105440448MySQL事务https://blog.csdn.net/qq_43040688/article/details/105441274MySQL备份https://blog.csdn.net/qq_43040688/article/details/105441944MySQL架构https://blog.csdn.net/qq_43040688/article/details/105450005MySQL高级特性https://blog.csdn.net/qq_43040688/article/details/105465192分库分表的高频面试题https://blog.csdn.net/qq_43040688/article/details/1055946531.2非关系型数据库Redis二、Java基础2.1Java虚拟机（已更新）虛拟机推荐《深入理解Java虚拟机》这本书，重点学习一下内存、垃圾回收、类加载机制这几部分内容。JVM内存结构链接JVM简介https://blog.csdn.net/qq_43040688/article/details/104964070程序计数器和虚拟机栈https://blog.csdn.net/qq_43040688/article/details/104970081本地方法栈和堆https://blog.csdn.net/qq_43040688/article/details/104972811方法区https://blog.csdn.net/qq_43040688/article/details/104982648直接内存https://blog.csdn.net/qq_43040688/article/details/1049960322.2Java并发（已更新）Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久Java并发基础学习Java并发，需要先掌握线程的一些基础知识这些基础知识的组合构成了后面的设计模式首先应该了解如何启动一个多线程，即使用Runnable、Callable、Thread；还需要了解线程启动后的生命周期，了解了不用实现方式的差别，最重要的研读Thread的源码，详情参考：Java多线程起步，Thread构造函数源码分析需要学习Thread常用API以及三种关闭线程的方式，详情参考：Thread的API需要了解this锁和class锁，详情参考：Java多线程之认识“锁”需要了解线程间的通讯，最基本的就是消费者和生产者模型，需要深入了解了wait、sleep、notify、nitifyAll的机制和差异，对于waitset要有个清晰的认识，详情参考：Java多线程之线程间的通讯需要尝试自定义了一个Boolean锁，了解了加锁和释放锁的过程，实现了获取正在阻塞的线程；需要了解线程运行时出现异常的处理方式，详情参考：自定义Boolean锁&amp;捕获线程中的异常需要学习了线程组的概念以及常用API，如interrupt，setDaemon，activeCount，enumerate，详情参考：线程组需要自定义了一个线程池，对线程池的处理机制有了较深的理解，详情参考：自定义线程池Java并发基础链接Java多线程起步https://blog.csdn.net/qq_43040688/article/details/103979628Thread构造函数源码分析https://blog.csdn.net/qq_43040688/article/details/105543926Thread的APIhttps://blog.csdn.net/qq_43040688/article/details/105747547Java多线程之认识“锁”https://blog.csdn.net/qq_43040688/article/details/105752943Java多线程之线程间的通讯https://blog.csdn.net/qq_43040688/article/details/105754406自定义Boolean锁&amp;捕获线程中的异常https://blog.csdn.net/qq_43040688/article/details/105771445线程组https://blog.csdn.net/qq_43040688/article/details/105774614自定义线程池https://blog.csdn.net/qq_43040688/article/details/105786243多线程的设计模式Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合以满足应用需求下面有十四个多线程的设计模式，帮助理解后面的JUC包。第一个设计模式是：观察者模式。需要定义一个主题，一个观察者。主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。详情参考：观察者模式第二个设计模式是：单例模式。解决方式有三种：第一种是doublecheck方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static类实现；第三种是利用enum类实现。详情参考：单例模式第三个设计模式是单线程执行模式。就是在同一时刻只能有一个对共享资源进行操作。详情参考：单线程执行设计模式第四个设计模式不可变对象设计模式。是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。详情参考：不可变对象设计模式第五个设计模式确保挂起设计模式。当线程在工作时，如果来了其他任务，将任务放入到队列中等待。详情参考：确保挂起设计模式第六个设计模式Balking设计模式。当工作已经执行过了，就直接return，防止重复的工作，提高效率。详情参考：Balking设计模式第七个设计模式生产者-消费者设计模式。如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。详情参考：生产者-消费者设计模式第七个设计模式读写锁的设计模式。读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能。详情参考：读写锁的设计模式第八个设计模式Thread-Per-Message。每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。详情参考：Thread-Per-Message第九个设计模式Worker设计模式。需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。详情参考：Worker设计模式第十个设计模式Future设计模式。通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。详情参考：Future设计模式第十一个设计模式两阶段终止设计模式。当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。详情参考：两阶段终止设计模式第十二个设计模式线程保险箱设计模式。利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。详情参考：线程保险箱设计模式和上下文设计模式第十三个设计模式ActiveObjects设计模式。接受异步调用的主动方法。可以主动异步的执行一些任务。详情参考：ActiveObjects设计模式第十四个设计模式CountDown设计模式。多个子任务执行，主任务等待子任务全部执行完，再执行详情参考：CountDown设计模式多线程的设计模式链接观察者模式https://blog.csdn.net/qq_43040688/article/details/105835544单例模式https://blog.csdn.net/qq_43040688/article/details/105798423单线程执行设计模式https://blog.csdn.net/qq_43040688/article/details/105856901不可变对象设计模式https://blog.csdn.net/qq_43040688/article/details/105865371确保挂起设计模式https://blog.csdn.net/qq_43040688/article/details/105886681Balking设计模式https://blog.csdn.net/qq_43040688/article/details/105890674生产者-消费者设计模式https://blog.csdn.net/qq_43040688/article/details/105891561读写锁的设计模式https://blog.csdn.net/qq_43040688/article/details/105857920Thread-Per-Messagehttps://blog.csdn.net/qq_43040688/article/details/105892219Worker设计模式https://blog.csdn.net/qq_43040688/article/details/105894685Future设计模式https://blog.csdn.net/qq_43040688/article/details/105868293两阶段终止设计模式https://blog.csdn.net/qq_43040688/article/details/105892777线程保险箱设计模式https://blog.csdn.net/qq_43040688/article/details/105887378上下文设计模式https://blog.csdn.net/qq_43040688/article/details/105888242ActiveObjects设计模式https://blog.csdn.net/qq_43040688/article/details/105895280CountDown设计模式https://blog.csdn.net/qq_43040688/article/details/105892054Java高并发与JVM的关系主要是学习waitset、JMM模型JMM模型中有四个内容，主要参看博客：Java多线程之内存模型三大特性。如果想学习更多，请学习JVM的部分。解决高速缓存中数据不一致性的问题——总线锁（效率低）、高速缓存一致性协议，英特尔高并发的三个要求——原子性、可见性、有序性happens-before指令重排序Java多线程之内存模型三大特性：https://blog.csdn.net/qq_43040688/article/details/105823532原子包CAS：乐观锁，CompareAndSwap。优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。缺点：在竞争激烈的情况下，浪费CUP资源。还有一个问题是ABA问题，解决方法是：加一个版本号。详情参考：CASUnSafe类内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式获取Unsafe需要通过反射Unsafe类的属性常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现详情参考：UnSafe类AtomicInteger和AtomicBoolean：是保证原子性的对象。利用的CAS详情参考：AtomicInteger和AtomicBooleanAtomicReference是一个利用CAS帮助对象保证原子性的但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：CAS详情参考：AtomicReference文章名称链接CAShttps://blog.csdn.net/qq_43040688/article/details/105914717AtomicIntegerhttps://blog.csdn.net/qq_43040688/article/details/105908835AtomicBooleanhttps://blog.csdn.net/qq_43040688/article/details/105917939AtomicReferencehttps://blog.csdn.net/qq_43040688/article/details/105918329UnSafe类https://blog.csdn.net/qq_43040688/article/details/105923421JUC工具包CountDownLatch通过一个计数器实现，计数器初始值就是线程的数量每当一个线程完成任务，就会使计数减一可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成详情见：CountDownLatchCyclicBarrier跟CountDownLatch的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点详情见：CyclicBarrierPhaserJDK1.7之后引用的，具有CyclicBarrier和CountDownLatch同时它的注册数是支持动态增加或减少（可以用于线程出现异常）当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复详情见：PhaserExchanger用于线程间交换数据需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题详情见：ExchangerSemaphore是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问详情见：SemaphoreReentrantLock支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞需要手动的释放锁，try...finally...相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高是一个Java类，具有更多的功能，同时可以自由的扩展详情请见：ReentrantLock读写锁将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能是悲观锁，可能读的线程太多，写的线程迟迟难以执行详情请见：读写锁StampedLock解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据详情请见：StampedLock三种锁的比较synchronizedStampedLockLock是JVM的的内置锁，每个JDK版本都会优化是一个Java类，可以更好的扩展是一个Java类，可以更好的扩展都是悲观锁提供了写的乐观锁都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁性能一般，因为有一个从用户态到内核态的过程性能最好，可以代替读写锁性能十分不稳定，在复杂的读写环境下，性能十分差详情请见：三种锁的比较ForkJoin基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行分为Fork和Join两个阶段，充分利用CPU资源详情请见：ForkJoin文章名称链接CountDownLatchhttps://blog.csdn.net/qq_43040688/article/details/105935307CyclicBarrierhttps://blog.csdn.net/qq_43040688/article/details/105937169Phaserhttps://blog.csdn.net/qq_43040688/article/details/106033183Exchangerhttps://blog.csdn.net/qq_43040688/article/details/105955788Semaphorehttps://blog.csdn.net/qq_43040688/article/details/105956731ReentrantLockhttps://blog.csdn.net/qq_43040688/article/details/105958719读写锁https://blog.csdn.net/qq_43040688/article/details/105975257StampedLockhttps://blog.csdn.net/qq_43040688/article/details/106026847三种锁的比较https://blog.csdn.net/qq_43040688/article/details/106032189ForkJoinhttps://blog.csdn.net/qq_43040688/article/details/106032309Exectors框架首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。ThreadPoolExecutor创建线程池有七大参数，特别重要有四种拒绝策略四种阻塞队列一些调试的API关闭线程池的注意事项详情请见：ThreadPoolExecutorExecutors用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：newCachedThreadPoolnewFixedThreadPoolnewScheduledThreadPoolnewSingleThreadExecutornewWorkStealingPool详情请见：ExecutorsCompletionService用来增强线程池，主要思想是：执行一批任务，先执行的，先获取结果实现的子类是：ExecutorCompletionService详情请见：CompletionServiceCompleableFuture可以进行串联的操作，即利用上一个任务的结果，执行下一个任务进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果可以不需要调用者主动获取结果，而进行回调执行一批任务时，获取的Future是按照任务完成的顺序创建CompleableFuture有多种方式，最多的是runAsync和supplyAsyncAPI分为组合方法、中转方法和终结方法详情请见：CompleableFuture文章名称链接ThreadPoolExecutorhttps://blog.csdn.net/qq_43040688/article/details/106041236Executorshttps://blog.csdn.net/qq_43040688/article/details/106046629CompletionServicehttps://blog.csdn.net/qq_43040688/article/details/106058225CompleableFuturehttps://blog.csdn.net/qq_43040688/article/details/106061776","link":"https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/"},{"title":"RocketMQ监控平台（附网盘链接）","content":"RocketMQ有一个对其扩展的开源项目incubator-rocketmq-externals，这个项目中有一个子模块叫rocketmq-console，这个便是管理控制台项目了，先将incubator-rocketmq-externals拉到本地，因为我们需要自己对rocketmq-console进行编译打包运行。在linux环境下，使用nohubjava-jarxxxx&amp;启动，为了防止端口冲突，已经修改其端口为9999链接：https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA提取码：jpg03.5.2下载并编译打包gitclonehttps://github.com/apache/rocketmq-externalscdrocketmq-consolemvncleanpackage-Dmaven.test.skip=true注意：打包前在rocketmq-console中配置namesrv集群地址：rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876启动rocketmq-console：java-jarrocketmq-console-ng-1.0.0.jar启动成功后，我们就可以通过浏览器访问http://localhost:8080进入控制台界面了，如下图：","link":"https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/"}]}