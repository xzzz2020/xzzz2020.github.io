<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-06-21T03:38:14.551Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[2020最新-Java面试]]></title>
        <id>https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/</id>
        <link href="https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/">
        </link>
        <updated>2020-06-18T12:29:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：<a href="https://blog.csdn.net/qq_43040688/article/details/105819866">https://blog.csdn.net/qq_43040688/article/details/105819866</a></p>
</blockquote>
<p>这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。</p>
<br>
<br>
<br>
<br>
<br>
<h2 id="一-数据库">一. 数据库</h2>
<h3 id="11-关系型数据库">1.1 关系型数据库</h3>
<h4 id="mysql已更新">MySQL(已更新)</h4>
<p>推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》<br>
<code>对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句</code></p>
<table>
<thead>
<tr>
<th>SQL语句学习</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105346357">https://blog.csdn.net/qq_43040688/article/details/105346357</a></td>
</tr>
<tr>
<td>重点部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105348610">https://blog.csdn.net/qq_43040688/article/details/105348610</a></td>
</tr>
<tr>
<td>扩展部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105381801">https://blog.csdn.net/qq_43040688/article/details/105381801</a></td>
</tr>
</tbody>
</table>
<p><code>接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构</code></p>
<table>
<thead>
<tr>
<th>SQL高级部分</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL体系结构和存储引擎介绍</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105393816">https://blog.csdn.net/qq_43040688/article/details/105393816</a></td>
</tr>
<tr>
<td>InnoDB存储引擎</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105415093">https://blog.csdn.net/qq_43040688/article/details/105415093</a></td>
</tr>
<tr>
<td>MySQL 索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105419053">https://blog.csdn.net/qq_43040688/article/details/105419053</a></td>
</tr>
<tr>
<td>MySQL创建高性能的索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105454477">https://blog.csdn.net/qq_43040688/article/details/105454477</a></td>
</tr>
<tr>
<td>MySQL查询性能优化</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105456790">https://blog.csdn.net/qq_43040688/article/details/105456790</a></td>
</tr>
<tr>
<td>MySQL锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105440448">https://blog.csdn.net/qq_43040688/article/details/105440448</a></td>
</tr>
<tr>
<td>MySQL事务</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441274">https://blog.csdn.net/qq_43040688/article/details/105441274</a></td>
</tr>
<tr>
<td>MySQL备份</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441944">https://blog.csdn.net/qq_43040688/article/details/105441944</a></td>
</tr>
<tr>
<td>MySQL架构</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105450005">https://blog.csdn.net/qq_43040688/article/details/105450005</a></td>
</tr>
<tr>
<td>MySQL高级特性</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105465192">https://blog.csdn.net/qq_43040688/article/details/105465192</a></td>
</tr>
<tr>
<td>分库分表的高频面试题</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105594653">https://blog.csdn.net/qq_43040688/article/details/105594653</a></td>
</tr>
</tbody>
</table>
<h3 id="12-非关系型数据库">1.2 非关系型数据库</h3>
<h4 id="redis">Redis</h4>
<h2 id="二-java基础">二、Java基础</h2>
<h3 id="21-java虚拟机已更新">2.1 Java虚拟机（已更新）</h3>
<p>虛拟机推荐 <strong>《深入理解Java虚拟机》</strong> 这本书，重点学习一下<code>内存</code>、<code>垃圾回收</code>、<code>类加载机制</code>这几部分内容。</p>
<table>
<thead>
<tr>
<th>JVM内存结构</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>JVM简介</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104964070">https://blog.csdn.net/qq_43040688/article/details/104964070</a></td>
</tr>
<tr>
<td>程序计数器和虚拟机栈</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104970081">https://blog.csdn.net/qq_43040688/article/details/104970081</a></td>
</tr>
<tr>
<td>本地方法栈和堆</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104972811">https://blog.csdn.net/qq_43040688/article/details/104972811</a></td>
</tr>
<tr>
<td>方法区</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104982648">https://blog.csdn.net/qq_43040688/article/details/104982648</a></td>
</tr>
<tr>
<td>直接内存</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104996032">https://blog.csdn.net/qq_43040688/article/details/104996032</a></td>
</tr>
</tbody>
</table>
<h3 id="22-java并发已更新">2.2 Java并发（已更新）</h3>
<blockquote>
<p>Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久</p>
</blockquote>
<h4 id="java并发基础">Java并发基础</h4>
<blockquote>
<p>学习Java并发，需要先掌握线程的一些基础知识<br>
这些基础知识的组合构成了后面的设计模式</p>
</blockquote>
<ul>
<li>首先应该了解如何启动一个多线程，即<strong>使用Runnable、Callable、Thread</strong>；还需要了解线程启动后的<strong>生命周期</strong>，<strong>了解了不用实现方式的差别</strong>，最重要的<strong>研读Thread的源码</strong>，详情参考：<code>Java多线程起步</code>，<code>Thread构造函数源码分析</code></li>
<li>需要学习<strong>Thread常用API</strong>以及<strong>三种关闭线程的方式</strong>，详情参考：<code>Thread的API</code></li>
<li>需要了解<strong>this锁</strong>和<strong>class锁</strong>，详情参考：<code>Java多线程之认识“锁”</code></li>
<li>需要了解<strong>线程间的通讯</strong>，最基本的就是消费者和生产者模型，需要深入了解了<strong>wait、sleep、notify、nitifyAll</strong>的机制和差异，对于<strong>wait set</strong>要有个清晰的认识，详情参考：<code>Java多线程之线程间的通讯</code></li>
<li>需要尝试自定义了一个<strong>Boolean锁</strong>，了解了<strong>加锁和释放锁的过程</strong>，实现了获取正在阻塞的线程；需要了解<strong>线程运行时出现异常的处理方式</strong><br>
，详情参考：<code>自定义Boolean锁&amp;捕获线程中的异常</code></li>
<li>需要学习了<strong>线程组的概念以及常用API</strong>，如interrupt，setDaemon，activeCount，enumerate， 详情参考：<code>线程组</code></li>
<li>需要<strong>自定义了一个线程池</strong>，对线程池的处理机制有了较深的理解，详情参考：<code>自定义线程池</code></li>
</ul>
<table>
<thead>
<tr>
<th>Java并发基础</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java多线程起步</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/103979628">https://blog.csdn.net/qq_43040688/article/details/103979628</a></td>
</tr>
<tr>
<td>Thread构造函数源码分析</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105543926">https://blog.csdn.net/qq_43040688/article/details/105543926</a></td>
</tr>
<tr>
<td>Thread的API</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105747547">https://blog.csdn.net/qq_43040688/article/details/105747547</a></td>
</tr>
<tr>
<td>Java多线程之认识“锁”</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105752943">https://blog.csdn.net/qq_43040688/article/details/105752943</a></td>
</tr>
<tr>
<td>Java多线程之线程间的通讯</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105754406">https://blog.csdn.net/qq_43040688/article/details/105754406</a></td>
</tr>
<tr>
<td>自定义Boolean锁&amp;捕获线程中的异常</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105771445">https://blog.csdn.net/qq_43040688/article/details/105771445</a></td>
</tr>
<tr>
<td>线程组</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105774614">https://blog.csdn.net/qq_43040688/article/details/105774614</a></td>
</tr>
<tr>
<td>自定义线程池</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105786243">https://blog.csdn.net/qq_43040688/article/details/105786243</a></td>
</tr>
</tbody>
</table>
<h4 id="多线程的设计模式">多线程的设计模式</h4>
<blockquote>
<p>Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合<font color = "red">以满足应用需求</font><br>
<strong>下面有十四个多线程的设计模式，帮助理解后面的JUC包。</strong></p>
</blockquote>
<ul>
<li>
<p>第一个设计模式是：<strong>观察者模式</strong>。需要定义一个<strong>主题</strong>，一个<strong>观察者</strong>。<font color = "purple">主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。</font>详情参考：<code>观察者模式</code></p>
</li>
<li>
<p>第二个设计模式是：<strong>单例模式</strong>。解决方式有三种：<font color = "purple">第一种是double check方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static 类实现；第三种是利用enum类实现。</font>详情参考：<code>单例模式</code></p>
</li>
<li>
<p>第三个设计模式是<strong>单线程执行模式</strong>。<font color = "purple">就是在同一时刻只能有一个对共享资源进行操作。</font>详情参考：<code>单线程执行设计模式</code></p>
</li>
<li>
<p>第四个设计模式<strong>不可变对象设计模式</strong>。<font color = "purple">是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。</font>详情参考：<code>不可变对象设计模式</code></p>
</li>
<li>
<p>第五个设计模式<strong>确保挂起设计模式</strong>。<font color = "purple">当线程在工作时，如果来了其他任务，将任务放入到队列中等待。</font>详情参考：<code>确保挂起设计模式</code></p>
</li>
<li>
<p>第六个设计模式<strong>Balking设计模式</strong>。<font color = "purple">当工作已经执行过了，就直接return，防止重复的工作，提高效率。</font>详情参考：<code>Balking设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>生产者-消费者设计模式</strong>。<font color = "purple">如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。</font>详情参考：<code>生产者-消费者设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>读写锁的设计模式</strong>。<font color = "purple">读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能</font>。详情参考：<code>读写锁的设计模式</code></p>
</li>
<li>
<p>第八个设计模式<strong>Thread-Per-Message</strong>。<font color = "purple">每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。</font>详情参考：<code>Thread-Per-Message</code></p>
</li>
<li>
<p>第九个设计模式 <strong>Worker 设计模式</strong>。<font color = "purple">需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。</font><br>
详情参考：<code>Worker 设计模式</code></p>
</li>
<li>
<p>第十个设计模式<strong>Future设计模式</strong>。<font color = "purple">通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。</font>详情参考：<code>Future设计模式</code></p>
</li>
<li>
<p>第十一个设计模式<strong>两阶段终止设计模式</strong>。<font color = "purple">当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。</font>详情参考：<code>两阶段终止设计模式</code></p>
</li>
<li>
<p>第十二个设计模式<strong>线程保险箱设计模式</strong>。<font color = "purple">利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。</font >详情参考：<code>线程保险箱设计模式</code>和<code>上下文设计模式</code></p>
</li>
<li>
<p>第十三个设计模式<strong>Active Objects 设计模式</strong>。<font color = "purple">接受异步调用的主动方法。可以主动异步的执行一些任务。</font>详情参考：<code>Active Objects 设计模式</code></p>
</li>
<li>
<p>第十四个设计模式<strong>Count Down设计模式</strong>。<font color = "purple">多个子任务执行，主任务等待子任务全部执行完，再执行</font>详情参考：<code>Count Down设计模式</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>多线程的设计模式</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>观察者模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105835544">https://blog.csdn.net/qq_43040688/article/details/105835544</a></td>
</tr>
<tr>
<td>单例模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105798423">https://blog.csdn.net/qq_43040688/article/details/105798423</a></td>
</tr>
<tr>
<td>单线程执行设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105856901">https://blog.csdn.net/qq_43040688/article/details/105856901</a></td>
</tr>
<tr>
<td>不可变对象设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105865371">https://blog.csdn.net/qq_43040688/article/details/105865371</a></td>
</tr>
<tr>
<td>确保挂起设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105886681">https://blog.csdn.net/qq_43040688/article/details/105886681</a></td>
</tr>
<tr>
<td>Balking设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105890674">https://blog.csdn.net/qq_43040688/article/details/105890674</a></td>
</tr>
<tr>
<td>生产者-消费者设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105891561">https://blog.csdn.net/qq_43040688/article/details/105891561</a></td>
</tr>
<tr>
<td>读写锁的设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105857920">https://blog.csdn.net/qq_43040688/article/details/105857920</a></td>
</tr>
<tr>
<td>Thread-Per-Message</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892219">https://blog.csdn.net/qq_43040688/article/details/105892219</a></td>
</tr>
<tr>
<td>Worker 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105894685">https://blog.csdn.net/qq_43040688/article/details/105894685</a></td>
</tr>
<tr>
<td>Future设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105868293">https://blog.csdn.net/qq_43040688/article/details/105868293</a></td>
</tr>
<tr>
<td>两阶段终止设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892777">https://blog.csdn.net/qq_43040688/article/details/105892777</a></td>
</tr>
<tr>
<td>线程保险箱设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105887378">https://blog.csdn.net/qq_43040688/article/details/105887378</a></td>
</tr>
<tr>
<td>上下文设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105888242">https://blog.csdn.net/qq_43040688/article/details/105888242</a></td>
</tr>
<tr>
<td>Active Objects 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105895280">https://blog.csdn.net/qq_43040688/article/details/105895280</a></td>
</tr>
<tr>
<td>Count Down设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892054">https://blog.csdn.net/qq_43040688/article/details/105892054</a></td>
</tr>
</tbody>
</table>
<h4 id="java高并发与jvm的关系">Java高并发与JVM的关系</h4>
<blockquote>
<p>主要是学习<code>wait set</code>、<code>JMM模型</code></p>
</blockquote>
<p><strong>JMM模型中有四个内容</strong>，主要参看博客：<code>Java多线程之内存模型三大特性</code>。如果想学习更多，请学习JVM的部分。</p>
<ul>
<li><strong>解决高速缓存中数据不一致性的问题</strong>——总线锁（效率低）、高速缓存一致性协议，英特尔</li>
<li><strong>高并发的三个要求</strong>——原子性、可见性、有序性</li>
<li><strong>happens-before</strong></li>
<li><strong>指令重排序</strong></li>
</ul>
<p>Java多线程之内存模型三大特性：<a href="https://blog.csdn.net/qq_43040688/article/details/105823532">https://blog.csdn.net/qq_43040688/article/details/105823532</a></p>
<h4 id="原子包">原子包</h4>
<p><strong>CAS</strong>  ：</p>
<ul>
<li>乐观锁，CompareAndSwap。</li>
<li>优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。</li>
<li>缺点：在竞争激烈的情况下，浪费CUP资源。</li>
<li>还有一个问题是ABA问题，解决方法是：加一个版本号。</li>
<li>详情参考：<code>CAS</code></li>
</ul>
<p><strong>UnSafe类</strong></p>
<ul>
<li>内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式</li>
<li>获取Unsafe需要通过<code>反射</code>Unsafe类的属性</li>
<li>常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现</li>
<li>详情参考：<code>UnSafe类</code></li>
</ul>
<p><strong>AtomicInteger和AtomicBoolean</strong>：</p>
<ul>
<li>是保证原子性的对象。</li>
<li>利用的CAS</li>
<li>详情参考：<code>AtomicInteger</code>和<code>AtomicBoolean</code></li>
</ul>
<p><strong>AtomicReference</strong></p>
<ul>
<li>是一个利用CAS帮助对象保证原子性的</li>
<li>但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：<code>CAS</code></li>
<li>详情参考：<code>AtomicReference</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAS</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105914717">https://blog.csdn.net/qq_43040688/article/details/105914717</a></td>
</tr>
<tr>
<td>AtomicInteger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105908835">https://blog.csdn.net/qq_43040688/article/details/105908835</a></td>
</tr>
<tr>
<td>AtomicBoolean</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105917939">https://blog.csdn.net/qq_43040688/article/details/105917939</a></td>
</tr>
<tr>
<td>AtomicReference</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105918329">https://blog.csdn.net/qq_43040688/article/details/105918329</a></td>
</tr>
<tr>
<td>UnSafe类</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105923421">https://blog.csdn.net/qq_43040688/article/details/105923421</a></td>
</tr>
</tbody>
</table>
<h4 id="juc工具包">JUC工具包</h4>
<p><strong>CountDownLatch</strong></p>
<ul>
<li>通过一个计数器实现，计数器初始值就是线程的数量</li>
<li>每当一个线程完成任务，就会使计数减一</li>
<li>可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成</li>
<li>详情见：<code>CountDownLatch</code></li>
</ul>
<p><strong>CyclicBarrier</strong></p>
<ul>
<li>跟<code>CountDownLatch</code>的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点</li>
<li>详情见：<code>CyclicBarrier</code></li>
</ul>
<p><strong>Phaser</strong></p>
<ul>
<li>JDK1.7之后引用的，具有<code>CyclicBarrier</code>和<code>CountDownLatch</code></li>
<li>同时它的注册数是支持动态增加或减少（可以用于线程出现异常）</li>
<li>当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复</li>
<li>详情见：<code>Phaser</code></li>
</ul>
<p><strong>Exchanger</strong></p>
<ul>
<li>用于线程间交换数据</li>
<li>需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题</li>
<li>详情见：<code>Exchanger</code></li>
</ul>
<p><strong>Semaphore</strong></p>
<ul>
<li>是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问</li>
<li>详情见：<code>Semaphore</code></li>
</ul>
<p><strong>ReentrantLock</strong></p>
<ul>
<li>支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的</li>
<li>支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞</li>
<li>需要手动的释放锁，try...finally...</li>
<li>相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高</li>
<li>是一个Java类，具有更多的功能，同时可以自由的扩展</li>
<li>详情请见：<code>ReentrantLock</code></li>
</ul>
<p><strong>读写锁</strong></p>
<ul>
<li>将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能</li>
<li>是悲观锁，可能读的线程太多，写的线程迟迟难以执行</li>
<li>详情请见：<code>读写锁</code></li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li>解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁</li>
<li>思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据</li>
<li>详情请见：<code>StampedLock</code></li>
</ul>
<p><strong>三种锁的比较</strong></p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>StampedLock</th>
<th>Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>是JVM的的内置锁，每个JDK版本都会优化</td>
<td>是一个Java类，可以更好的扩展</td>
<td>是一个Java类，可以更好的扩展</td>
</tr>
<tr>
<td>都是悲观锁</td>
<td>提供了写的乐观锁</td>
<td>都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁</td>
</tr>
<tr>
<td>性能一般，因为有一个从用户态到内核态的过程</td>
<td>性能最好，可以代替读写锁</td>
<td>性能十分不稳定，在复杂的读写环境下，性能十分差</td>
</tr>
</tbody>
</table>
<ul>
<li>详情请见：<code>三种锁的比较</code></li>
</ul>
<p><strong>ForkJoin</strong></p>
<ul>
<li>基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行</li>
<li>分为Fork和Join两个阶段，充分利用CPU资源</li>
<li>详情请见：<code>ForkJoin</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountDownLatch</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105935307">https://blog.csdn.net/qq_43040688/article/details/105935307</a></td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105937169">https://blog.csdn.net/qq_43040688/article/details/105937169</a></td>
</tr>
<tr>
<td>Phaser</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106033183">https://blog.csdn.net/qq_43040688/article/details/106033183</a></td>
</tr>
<tr>
<td>Exchanger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105955788">https://blog.csdn.net/qq_43040688/article/details/105955788</a></td>
</tr>
<tr>
<td>Semaphore</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105956731">https://blog.csdn.net/qq_43040688/article/details/105956731</a></td>
</tr>
<tr>
<td>ReentrantLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105958719">https://blog.csdn.net/qq_43040688/article/details/105958719</a></td>
</tr>
<tr>
<td>读写锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105975257">https://blog.csdn.net/qq_43040688/article/details/105975257</a></td>
</tr>
<tr>
<td>StampedLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106026847">https://blog.csdn.net/qq_43040688/article/details/106026847</a></td>
</tr>
<tr>
<td>三种锁的比较</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032189">https://blog.csdn.net/qq_43040688/article/details/106032189</a></td>
</tr>
<tr>
<td>ForkJoin</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032309">https://blog.csdn.net/qq_43040688/article/details/106032309</a></td>
</tr>
</tbody>
</table>
<h4 id="exectors框架">Exectors框架</h4>
<blockquote>
<p>首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。</p>
</blockquote>
<p><strong>ThreadPoolExecutor</strong></p>
<ul>
<li>创建线程池有七大参数，<code>特别重要</code></li>
<li>有四种拒绝策略</li>
<li>四种阻塞队列</li>
<li>一些调试的API</li>
<li>关闭线程池的注意事项</li>
<li>详情请见：<code>ThreadPoolExecutor</code></li>
</ul>
<p><strong>Executors</strong><br>
用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：</p>
<ul>
<li>newCachedThreadPool</li>
<li>newFixedThreadPool</li>
<li>newScheduledThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newWorkStealingPool</li>
<li>详情请见：<code>Executors</code></li>
</ul>
<p><strong>CompletionService</strong></p>
<ul>
<li>用来增强线程池，主要思想是：<code>执行一批任务，先执行的，先获取结果</code></li>
<li>实现的子类是：<code>ExecutorCompletionService</code></li>
<li>详情请见：<code>CompletionService</code></li>
</ul>
<p><strong>CompleableFuture</strong></p>
<ul>
<li>可以进行串联的操作，即利用上一个任务的结果，执行下一个任务</li>
<li>进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果</li>
<li>可以不需要调用者主动获取结果，而进行回调</li>
<li>执行一批任务时，获取的Future是按照任务完成的顺序</li>
<li>创建CompleableFuture有多种方式，最多的是<code>runAsync</code>和<code>supplyAsync</code></li>
<li>API分为组合方法、中转方法和终结方法</li>
<li>详情请见：<code>CompleableFuture</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolExecutor</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106041236">https://blog.csdn.net/qq_43040688/article/details/106041236</a></td>
</tr>
<tr>
<td>Executors</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106046629">https://blog.csdn.net/qq_43040688/article/details/106046629</a></td>
</tr>
<tr>
<td>CompletionService</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106058225">https://blog.csdn.net/qq_43040688/article/details/106058225</a></td>
</tr>
<tr>
<td>CompleableFuture</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106061776">https://blog.csdn.net/qq_43040688/article/details/106061776</a></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMQ监控平台（附网盘链接）]]></title>
        <id>https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/</id>
        <link href="https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/">
        </link>
        <updated>2020-06-16T12:01:12.000Z</updated>
        <content type="html"><![CDATA[<p><code>RocketMQ</code>有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，先将<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>拉到本地，因为我们需要自己对<code>rocketmq-console</code>进行编译打包运行。</p>
<p>在linux环境下，使用<code>nohub java -jar xxxx &amp;</code>  启动，为了防止端口冲突，已经修改其端口为<strong>9999</strong></p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA">https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA</a><br>
提取码：jpg0</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020053110115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQwNjg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="352-下载并编译打包">3.5.2 下载并编译打包</h3>
<pre><code class="language-sh">git clone https://github.com/apache/rocketmq-externals
cd rocketmq-console
mvn clean package -Dmaven.test.skip=true
</code></pre>
<p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：</p>
<pre><code class="language-sh">rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876
</code></pre>
<p>启动rocketmq-console：</p>
<pre><code class="language-sh">java -jar rocketmq-console-ng-1.0.0.jar
</code></pre>
<p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200531101225351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQwNjg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
</feed>