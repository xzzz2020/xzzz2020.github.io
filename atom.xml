<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-11-13T07:23:20.050Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[thymeleaf手动渲染@{}的问题与解决]]></title>
        <id>https://xzzz2020.github.io/post/wrYT9T5SW/</id>
        <link href="https://xzzz2020.github.io/post/wrYT9T5SW/">
        </link>
        <updated>2020-11-04T08:29:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-简介">一、简介</h2>
<p>最近写了一个项目，然后<strong>想利用TemplateEngine实现thymeleaf的手动渲染，将生成的html页面加入Redis缓存，提高项目访问速度。</strong></p>
<h2 id="二-springboot-1x实现">二、SpringBoot 1.x实现</h2>
<p>以前使用的maven版本如下所示：</p>
<pre><code class="language-xml">  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
  &lt;/parent&gt;
    &lt;!-- SpringMVC --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- thymeleaf --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<p>可以看出是springboot1.x版本。</p>
<p>附上该版本thymeleaf手动渲染的实现。</p>
<pre><code class="language-java">    @RequestMapping(value = &quot;/to_list&quot;, produces = &quot;text/html&quot;)
    @ResponseBody
    public String toGoods(Model model, MiaoshaUser user,
                          final HttpServletRequest request,
                          final HttpServletResponse response) {

        //取缓存
        String html;
        html = redisService.get(GoodsKey.getGoodsList(), &quot;&quot;, String.class);
        if (html != null) {//如果缓存有这个页面
            return html;
        } else {//如果没有这个页面
            //访问数据库获取商品数据
            List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();
            if (user != null) {
                //如果有用户信息，则保存在Model中
                model.addAttribute(&quot;user&quot;, user);
            }
            //将商品数据保存在Model中
            model.addAttribute(&quot;goodsList&quot;, goodsList);

            //手动渲染
            SpringWebContext springWebContext = new SpringWebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap(), context);
            html = viewResolver.getTemplateEngine().process(&quot;goods_list&quot;, springWebContext);
            if (!StringUtils.isEmpty(html)) {
                //保存到缓存
                redisService.set(GoodsKey.getGoodsList(), &quot;&quot;, html);
            }
            //返回到浏览器
            return html;
        }

    }
</code></pre>
<p><strong>需要依赖两个类</strong>：ThymeleafViewResolver以及ApplicationContext</p>
<p>这两个类都可以通过Spring容器注入进去，如下所示：</p>
<pre><code class="language-java">@Autowired
private ThymeleafViewResolver viewResolver;

@Autowired
private ApplicationContext context;
</code></pre>
<p>将上面手动渲染流程代码抽离出来，使用模版如下：</p>
<pre><code class="language-java">//首先创建一个上下文容器，context是Spring的ApplicationContext
SpringWebContext springWebContext = new SpringWebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap(), context);

//获取模版引擎，进行使用process方法解析
//第一个参数&quot;goods_list&quot;指需要解析的thymeleaf模版，一般在template目录下
//第二个参数就是上下文容器
html = viewResolver.getTemplateEngine().process(&quot;goods_list&quot;, springWebContext);
if (!StringUtils.isEmpty(html)) {
    //保存到缓存
    redisService.set(GoodsKey.getGoodsList(), &quot;&quot;, html);
}
//返回到浏览器
return html;
</code></pre>
<h2 id="三-springboot-2x实现">三、Springboot 2.x实现</h2>
<p>pom.xml如下所示：</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.17.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>首先如果直接使用上面的方式，会发现找不到SpringWebContext这个类，这个类是Spring4下的，在Spring5如移除掉了。</p>
<p>那么我们可以使用其他的类进行代替。</p>
<h3 id="1-第一个是context">1. 第一个是Context</h3>
<p>这个是很多博主使用的方式，我最初也采用了这种，这种文章比较多，博主就不再演示了。</p>
<p>当页面在渲染@{}标签时，就会报错，如下所示：</p>
<blockquote>
<p>Caused by: org.attoparser.ParseException: Link base &quot;/css/global.css&quot; cannot be context relative (/...) unless the context used for executing the engine implements the org.thymeleaf.context.IWebContext interface (template: &quot;/mail/activation&quot; - line 6, col 25)</p>
<p>Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Link base &quot;/css/global.css&quot; cannot be context relative (/...) unless the context used for executing the engine implements the org.thymeleaf.context.IWebContext interface (template: &quot;/mail/activation&quot; - line 6, col 25)</p>
</blockquote>
<p><strong>这个是因为没有使用IWebContext 的接口容器所导致</strong></p>
<h3 id="2-第二个是webcontext类">2. 第二个是WebContext类</h3>
<p>使用方式如下：</p>
<pre><code class="language-java">IWebContext webContext = new WebContext(request,response,request.getServletContext(),response.getLocale(),model.asMap());
String cacheHtml = templateEngine.process(&quot;/index&quot;, webContext);
</code></pre>
<p>此时就不会报错，相比Spring4或者Springboot1.x而言，剔除了ApplicationContext 过多的依赖，现在thymeleaf渲染不再过多依赖spring容器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】ZooKeeper基础]]></title>
        <id>https://xzzz2020.github.io/post/ZhQcE1ff2/</id>
        <link href="https://xzzz2020.github.io/post/ZhQcE1ff2/">
        </link>
        <updated>2020-09-21T09:26:05.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8Ezookeeper%E7%AE%80%E4%BB%8B">一、分布式系统与Zookeeper简介</a>
<ul>
<li><a href="#1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bzookeeper">1. 简单介绍一下Zookeeper</a></li>
<li><a href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">2. 什么是分布式系统？</a></li>
<li><a href="#3-%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8Bzookeeper%E7%9A%84%E7%89%B9%E6%80%A7">3. 列举一下Zookeeper的特性</a></li>
<li><a href="#4-zoocfg%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B">4. zoo.cfg常用配置有哪些？</a></li>
<li><a href="#5-zookeeper%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8">5. Zookeeper都有哪些作用？</a></li>
<li><a href="#6-session%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">6. session的基本原理</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">二、Zookeeper的基本数据模型</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">2. 基本操作</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-watcher%E6%9C%BA%E5%88%B6">三、Watcher机制</a>
<ul>
<li><a href="#1-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bwatcher%E6%9C%BA%E5%88%B6">1. 简单描述一下Watcher机制</a></li>
<li><a href="#2-watcher%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">2. Watcher的事件类型都有哪些？</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%9A%84watcher">3. 创建节点的Watcher</a></li>
<li><a href="#4-watcher%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4. watcher的使用场景</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-acl%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">四、ACL权限控制</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B-2">1. 简介</a></li>
<li><a href="#2-acl%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90">2. Acl权限列表的构成</a></li>
<li><a href="#3-%E6%9D%83%E9%99%90%E6%9C%BA%E5%88%B6">3. 权限机制</a></li>
<li><a href="#4-%E6%9D%83%E9%99%90%E7%BB%84%E5%90%88%E5%AD%97%E7%AC%A6%E4%B8%B2">4. 权限组合字符串</a></li>
<li><a href="#5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C">5. 命令行相关操作</a></li>
<li><a href="#6-%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6. 常用使用场景</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-four-latter-words">五、Four Latter Words</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B-3">1. 简介</a></li>
<li><a href="#2-%E5%B8%B8%E8%A7%81%E5%9B%9B%E5%AD%97%E5%91%BD%E4%BB%A4">2. 常见四字命令</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-分布式系统与zookeeper简介">一、分布式系统与Zookeeper简介</h2>
<h3 id="1-简单介绍一下zookeeper">1. 简单介绍一下Zookeeper</h3>
<ul>
<li>是一个<strong>中间件</strong>，可以提供协调服务，比如说存储消息</li>
<li>作用于<strong>分布式系统</strong>，发挥其优势，可以为大数据服务</li>
<li>支持Java，提供java和c客户端的API</li>
</ul>
<h3 id="2-什么是分布式系统">2. 什么是分布式系统？</h3>
<ul>
<li>很多台计算机组成一个整体，一个整体一致对外并且处理同一个请求</li>
<li>内部的每台计算机都可以互相通信（rest/rpc）</li>
<li>客户端到服务端的一次请求到相应结束会历经多台计算机</li>
</ul>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200917163612201.png" alt="image-20200917163612201" style="zoom: 67%;" />
<h3 id="3-列举一下zookeeper的特性">3. 列举一下Zookeeper的特性</h3>
<ul>
<li><strong>一致性</strong>：数据一致性，只能保证数据的最终一致性，而不是强一致性，也就是说数据按照顺序分批入库，慢慢保存进来</li>
<li><strong>原子性</strong>：事务要么成功，要么失败，不会局部化，局部化指的是部分机器成功，部分机器失败</li>
<li><strong>单一视图</strong>：客户端连接集群中任意一个zookeeper节点，数据都是一致的</li>
<li><strong>可靠性</strong>：每次对zookeeper的操作状态都会保存到服务端，我们可以去查看这个状态</li>
<li><strong>实时性</strong>：客户端可以读到zookeeper服务端的最新数据</li>
</ul>
<h3 id="4-zoocfg常用配置有哪些">4. zoo.cfg常用配置有哪些？</h3>
<ol>
<li>
<p><strong>tickTime</strong>：用于计算的基本时间单元，默认是2000ms。比如Session超时：给一个N倍数，N*ticktime后，会销毁</p>
</li>
<li>
<p><strong>initLimit</strong>：用于集群，允许从节点连接并同步到master节点的初始化连接时间，以tickTime倍数表示，默认10倍</p>
</li>
<li>
<p><strong>syncLimit</strong>：用于集群，master主节点与从节点之间发送消息，请求和应答的时间（心跳机制），默认5倍</p>
</li>
<li>
<p><strong>dataDir</strong>：数据存储的目录，必须指定</p>
</li>
<li>
<p><strong>dataLogDir</strong>：日志目录，如果没有配置，将存储在dataDir</p>
</li>
<li>
<p><strong>clientPort</strong>：连接服务器的端口，默认2181</p>
</li>
</ol>
<h3 id="5-zookeeper都有哪些作用">5. Zookeeper都有哪些作用？</h3>
<ul>
<li><strong>master节点选举</strong>：主节点挂了以后，从节点就会接手主节点的工作，并且保证这个节点是唯一的。这也是首脑模式，从而保证我们的集群是高可用的。</li>
<li><strong>统一配置文件管理</strong>：只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，此操作在云计算中用的比较多，比如可以统一修改redis的配置</li>
<li><strong>发布与订阅</strong>：类似消息队列MQ，dubbo发布者把数据存储在znode上，订阅者会读取这个数据</li>
<li><strong>提供分布式锁</strong>：提供在分布式环境下，类似于多线程中锁的机制，让不同的进制之间争夺资源</li>
</ul>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200918095528121.png" alt="image-20200918095528121" style="zoom: 33%;" />
<ul>
<li><strong>集群管理</strong>：集群中保证数据的强一致性。一个客户端修改了主节点的数据，那么主节点的附属节点也会同步修改，保证客户端不管从哪个节点读取数据，都是一致的</li>
</ul>
<h3 id="6-session的基本原理">6. session的基本原理</h3>
<ul>
<li>
<p>客户端与服务端之间的连接存在会话，类似于Servlet中的session</p>
</li>
<li>
<p>每个会话都可以设置一个超时时间，客户端会定时向服务端发送一个ping包；心跳检测超时后，会话就会被清除</p>
</li>
<li>
<p>如果session过期，临时节点znode就会被抛弃或者删除</p>
</li>
</ul>
<h2 id="二-zookeeper的基本数据模型">二、Zookeeper的基本数据模型</h2>
<h3 id="1-简介">1. 简介</h3>
<ul>
<li>是一个<strong>树形结构</strong>，zk的数据模型也可以理解为linux/unix的文件目录：/usr/local....</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/img_convert/c8c4e14273185d69bec7b7505fd0ba6a.png" alt="image-20200918092521359" loading="lazy"></figure>
<ul>
<li>每一个节点都称之为<strong>znode</strong>，它可以有子节点，也可以有数据</li>
<li>每一个节点分为<strong>临时节点和永久节点</strong>。临时节点除了人为对数据的操作，数据在客户端断开后也会消失；而永久节点相当于一个持久化的过程，这些数据只能人为添加或者删除。</li>
<li>每一个zk节点都有各自的<strong>版本号</strong>，可以通过命令行来显示节点信息</li>
<li>每当该节点的数据发生变化，该节点的版本号就会采用<strong>乐观锁</strong>的方式累加</li>
<li>删除或者修改过时的节点，<strong>版本号不匹配</strong>会报错</li>
<li>每个zk节点存储的<strong>数据不宜过大</strong>，几k即可</li>
<li>节点可以设置<strong>权限acl</strong>，可以通过权限限制用户的访问</li>
</ul>
<h3 id="2-基本操作">2. 基本操作</h3>
<ol>
<li><strong>启动zk和客户端连接zk</strong></li>
</ol>
<pre><code class="language-shell">../bin/zkServer.sh start

../bin/zkCli.sh
</code></pre>
<ol start="2">
<li><strong>显示指定节点的子节点</strong></li>
</ol>
<pre><code class="language-shell">ls /xxxx/xxx
</code></pre>
<ol start="3">
<li><strong>显示指定节点的子节点以及状态信息</strong></li>
</ol>
<pre><code class="language-shell">ls2 /xxxx/xxx  # 相当于ls + stat
</code></pre>
<p><strong>状态信息解释</strong>：</p>
<blockquote>
<p><strong>cZxid</strong>：创建时节点的id</p>
<p><strong>ctime</strong>：创建节点的时间</p>
<p><strong>mZxid</strong>：修改后的节点id</p>
<p><strong>mtime</strong>：修改节点的时间</p>
<p><strong>pZxid</strong>：子节点的id</p>
<p><strong>cversion</strong>：子节点的version</p>
<p><strong>dataVersion</strong>：当前节点的版本号</p>
<p><strong>aclVersion</strong>：权限相关版本号</p>
<p><strong>ephemeralOwner</strong>：如果是0x0代表是永久节点，反之是临时节点</p>
<p><strong>dataLength</strong>：数据长度</p>
<p><strong>numChildren</strong>：子节点的个数</p>
</blockquote>
<ol start="4">
<li><strong>显示节点的状态</strong></li>
</ol>
<pre><code class="language-shell">stat /xxx/xxx
</code></pre>
<ol start="5">
<li><strong>取出指定节点的数据</strong></li>
</ol>
<pre><code class="language-shell">get /xxx/xxx
</code></pre>
<ol start="6">
<li><strong>创建节点</strong></li>
</ol>
<pre><code class="language-shell">creat [节点名称] [数据]  # 默认创建一个无序且持久化的永久节点
creat -e [节点名称] [数据] # 创建一个临时的节点
creat -s [节点名称] [数据]  # 默认创建一个有序且持久化的永久节点，每次累加1
</code></pre>
<ol start="7">
<li><strong>覆盖节点的数据</strong></li>
</ol>
<pre><code class="language-shell">set [节点名称] [数据]  # 直接覆盖节点的数据，并让其版本号+1
set [节点名称] [数据] [期望的版本号] # 类似于CAS，比较当前版本号和期望版本号是否相同，不同会报错
</code></pre>
<ol start="8">
<li><strong>删除节点</strong></li>
</ol>
<pre><code class="language-shell">delete [节点名称] # 直接删除该节点
delete [节点名称] [期望的版本号] # 只有版本号和当前最新的匹配才可以删除
</code></pre>
<blockquote>
<p>建议使用带版本号的更新和删除机制，这样才可以实现乐观锁的机制</p>
</blockquote>
<h2 id="三-watcher机制">三、Watcher机制</h2>
<h3 id="1-简单描述一下watcher机制">1. 简单描述一下Watcher机制</h3>
<ul>
<li>针对每个节点的操作，比如说更新删除操作，都会有一个监督者，叫做watcher</li>
<li>当监控的某个对象（znode）发生了变化，则触发watcher事件，<strong>对于不同的操作，触发的watcher是不同的</strong>，比如说：节点创建、节点删除、节点数据更新</li>
<li>zk中watcher是<strong>一次性</strong>的，触发后就会立即销毁</li>
<li>父节点和子节点都会触发watcher，也就是说<strong>对子节点进行操作时，该子节点的父节点也会触发</strong></li>
</ul>
<h3 id="2-watcher的事件类型都有哪些">2. Watcher的事件类型都有哪些？</h3>
<ul>
<li><strong>创建父节点触发</strong>：NodeCreated</li>
<li><strong>修改父节点数据触发</strong>：NodeDataChanged</li>
<li><strong>删除父节点触发</strong>：NodeDeleted</li>
<li><strong>创建子节点时触发</strong>：NodeChildrenChanged，需要先在父节点创建watcher</li>
<li><strong>删除子节点时触发</strong>：NodeChildrenChanged，需要先在父节点创建watcher</li>
<li><strong>修改子节点时</strong>：不会触发任何事件，如果想要触发watcher，需要把该子节点当作父节点来创建和观察watcher</li>
</ul>
<h3 id="3-创建节点的watcher">3. 创建节点的Watcher</h3>
<pre><code class="language-shell">get [节点名称] watcher
stat [节点名称] watcher
ls [节点名称] watcher
ls2 [节点名称] watcher
</code></pre>
<h3 id="4-watcher的使用场景">4. watcher的使用场景</h3>
<ul>
<li><strong>统一资源配置</strong>：在一个zk集群中，给每个节点设置一个watcher。修改集群中节点的数据，此时会触发watcher修改客户端的配置；与此同时，集群中所有的zk都会更新数据并且触发watcher，最后将更新所有的配置信息</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/img_convert/8916c09e1c686af873c4d0f9edb02100.png" alt="image-20200919111156393" loading="lazy"></figure>
<h2 id="四-acl权限控制">四、ACL权限控制</h2>
<h3 id="1-简介-2">1. 简介</h3>
<ul>
<li>针对节点可以<strong>设置相关读写等权限</strong>，目的是<strong>保障数据安全性</strong></li>
<li>权限permissions可以指定不同的权限范围和角色</li>
</ul>
<h3 id="2-acl权限列表的构成">2. Acl权限列表的构成</h3>
<blockquote>
<p>acl通过[scheme: id : permissions​]来构成权限列表</p>
</blockquote>
<ul>
<li><strong>scheme</strong>：代表某种权限机制</li>
<li><strong>id</strong>：代表允许访问的用户</li>
<li><strong>permissions</strong>：权限组合字符串</li>
</ul>
<h3 id="3-权限机制">3. 权限机制</h3>
<ul>
<li>
<p><strong>world</strong>：world下只有一个id，即只有一个用户，也就是anyone，代表的是默认权限。组合的写法就是：world:anyone: [permissions]</p>
</li>
<li>
<p><strong>auth</strong>：代表认证登录，需要注册用户拥有权限。组合的写法就是：auth:user:password:[permissions]</p>
</li>
<li>
<p><strong>digest</strong>：需要对密码加密后才能访问。组合的写法就是：digest:user:BASE64(SHA1(password)):[permissions]</p>
</li>
<li>
<p><strong>ip</strong>：限制ip地址访问。组合的写法就是：ip:xxx.xxx.xxx.xxx:[permissions]</p>
</li>
<li>
<p><strong>super</strong>：超级管理员，拥有所有的权限。</p>
</li>
</ul>
<blockquote>
<p>auth和digest的区别在于，前者明文后者密文</p>
</blockquote>
<blockquote>
<p>对于super权限，需要修改zkServer.sh增加super管理员，最后重启zkServer.sh</p>
</blockquote>
<h3 id="4-权限组合字符串">4. 权限组合字符串</h3>
<blockquote>
<p>权限字符串列表：crdwa</p>
</blockquote>
<ul>
<li><strong>create</strong>：创建当前节点的子节点</li>
<li><strong>read</strong>：获取当前节点以及子节点</li>
<li><strong>write</strong>：设置当前节点的数据</li>
<li><strong>delete</strong>：删除当前节点的子节点</li>
<li><strong>admin</strong>：可以分配当前节点的权限</li>
</ul>
<h3 id="5-命令行相关操作">5. 命令行相关操作</h3>
<ol>
<li><strong>获取某个节点的权限信息</strong></li>
</ol>
<pre><code class="language-shell">getAcl [节点名称] 
</code></pre>
<ol start="2">
<li><strong>设置某个节点的权限信息</strong></li>
</ol>
<pre><code class="language-shell">setAcl [节点名称] [权限列表]
</code></pre>
<ol start="3">
<li><strong>注册用户</strong></li>
</ol>
<blockquote>
<p>注册时输入明文密码，但是在zk系统中是以加密的形式存在的</p>
</blockquote>
<pre><code class="language-shell">addauth digest [用户名]:[密码]
</code></pre>
<h3 id="6-常用使用场景">6. 常用使用场景</h3>
<ul>
<li><strong>开发和测试环境分离</strong>，开发者无权操作测试库的节点，只能看；测试和开发连接的节点不同。</li>
<li><strong>防止集群连接混乱</strong>，生产环境上控制指定ip的服务可以访问相关节点</li>
</ul>
<h2 id="五-four-latter-words">五、Four Latter Words</h2>
<h3 id="1-简介-3">1. 简介</h3>
<ul>
<li>zk可以通过它自身提供的简写来和服务器进行交互</li>
<li>需要安装nc：yum install nc</li>
<li>基本使用规则：echo [commond] | nc [ip] [port]，端口和ip之间是一个空格而不是冒号</li>
</ul>
<h3 id="2-常见四字命令">2. 常见四字命令</h3>
<ul>
<li><strong>stat</strong>：查看zk状态信息，以及是否是集群模式</li>
<li><strong>ruok</strong>：查看zkServer是否启动，如果启动会返回一个imok</li>
<li><strong>dump</strong>：列出未经处理的会话和临时节点</li>
<li><strong>conf</strong>：查看zk相关配置</li>
<li><strong>cons</strong>：展示连接到zk的客户端信息</li>
<li><strong>envi</strong>：查看zk的环境变量</li>
<li><strong>mntr</strong>：监控zk的健康信息</li>
<li><strong>wchs</strong>：展示watch的个数</li>
<li><strong>wchc和wchp</strong>：展示watch的详细信息</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】Apache Curator入门使用]]></title>
        <id>https://xzzz2020.github.io/post/H2W9aCW-q/</id>
        <link href="https://xzzz2020.github.io/post/H2W9aCW-q/">
        </link>
        <updated>2020-09-21T09:23:27.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-apache-curator%E7%AE%80%E4%BB%8B">一、Apache Curator简介</a></li>
<li><a href="#%E4%BA%8C-curator%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二、Curator基本操作</a>
<ul>
<li><a href="#1-%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5">1. 重试策略</a></li>
<li><a href="#2-%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%B3%E9%97%ADzookeeper">2. 连接与关闭Zookeeper</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9">3. 创建节点</a></li>
<li><a href="#4-%E5%88%A0%E9%99%A4%E5%92%8C%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9">4. 删除和更新节点</a></li>
<li><a href="#5-%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%8A%82%E7%82%B9">5. 查询节点以及子节点</a></li>
<li><a href="#6-%E5%88%9B%E5%BB%BAwatcher">6. 创建watcher</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-watcher%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9">三、watcher统一配置修改</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-apache-curator简介">一、Apache Curator简介</h2>
<ul>
<li>
<p><strong>解决了watcher的一次性的问题</strong>，注册一个watcher可以触发多次</p>
</li>
<li>
<p>Api简单易用</p>
</li>
<li>
<p>可以<strong>递归创建节点</strong></p>
</li>
<li>
<p><strong>提供ZooKeeper各种应用场景</strong>(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装</p>
</li>
<li>
<p>提供了常用的Zookeeper工具类</p>
</li>
<li>
<p>提供了一套Fluent风格的操作API</p>
</li>
</ul>
<h2 id="二-curator基本操作">二、Curator基本操作</h2>
<h3 id="1-重试策略">1. 重试策略</h3>
<blockquote>
<p>一共有五种重试策略</p>
</blockquote>
<ol>
<li>
<p><strong>重试策略ExponentialBackoffRetry，重试N次限制总的重试时间</strong></p>
<ul>
<li><code>baseSleepTimeMs</code>：两次重试之间的间隔时间</li>
<li><code>maxRetries</code>：最大重试次数，如果超过次数就放弃</li>
<li><code>maxSleepMs</code>：最大重试时间，如果超过该时间就放弃</li>
<li><strong>推荐的使用方式为</strong>：<code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 5);</code></li>
</ul>
</li>
<li>
<p><strong>重试策略RetryNTimes，重试N次</strong></p>
<ul>
<li><code>n</code>：重试的次数</li>
<li><code>sleepMsBetweenRetries</code>：两次重试之间的间隔时间</li>
<li><strong>推荐的使用方式为</strong>：<code>RetryPolicy retryPolicy = new RetryNTimes(3, 5000);</code></li>
</ul>
</li>
<li>
<p><strong>重试策略RetryOneTime，重试一次</strong></p>
<ul>
<li><code>sleepMsBetweenRetry</code>：两次重试之间的间隔时间</li>
<li><strong>不推荐使用</strong></li>
</ul>
</li>
<li>
<p><strong>重试策略RetryForever，一直在重试</strong></p>
<ul>
<li><code>retryIntervalMs</code>：两次重试之间的间隔时间</li>
<li><strong>不推荐使用</strong></li>
</ul>
</li>
<li>
<p><strong>重试策略RetryUntilElapsed</strong></p>
<ul>
<li><code>maxElapsedTimeMs</code>：最大重试时间，重试时间超过maxElapsedTimeMs后，就不再重试</li>
<li><code>sleepMsBetweenRetries</code>：两次重试之间的间隔时间</li>
<li><strong>推荐使用方式为</strong>：<code>RetryPolicy retryPolicy = new RetryUntilElapsed(2000, 3000);</code></li>
</ul>
</li>
</ol>
<h3 id="2-连接与关闭zookeeper">2. 连接与关闭Zookeeper</h3>
<pre><code class="language-java">//1 重试策略：初试时间为1s 重试10次
RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);
//2 通过工厂创建连接
CuratorFramework client = CuratorFrameworkFactory.builder()
        .connectString(&quot;192.168.1.110:2181&quot;)//连接地址
        .connectionTimeoutMs(3_000)//连接超时时间
        .sessionTimeoutMs(30_000)//会话超时时间
        .retryPolicy(retryPolicy)//重试策略
        .namespace(&quot;super&quot;)//命名空间，连接后所有的操作都是在这个/super节点之下
        .build();
//3 开启连接
client.start();
//4 关闭连接
client.close();
</code></pre>
<h3 id="3-创建节点">3. 创建节点</h3>
<p><strong>creatingParentsIfNeeded是递归创建节点，如果不存在父节点则同时会创建父节点</strong></p>
<p><strong>创建模式有以下几种</strong>:</p>
<ul>
<li><code>CreateMode.PERSISTENT</code>：永久节点</li>
<li><code>CreateMode.PERSISTENT_SEQUENTIAL</code>：永久顺序节点</li>
<li><code>CreateMode.EPHEMERAL</code>：临时节点</li>
<li><code>CreateMode.EPHEMERAL_SEQUENTIAL</code>：临时顺序节点</li>
</ul>
<p><strong>权限控制</strong>：</p>
<ul>
<li>通过withACL，添加一个权限列表List&lt;ACL&gt;</li>
<li>ACL类有两个属性
<ul>
<li>第一个是perms，可以通过Perms的枚举选择，代表了权限字符串列表：crdwa</li>
<li>第二个是Id，代表着五种权限机制，比如说world、digest等</li>
</ul>
</li>
<li>Id类，有两个属性
<ul>
<li>第一个是scheme，代表权限模式</li>
<li>第二个是id，代表权限模式后面的字符串，如digest模式，user:BASE64(SHA1(password))</li>
</ul>
</li>
</ul>
<pre><code class="language-java">List&lt;ACL&gt; acls = new ArrayList&lt;ACL&gt;();
Id demo1 = new Id(&quot;digest&quot;, AclUtils.getDigestUserPwd(&quot;demo1:123456&quot;));
Id demo2 = new Id(&quot;digest&quot;, AclUtils.getDigestUserPwd(&quot;demo2:123456&quot;));
acls.add(new ACL(Perms.ALL, demo1));
acls.add(new ACL(Perms.READ, demo2));
acls.add(new ACL(Perms.DELETE | Perms.CREATE, demo2));
</code></pre>
<p><strong>创建节点举例</strong>：</p>
<pre><code class="language-java">String nodePath = &quot;/super/demo&quot;;
byte[] data = &quot;superme&quot;.getBytes();
// 创建节点
client.create().creatingParentsIfNeeded()
		.withMode(CreateMode.PERSISTENT)//创建模式
		.withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)//权限列表，如果想要将所有递归创建的节点都指定当前的权限，可以多一个参数true，如withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE，true)
		.forPath(nodePath, data);
</code></pre>
<h3 id="4-删除和更新节点">4. 删除和更新节点</h3>
<pre><code class="language-java">String nodePath = &quot;/super/demo&quot;;

// 更新节点数据
byte[] newData = &quot;batman&quot;.getBytes();
client.setData().withVersion(0).forPath(nodePath, newData);

// 删除节点
client.delete()
     .guaranteed()                // 如果删除失败，那么在后端还是继续会删除，直到成功
     .deletingChildrenIfNeeded()  // 如果有子节点，就删除
     .withVersion(0)              // 版本号，如果不匹配会报错
     .forPath(nodePath);		  // 删除的节点地址
</code></pre>
<h3 id="5-查询节点以及子节点">5. 查询节点以及子节点</h3>
<pre><code class="language-java">String nodePath = &quot;/super/demo&quot;;

// 判断节点是否存在,如果不存在则为空
Stat statExist = cto.client.checkExists().forPath(nodePath + &quot;/abc&quot;);
System.out.println(statExist);//statExist!=null，则代表节点存在

// 读取节点数据
Stat stat = new Stat();
byte[] data = client.getData()
        .storingStatIn(stat)//将节点的状态信息也读取进来
        .forPath(nodePath);
System.out.println(&quot;节点&quot; + nodePath + &quot;的数据为: &quot; + new String(data));
System.out.println(&quot;该节点的版本号为: &quot; + stat.getVersion());

 // 查询子节点
 List&lt;String&gt; childNodes = client.getChildren()
         .forPath(nodePath);
 System.out.println(&quot;开始打印子节点：&quot;);
 for (String s : childNodes) {
     System.out.println(s);
 }
</code></pre>
<h3 id="6-创建watcher">6. 创建watcher</h3>
<p><strong>一次性的创建方式</strong>：</p>
<pre><code class="language-java">String nodePath = &quot;/super/demo&quot;;
// 添加watcher 事件  当使用usingWatcher的时候，监听只会触发一次，监听完毕后就销毁
cto.client.getData().usingWatcher((Watcher) event -&gt; {
    System.out.println(&quot;触发了watcher&quot;+event);
}).forPath(nodePath);

cto.client.getData().usingWatcher((CuratorWatcher) event -&gt; {
    System.out.println(&quot;触发了watcher&quot;+event);
}).forPath(nodePath);
</code></pre>
<p><strong>重复使用父节点的watcher</strong>：</p>
<pre><code class="language-java">String nodePath = &quot;/super/demo&quot;;

// NodeCache: 监听数据节点的变更，会触发事件
NodeCache nodeCache = new NodeCache(client, nodePath);

nodeCache.start(true);//buildInitial : 初始化的时候获取node的值并且缓存，true代表进行初始化，缓存节点值，默认为false

if (nodeCache.getCurrentData() != null) {
   System.out.println(&quot;节点初始化数据为：&quot; + new String(nodeCache.getCurrentData().getData()));
} else {
   System.out.println(&quot;节点初始化数据为空...&quot;);
}

//创建监听器，当节点数据发生更改或者创建时，就会触发该方法
nodeCache.getListenable().addListener(() -&gt; {
    //如果是因为删除，导致获取不到节点
    if (nodeCache.getCurrentData() == null) {
        System.out.println(&quot;节点被删除了~&quot;);
        return;
    }
    //获取数据
    String data = new String(nodeCache.getCurrentData().getData());
    //获取触发的节点路径
    String path = nodeCache.getCurrentData().getPath()；
    System.out.println(&quot;节点路径：&quot; + path + &quot;数据：&quot; + data);
});
</code></pre>
<p><strong>重复使用子节点的watcher</strong>：</p>
<pre><code class="language-java">String nodePath = &quot;/super/demo&quot;;

// 为子节点添加watcher
// PathChildrenCache: 监听数据节点的增删改，会触发事件
String childNodePathCache = nodePath;

//新建一个子节点缓存
PathChildrenCache childrenCache = new PathChildrenCache(client, childNodePathCache, true);//cacheData: 设置缓存节点的数据状态，如果为true，也会将子节点的状态信息缓存下来


/**
 * StartMode: 初始化方式
 * POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发初始化事件（推荐）
 * NORMAL：异步初始化
 * BUILD_INITIAL_CACHE：同步初始化
 */
childrenCache.start(StartMode.POST_INITIALIZED_EVENT);

//获取缓存的子节点数据
List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();
System.out.println(&quot;当前数据节点的子节点数据列表：&quot;);
for (ChildData cd : childDataList) {
    String childData = new String(cd.getData());
    System.out.println(childData);
}

//为子节点缓存添加监听器，可以对子节点触发的event的类型进行判断
childrenCache.getListenable().addListener((client, event) -&gt; {
    if (event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) {//初始化事件触发
        System.out.println(&quot;子节点初始化ok...&quot;);
    } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) {//增加子节点
        String path = event.getData().getPath();
        if (path.equals(ADD_PATH)) {
            System.out.println(&quot;添加子节点:&quot; + event.getData().getPath());
            System.out.println(&quot;子节点数据:&quot; + new String(event.getData().getData()));
        } else if (path.equals(&quot;/super/imooc/e&quot;)) {
            System.out.println(&quot;添加不正确...&quot;);
        }
    } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {//删除子节点
        System.out.println(&quot;删除子节点:&quot; + event.getData().getPath());
    } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {//子节点数据修改事件
        System.out.println(&quot;修改子节点路径:&quot; + event.getData().getPath());
        System.out.println(&quot;修改子节点数据:&quot; + new String(event.getData().getData()));
    }
});
</code></pre>
<h2 id="三-watcher统一配置修改">三、watcher统一配置修改</h2>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200921165758514.png" alt="image-20200921165758514" loading="lazy"></figure>
<pre><code class="language-java">public class Client1 {

   public CuratorFramework client = null;
   public static final String zkServerPath = &quot;192.168.1.110:2181&quot;;

   public Client1() {
      RetryPolicy retryPolicy = new RetryNTimes(3, 5000);
      client = CuratorFrameworkFactory.builder()
            .connectString(zkServerPath)
            .sessionTimeoutMs(10000).retryPolicy(retryPolicy)
            .namespace(&quot;workspace&quot;).build();
      client.start();
   }
   
   public void closeZKClient() {
      if (client != null) {
         this.client.close();
      }
   }
   
   public final static String CONFIG_NODE_PATH = &quot;/super/demo&quot;;
   public final static String SUB_PATH = &quot;/redis-config&quot;;
   public static CountDownLatch countDown = new CountDownLatch(1);
   
   public static void main(String[] args) throws Exception {
      //连接Zookeeper
      Client1 cto = new Client1();
      System.out.println(&quot;client1 启动成功...&quot;);
      
       //需要在父节点添加对子节点的监听
      final PathChildrenCache childrenCache = new PathChildrenCache(cto.client, CONFIG_NODE_PATH, true);
      childrenCache.start(StartMode.BUILD_INITIAL_CACHE);
      
      // 添加监听器
      childrenCache.getListenable().addListener(new PathChildrenCacheListener() {
         public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
            // 监听节点变化
            if(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)){
               String configNodePath = event.getData().getPath();
               if (configNodePath.equals(CONFIG_NODE_PATH + SUB_PATH)) {
                  System.out.println(&quot;监听到配置发生变化，节点路径为:&quot; + configNodePath);
                  
                  // 读取节点数据
                  String jsonConfig = new String(event.getData().getData());
                  System.out.println(&quot;节点&quot; + CONFIG_NODE_PATH + &quot;的数据为: &quot; + jsonConfig);
                  
                  // 从json转换配置
                  RedisConfig redisConfig = null;
                  if (StringUtils.isNotBlank(jsonConfig)) {
                     redisConfig = JsonUtils.jsonToPojo(jsonConfig, RedisConfig.class);
                  }
                  
                  // 配置不为空则进行相应操作
                  if (redisConfig != null) {
                     String type = redisConfig.getType();
                     String url = redisConfig.getUrl();
                     String remark = redisConfig.getRemark();
                     // 判断事件
                     if (type.equals(&quot;add&quot;)) {
                        System.out.println(&quot;监听到新增的配置，准备下载...&quot;);
                        // ... 连接ftp服务器，根据url找到相应的配置
                        Thread.sleep(500);
                        System.out.println(&quot;开始下载新的配置文件，下载路径为&lt;&quot; + url + &quot;&gt;&quot;);
                        // ... 下载配置到你指定的目录
                        Thread.sleep(1000);
                        System.out.println(&quot;下载成功，已经添加到项目中&quot;);
                        // ... 拷贝文件到项目目录
                     } else if (type.equals(&quot;update&quot;)) {
                        System.out.println(&quot;监听到更新的配置，准备下载...&quot;);
                        // ... 连接ftp服务器，根据url找到相应的配置
                        Thread.sleep(500);
                        System.out.println(&quot;开始下载配置文件，下载路径为&lt;&quot; + url + &quot;&gt;&quot;);
                        // ... 下载配置到你指定的目录
                        Thread.sleep(1000);
                        System.out.println(&quot;下载成功...&quot;);
                        System.out.println(&quot;删除项目中原配置文件...&quot;);
                        Thread.sleep(100);
                        // ... 删除原文件
                        System.out.println(&quot;拷贝配置文件到项目目录...&quot;);
                        // ... 拷贝文件到项目目录
                     } else if (type.equals(&quot;delete&quot;)) {
                        System.out.println(&quot;监听到需要删除配置&quot;);
                        System.out.println(&quot;删除项目中原配置文件...&quot;);
                     }
                     
                     // TODO 视情况统一重启服务
                  }
               }
            }
         }
      });
      
      countDown.await();
      
      cto.closeZKClient();
   }
   
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速幂之Java实现]]></title>
        <id>https://xzzz2020.github.io/post/-PWIO63oG/</id>
        <link href="https://xzzz2020.github.io/post/-PWIO63oG/">
        </link>
        <updated>2020-09-21T02:38:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>博主针对2021校招字节跳动的第五轮笔试第二，学习了快速幂算法</p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li>
<li><a href="#%E4%BA%8C-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">二、性能优化</a></li>
<li><a href="#%E4%B8%89-%E5%AF%B9%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%A6%A8">三、对性能进行压榨</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<blockquote>
<p>求A^B的最后三位数表示的整数。</p>
<p>说明：A^B的含义是“A的B次方”</p>
</blockquote>
<p><strong>当一个数的幂很大时，如果直接使用Math.pow()运算，会导致溢出，所以最简单的方法就是，累乘B次，每次对结果进行求模运算，我们以2的1000000000次方为例，Java代码如下</strong>：</p>
<pre><code class="language-java">public class Test {
    private static int mod = 1000;

    public static void main(String[] args) {
        int x = 2;
        int n = 1000000000;
        long startTime = System.currentTimeMillis();
        int result = fastPower(x,n);
        System.out.println(&quot;结果是：&quot;+result);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;运行时间为：&quot;+(endTime-startTime)+&quot; ms. &quot;);
    }

    private static int fastPower(int x, int n) {
        int result = 1;
        for (int i = 1; i &lt;= n; i++) {
            result %= mod;
            result *= x;
        }
        return result%mod;
    }
}
</code></pre>
<p>结果：</p>
<pre><code>结果是：376
运行时间为：11127 ms. 
</code></pre>
<p>可以看出，时间复杂度非常高，基本上所有的题目都没有办法AC，所以<strong>需要进一步优化时间复杂度。</strong></p>
<h2 id="二-性能优化">二、性能优化</h2>
<p>对于2的10次方来讲，可以<strong>对其进行拆分</strong>：</p>
<pre><code>2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2
</code></pre>
<p>快速幂算法的核心思想就是**每一步都把指数分成两半，而相应的底数做平方运算。**这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p>
<p>针对上面例子，继续优化：</p>
<pre><code>(2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2)
==》4^5
</code></pre>
<p><strong>此时指数变成了一半，多计算了一次底数平方，少计算5次指数运算。</strong></p>
<p>按照这个思路，可以对所有指数为偶数的不断优化。但是如果指数为奇数呢，比如上面的4^5。</p>
<p>优化的思路就是，将指数减一，凑出偶数，即<strong>抽出了一个底数的一次方</strong>，如下所示：</p>
<pre><code>4^5 = 4^4 * 4^1 
</code></pre>
<p>这样继续对4^4优化为：</p>
<pre><code>4^4 * 4^1 
==》 16^2 *  4^1 
==》 256^1 * 4^1
==》 1024
</code></pre>
<p><strong>相比于10次的累乘运算，优化到了5次，优化后的Java代码如下。</strong></p>
<pre><code class="language-java">public class Test {
    private static int mod = 1000;

    public static void main(String[] args) {
        int x = 2;
        int n = 1000000000;
        long startTime = System.currentTimeMillis();
        int result = fastPower(x, n);
        System.out.println(&quot;结果是：&quot; + result);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;运行时间为：&quot; + (endTime - startTime) + &quot; ms. &quot;);
    }

    private static int fastPower(int x, int n) {
        int result = 1;
        while (n &gt; 0) {
            if (n % 2 == 1) {
                n -= 1;
                result *= x;
                result %= mod;
            } else {
                n /= 2;
                x *= x;
                x %= mod;
            }
        }
        return result % mod;
    }
}
</code></pre>
<p><strong>结果</strong>：</p>
<pre><code>结果是：376
运行时间为：0 ms.
</code></pre>
<h2 id="三-对性能进行压榨">三、对性能进行压榨</h2>
<p><strong>上述代码结构依然有优化的空间</strong>：</p>
<ol>
<li>n % 2 == 1可以使用&amp;运算符优化，变成(n &amp; 1) == 1</li>
<li>n /= 2可以使用位运算符优化，变成n = n &gt;&gt; 1</li>
</ol>
<p><strong>优化后的代码如下</strong>：</p>
<pre><code class="language-java">public class Test {
    private static int mod = 1000;

    public static void main(String[] args) {
        int x = 2;
        int n = 1000000000;
        long startTime = System.currentTimeMillis();
        int result = fastPower(x, n);
        System.out.println(&quot;结果是：&quot; + result);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;运行时间为：&quot; + (endTime - startTime) + &quot; ms. &quot;);
    }

    private static int fastPower(int x, int n) {
        int result = 1;
        while (n &gt; 0) {
            if ((n &amp; 1) == 1) {
                n -= 1;
                result *= x;
                result %= mod;
            }
            n = n &gt;&gt; 1;
            x *= x;
            x %= mod;
        }
        return result % mod;
    }
}
</code></pre>
<p><strong>结果</strong>：</p>
<pre><code>结果是：376
运行时间为：0 ms.
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】SpringMVC源码分析]]></title>
        <id>https://xzzz2020.github.io/post/hfCflPZX4/</id>
        <link href="https://xzzz2020.github.io/post/hfCflPZX4/">
        </link>
        <updated>2020-09-10T12:17:52.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90">一、配置文件分析</a>
<ul>
<li><a href="#1-xml%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90">1. XML配置分析</a></li>
<li><a href="#2-mvc%E9%85%8D%E7%BD%AE">2. MVC配置</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%85%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">二、入口方法分析</a>
<ul>
<li><a href="#1-%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96">1. 容器初始化</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90controller">2. 解析Controller</a></li>
<li><a href="#3-spring%E5%AF%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81">3. Spring对注解的配置支持</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-springmvc%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B">三、SpringMVC的核心流程</a>
<ul>
<li><a href="#1-%E5%85%B3%E9%94%AE%E6%B5%81%E7%A8%8B">1. 关键流程</a></li>
<li><a href="#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">2. 核心组件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-配置文件分析">一、配置文件分析</h2>
<h3 id="1-xml配置分析">1. XML配置分析</h3>
<p><strong>在一个SSM项目中，需要在xml文件配置SpingMVC的相关组件</strong></p>
<ol>
<li><strong>DispatcherServlet</strong>：做请求分发以及结果渲染</li>
<li><strong>ContextLoaderListener</strong>：配置监听器，在创建Servlet前，加载SpringMVC的配置</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;!-- 配置加载类路径的配置文件 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- 配置监听器 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="2-mvc配置">2. MVC配置</h3>
<ol>
<li>配置了视图解析器<strong>viewResolver</strong>，提供了视图解析的目录以及后缀</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/mvc
           http://www.springframework.org/schema/mvc/spring-mvc.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/aop
      http://www.springframework.org/schema/aop/spring-aop.xsd
           &quot;&gt;

    &lt;!-- 扫描controller的注解，别的不扫描 --&gt;
    &lt;context:component-scan base-package=&quot;cn.xzzz2020.ssm.controller&quot;&gt;
    &lt;/context:component-scan&gt;

    &lt;!-- 配置视图解析器 --&gt;
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;!-- JSP文件所在的目录 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
        &lt;!-- 文件的后缀名 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 开启对SpringMVC注解的支持 --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--
        支持AOP的注解支持，AOP底层使用代理技术
        JDK动态代理，要求必须有接口
        cglib代理，生成子类对象，proxy-target-class=&quot;true&quot; 默认使用cglib的方式
    --&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="二-入口方法分析">二、入口方法分析</h2>
<h3 id="1-容器初始化">1. 容器初始化</h3>
<blockquote>
<p>第一个需要关注的是ContextLoaderListener</p>
</blockquote>
<ol>
<li>
<p>这个类实现了ServletContextListener接口，本质上是Servlet的监听器</p>
</li>
<li>
<p>Tomcat会优先加载Servlet的监听器，以保证在Servlet初始化时，调用初始化方法contextInitialized</p>
</li>
<li>
<p>接着读取并解析容器的配置，创建并刷新出容器的实例来</p>
</li>
</ol>
<pre><code class="language-java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener {

   /**
    * Initialize the root web application context.
    */
   @Override
   public void contextInitialized(ServletContextEvent event) {
      initWebApplicationContext(event.getServletContext());
   }
}
</code></pre>
<h3 id="2-解析controller">2. 解析Controller</h3>
<ol>
<li>配置前端控制器，这样在容器初始化后，就会解析Controller的@RequestMapping注解</li>
<li>根据注解，建立请求方法和Controller的映射</li>
</ol>
<pre><code class="language-xml">&lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<h3 id="3-spring对注解的配置支持">3. Spring对注解的配置支持</h3>
<p><strong>配置SpringMVC</strong></p>
<pre><code class="language-java">public class StartWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
	/**
	 * SpringContext中相关的bean
	 *
	 * @return
	 */
	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class&lt;?&gt;[]{SpringRootConfig.class};
	}
	/**
	 * DispatcherServlet中上下文相关的Bean
	 *
	 * @return
	 */
	@Override
	protected Class&lt;?&gt;[] getServletConfigClasses() {
		return new Class&lt;?&gt;[]{MVCConfig.class};
	}
	/**
	 * Servlet请求映射路径
	 *
	 * @return
	 */
	@Override
	protected String[] getServletMappings(){
		return new String[]{&quot;/&quot;};
	}
	/**
	 * 拦截并处理请求的编码
	 *
	 * @return
	 */
	@Override
	protected Filter[] getServletFilters() {
		CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
		encodingFilter.setEncoding(&quot;UTF-8&quot;);
		encodingFilter.setForceEncoding(true);
		return new Filter[]{encodingFilter};
	}
}
</code></pre>
<p><strong>设置需要扫描的核心包路径</strong></p>
<pre><code class="language-java">/**
 * SpringContext中相关的bean
 *
 * @return
 */
@Configuration
@ComponentScan(&quot;com.imooc.service&quot;)
public class SpringRootConfig {
}
</code></pre>
<p><strong>配置需要扫描的Controller路径</strong></p>
<pre><code class="language-java">/**
 * DispatcherServlet中上下文相关的Bean
 *
 * @return
 */
@Configuration
@ComponentScan(&quot;com.imooc.controller&quot;)
@EnableWebMvc
public class MVCConfig {
    //内部资源视图解析器
	@Bean
	public InternalResourceViewResolver viewResolver(){
		InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver();
		internalResourceViewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
		internalResourceViewResolver.setSuffix(&quot;.jsp&quot;);
		return internalResourceViewResolver;
	}
}
</code></pre>
<h2 id="三-springmvc的核心流程">三、SpringMVC的核心流程</h2>
<blockquote>
<p>主要流程与自定义SpringMVC思路一样，可以参考文章：</p>
</blockquote>
<h3 id="1-关键流程">1. 关键流程</h3>
<ol>
<li>建立请求和Controller方法的映射集合的流程</li>
<li>根据请求查找对应的Controller方法的流程</li>
<li>请求参数绑定到方法的形参</li>
<li>执行方法处理请求</li>
<li>渲染视图</li>
</ol>
<h3 id="2-核心组件">2. 核心组件</h3>
<figure data-type="image" tabindex="1"><img src="https://img-service.csdnimg.cn/img_convert/b550b1f740d71acd5fb649e2af8ad1aa.png" alt="img" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】SpringIOC源码分析]]></title>
        <id>https://xzzz2020.github.io/post/3wLQd4LMj/</id>
        <link href="https://xzzz2020.github.io/post/3wLQd4LMj/">
        </link>
        <updated>2020-09-10T12:16:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li>
<li><a href="#%E4%BA%8C-ioc%E5%AE%B9%E5%99%A8">二、IOC容器</a>
<ul>
<li><a href="#1-%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3beanfactory">1. 简单容器接口BeanFactory</a></li>
<li><a href="#2-listablebeanfactory%E6%8E%A5%E5%8F%A3">2. ListableBeanFactory接口</a></li>
<li><a href="#3-autowirecapablebeanfactory%E6%8E%A5%E5%8F%A3">3. AutowireCapableBeanFactory接口</a></li>
<li><a href="#4-defaultlistablebeanfactory%E7%B1%BB">4. DefaultListableBeanFactory类</a></li>
<li><a href="#5-%E9%AB%98%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3applicationcontext">5. 高级容器接口ApplicationContext</a></li>
<li><a href="#6-configurableapplicationcontext%E6%8E%A5%E5%8F%A3">6. ConfigurableApplicationContext接口</a></li>
<li><a href="#7-abstractapplicationcontext">7. AbstractApplicationContext</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96">三、容器初始化</a>
<ul>
<li><a href="#1-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8post-processor">1. 后置处理器post processor</a></li>
<li><a href="#2-aware%E6%8E%A5%E5%8F%A3">2. Aware接口</a></li>
<li><a href="#3-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%80%85%E6%A8%A1%E5%BC%8F">3. 事件监听者模式</a></li>
<li><a href="#4-%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E9%80%BB%E8%BE%91">4. 容器刷新逻辑</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%AE%B9%E5%99%A8%E8%8E%B7%E5%8F%96bean">四、容器获取Bean</a>
<ul>
<li><a href="#1-getbean">1. getBean</a></li>
<li><a href="#2-%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98">2. 单例的三级缓存</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">3. 如何判断是否是循环依赖？</a></li>
<li><a href="#4-dogetbean%E6%BA%90%E4%BB%A3%E7%A0%81">4. doGetBean源代码</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean">六、容器创建Bean</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">1. 创建前的准备</a></li>
<li><a href="#2-docreatbean">2. doCreatBean</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">3. 如何解决循环依赖</a></li>
<li><a href="#4-spring%E9%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">4. Spring都会出现哪些情况的循环依赖？</a></li>
<li><a href="#%E6%BA%90%E7%A0%81">源码</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%AE%B9%E5%99%A8%E7%9A%84bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">七、容器的Bean依赖注入</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<p><strong>SpringIOC解决的问题</strong>：将对象之间的关系使用配置或者注解管理</p>
<p><strong>Bean是Spring的一等公民</strong>：</p>
<ul>
<li>
<p>Bean的本质就是Java对象，只是这个对象的生命周期由容器管理，只需要告诉Spring它需要管理哪些对象</p>
</li>
<li>
<p>不需要为了创建Bean而在原来的Java类上添加任意的限制，体现了代码的低侵入</p>
</li>
<li>
<p>对Java对象的配置体现在配置文件或者注解上</p>
</li>
</ul>
<p><strong>BeanDefinition</strong></p>
<ul>
<li>
<p>在Java中曾经使用的Class对象来描述，在Spring中描述Bean的定义</p>
</li>
<li>
<p><strong>主要配置额外属性：</strong></p>
<ul>
<li>
<p><strong>作用范围scope（@Scope）</strong>，有五个，最重要的是singleton和prototype</p>
</li>
<li>
<p><strong>懒加载lazi-init（@Lazy）</strong>：决定Bean是否延迟加载，如果为true，则只有在使用的时候才会创建</p>
</li>
<li>
<p><strong>首选primary（@Primary）</strong>：如果存在一个接口对应多个实现，设置为true的Bean会被优先装配</p>
</li>
<li>
<p><strong>工厂类Beanfactory-bean（@Configuration）和工厂方法Beanfactory-method（@Bean）</strong>：指示出Bean在哪个类的什么方法创建</p>
</li>
</ul>
</li>
</ul>
<p><strong>Spring中Bean的继承关系是通过parent属性定义</strong></p>
<h2 id="二-ioc容器">二、IOC容器</h2>
<h3 id="1-简单容器接口beanfactory">1. 简单容器接口BeanFactory</h3>
<p><strong>BeanFactory接口的核心方法：</strong></p>
<ul>
<li><strong>getBean</strong>：可以通过Bean的名字或者Class对象获取Bean的实例</li>
<li><strong>isSingleton和isPrototype</strong>：判断是否是单例</li>
<li><strong>getType</strong>：根据名字获取Class对象</li>
<li><strong>getAliases</strong>：根据Bean的名字获取它的别名数组</li>
</ul>
<p><strong>BeanFactory和FactoryBean的区别？</strong></p>
<ul>
<li>
<p>BeanFactory是Spring IoC容器的实际代表者，IoC容器负责容纳此前所描述的bean，并对bean进行管理。</p>
</li>
<li>
<p>在Spring中，BeanFactory是IoC容器的核心接口。它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
</li>
<li>
<p>Spring为我们提供了许多易用的BeanFactory实现，XmlBeanFactory就是最常用的一个。该实现将以XML方式描述组成应用的对象以及对象间的依赖关系。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。</p>
</li>
<li>
<p>当一个受Spring容器管理的bean 如果实现了FactoryBean接口 在bean实例化(getBean)阶段 Spring会调用该bean的getObejct方法返回的不一定是自身的实例，对bean的生产修饰做了很好的封装。</p>
</li>
<li>
<p>如果想要获取FactoryBean的实现类，在名字前面加“&amp;”</p>
</li>
</ul>
<p><strong>FactoryBean举例</strong></p>
<pre><code class="language-java">@Component
public class UserFactoryBean implements FactoryBean&lt;User&gt; {
   @Override
   public User getObject() throws Exception {
      return new User();
   }

   @Override
   public Class&lt;?&gt; getObjectType() {
      return User.class;
   }
} 

 public static void main(String[] args) {
     ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Entrance.class);
     Object bean = applicationContext.getBean(&quot;&amp;factory&quot;);
     System.out.println(bean);
     Object bean2 = applicationContext.getBean(&quot;factory&quot;);
     System.out.println(bean2);
 }
</code></pre>
<p><strong>output：</strong></p>
<pre><code>com.imooc.entity.factory.factory@3bbc39f8
com.imooc.entity.User@4ae3c1cd
</code></pre>
<h3 id="2-listablebeanfactory接口">2. ListableBeanFactory接口</h3>
<ul>
<li>
<p>负责批量列举容器Bean的信息</p>
<p><strong>核心方法</strong>：</p>
</li>
<li>
<p>getBeanDefinitionNames()：可以列出IOC容器的加载的Bean的名字</p>
</li>
<li>
<p>getBeanDefinitionCount()：获取容器中Bean的数目</p>
</li>
</ul>
<h3 id="3-autowirecapablebeanfactory接口">3. AutowireCapableBeanFactory接口</h3>
<ul>
<li>负责自动依赖注入</li>
</ul>
<p><strong>自动装配策略有</strong>：</p>
<ul>
<li>根据名称</li>
<li>根据类型</li>
<li>根据构造函数</li>
<li>不自动装配</li>
</ul>
<blockquote>
<p>比如@Autowire方法调用的就是resolveDependency()实现的自动注入，使用的是根据类型进行依赖注入，@Resource和@Qualifier按名称匹配注入Bean</p>
</blockquote>
<h3 id="4-defaultlistablebeanfactory类">4. DefaultListableBeanFactory类</h3>
<ul>
<li>第一个具备IOC容器的实现类</li>
<li>提供了beanDefinitionMap负责记录Bean的定义</li>
</ul>
<pre><code class="language-java">	/** Map of bean definition objects, keyed by bean name. */
	//记录Bean的注册信息
	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<h3 id="5-高级容器接口applicationcontext">5. 高级容器接口ApplicationContext</h3>
<p><strong>继承了多个接口，提供了丰富的功能</strong>：</p>
<ul>
<li>EnvironmentCapable：提供加载多个配置文件的能力</li>
<li>ListableBeanFactory：通过列表的方式管理Bean</li>
<li>HierarchicalBeanFactory：支持多层级的容器，提供对每一个层级Bean的管理</li>
<li>ResourcePatternResolver：可以用于加载资源文件</li>
<li>ApplicationEventPublisher：具备事件发布的能力</li>
</ul>
<p><strong>基于传统XML配置的实现类：</strong></p>
<ul>
<li>**FileSystemXmlApplicationContext：**从文件系统加载并定义相关资源</li>
<li>**ClassPathXmlApplicationContext：**从classpath加载配置</li>
<li>**XmlWebApplicationContext：**用于Web应用程序</li>
</ul>
<p><strong>流行的根据注解的实现类</strong></p>
<ul>
<li>
<p>**AnnotationConfigApplicationContext：**负责非Web应用</p>
</li>
<li>
<p>**AnnotationConfigServletWebServerApplicationContext：**负责Web的应用</p>
</li>
<li>
<p>**AnnotationConfigReactiveWebServerApplicationContext：**额外满足响应式的需求</p>
</li>
</ul>
<h3 id="6-configurableapplicationcontext接口">6. ConfigurableApplicationContext接口</h3>
<ul>
<li>是ApplicationContext的子接口</li>
<li>继承了Lifecycle接口，提供控制IOC容器生命周期的方法</li>
<li>提供了refresh方法，初始化容器，也可以重新启动容器</li>
</ul>
<h3 id="7-abstractapplicationcontext">7. AbstractApplicationContext</h3>
<p><strong>是一个模板方法的一个体现</strong></p>
<ul>
<li><strong>refresh</strong>，属于模板方法，定义了容器初始化的算法骨架</li>
<li><strong>prepareRefresh</strong>，是一个具体的方法，由这个抽象类本身实现</li>
<li><strong>postProcessBeanFactory</strong>是一个钩子方法，子类可以根据情况选择是否实现</li>
<li><strong>refreshBeanFactory</strong>是一个抽象方法，强制子类实现</li>
</ul>
<h2 id="三-容器初始化">三、容器初始化</h2>
<blockquote>
<p>主要处理逻辑是AbstractApplicationContext的Refresh()方法，这是个模板方法，定义了容器初始化的算法，应用了模板设计模式，所以这个类也是个抽象类。</p>
</blockquote>
<h3 id="1-后置处理器post-processor">1. 后置处理器post processor</h3>
<p><strong>有三种后置处理器</strong>：</p>
<ul>
<li>
<p>BeanDefinition后置处理器，继承了BeanFactory后置处理器，用于处理BeanDefinition，也可以处理容器</p>
</li>
<li>
<p>BeanFactory后置处理器，用于处理容器</p>
</li>
<li>
<p>Bean的后置处理器，用于处理Bean</p>
</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>本身也是需要注册到容器中的Bean</li>
<li>定义一些方法，这些方法会在特定的时机被容器所调用</li>
<li>实现不改变容器或者Bean核心逻辑的情况下对容器或者Bean进行扩展</li>
<li>比如对一些方法进行包装，修改内容等</li>
</ul>
<p><strong>BeanDefinitionPostProcessor举例</strong></p>
<ul>
<li>Mybatis就会搜索第三方Jar包中的Class，将其注入到IOC容器中</li>
</ul>
<p><strong>BeanPostProcessor举例</strong></p>
<ul>
<li>有两个方法分别负责Bean初始化前做什么事情，初始化后做什么事情，但是需要定义一个过滤规则，对不同的bean进行过滤</li>
</ul>
<h3 id="2-aware接口">2. Aware接口</h3>
<ul>
<li>bean实现xxxAware接口可以感知到容器</li>
<li>可以获取容器BeanFactory（低级容器）、ApplicationContext（高级容器）、BeanName（bean的名字）、ResourceLoader（资源加载器）</li>
</ul>
<h3 id="3-事件监听者模式">3. 事件监听者模式</h3>
<p><strong>Spring中的事件驱动模型</strong></p>
<ul>
<li><strong>事件</strong>：ApplicationEvent抽象类是Spring中所有事件的父类，比如对于容器事件定义了一个ApplicationContextEvent子类，该子类有几个子类，比如容器关闭后的事件、容器启动时的事件、容器初始化完成后的事件</li>
<li><strong>事件监听器</strong>：ApplicationListener接口，该接口的两个子接口都有两个方法，判断当前事件源以及事件是否是该监听器感兴趣的，开发者可以继承父接口或者在某个Bean方法上使用注解@EventListener</li>
<li><strong>事件发布器</strong>：ApplicationEventPublisher以及ApplicationEventMulticaster接口。ApplicationEventPublisher提供事件发布的能力，ApplicationContext实现了该接口，也就是说高级的IOC容器具备发布事件的能力，可以在bean实现对应的Aware接口，获取容器的发布器。ApplicationEventMulticaster提供了注册和删除监听器的能力，利用Set集合保存监听器，默认的子实现类在定义了Executor，也就是可以通过多线程使用异步的方式调用注册好的监听器</li>
</ul>
<p><strong>详情见：</strong></p>
<h3 id="4-容器刷新逻辑">4. 容器刷新逻辑</h3>
<ol>
<li>
<p><strong>调用prepareRefresh()：负责做刷新前的准备工作</strong></p>
<ul>
<li>设置刷新时间</li>
<li>设置容器的状态为激活</li>
<li>创建事件集合</li>
</ul>
</li>
<li>
<p><strong>obtainFreshBeanFactory()：获取容器刷新后的BeanFactory实例，会进行BeanDefinition的注册</strong></p>
</li>
<li>
<p><strong>prepareBeanFactory(beanFactory)：为容器注册一些系统级别的Bean</strong></p>
</li>
</ol>
<ul>
<li>
<p>设置表达式语言处理器、资源加载器、事件发布器</p>
</li>
<li>
<p>设置动态装配规则</p>
</li>
<li>
<p>判断是否需要织入器，使用Bean级别的后置处理器进行AOP操作</p>
</li>
<li>
<p>添加后置处理器将容器传递给实现ApplicationContextAware接口的Bean、如果某个 bean实现了Aware接口，将在自动装配的时候忽略它们</p>
</li>
</ul>
<ol start="4">
<li>
<p><strong>postProcessBeanFactory(beanFactory)：注册容器级别的后置处理器</strong></p>
</li>
<li>
<p><strong>invokeBeanFactoryPostProcessors(beanFactory)：调用容器级别的后置处理器</strong></p>
</li>
<li>
<p><strong>registerBeanPostProcessors(beanFactory)：注册Bean级别的后置处理器，在类初始化前和初始化后进行一些处理</strong></p>
</li>
<li>
<p><strong>initMessageSource()：初始化国际化的配置</strong></p>
</li>
<li>
<p><strong>initApplicationEventMulticaster()：初始化事件发布者组件，支持事件的发布和注册</strong></p>
</li>
<li>
<p><strong>onRefresh()：提供提前初始化一些特殊的Bean</strong></p>
</li>
<li>
<p><strong>registerListeners()：注册事件监听器</strong></p>
</li>
<li>
<p><strong>finishBeanFactoryInitialization(beanFactory)：主要实例化所有不是懒加载的实例</strong></p>
<ul>
<li>
<p>解析相关配置文件的值，如@Value注解</p>
</li>
<li>
<p>进行类编译器的AOP织入操作</p>
</li>
<li>
<p>先实例化所有不是懒加载的实例，通过BeanDefinition判断Bean是否是抽象的、单例的和懒加载的</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>AOP分为三种方式：编译期织入、类加载期织入和运行期织入</p>
</blockquote>
<ol start="12">
<li>
<p><strong>finishRefresh()：触发初始化完成的回调方法，发布容器刷新完成的事件给监听者</strong></p>
</li>
<li>
<p><strong>resetCommonCaches()：重启共用缓存</strong></p>
</li>
</ol>
<p><strong>refresh源码</strong></p>
<pre><code class="language-java">	/**
	 * 加载或刷新一个持久化的配置，可能是XML文件、属性文件或关系数据库模式。
	 * 由于这是一种启动方法，如果失败，应该销毁已经创建的单例，以避免悬空资源。
	 * 换句话说，在调用该方法之后，要么全部实例化，要么完全不实例化。
	 * @throws 如果bean工厂无法初始化，则抛出 BeansException 异常
	 * @throws 如果已经初始化且不支持多次刷新，则会抛出 IllegalStateException 异常
	 */
	@Override
	public void refresh() throws BeansException, IllegalStateException {
		// 给容器refresh加锁，避免容器处在refresh阶段时，容器进行了初始化或者销毁的操作
		synchronized (this.startupShutdownMonitor) {
			// 调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识，具体方法
			prepareRefresh();

			//告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从
			//子类的refreshBeanFactory()方法启动，里面有抽象方法
			//针对xml配置，最终创建内部容器，该容器负责 Bean 的创建与管理，此步会进行BeanDefinition的注册
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// 注册一些容器中需要的系统Bean.例如classloader，beanfactoryPostProcessor等
			prepareBeanFactory(beanFactory);

			try {
				//允许容器的子类去注册postProcessor  ，钩子方法
				postProcessBeanFactory(beanFactory);

				// 激活在容器中注册为bean的BeanFactoryPostProcessors
				//对于注解容器，org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
				//方法扫描应用中所有BeanDefinition并注册到容器之中
				invokeBeanFactoryPostProcessors(beanFactory);

				// 注册拦截bean创建过程的BeanPostProcessor
				registerBeanPostProcessors(beanFactory);

				// 找到“messageSource”的Bean提供给ApplicationContext使用，
				// 使得ApplicationContext具有国际化能力。
				initMessageSource();

				// 初始化ApplicationEventMulticaster该类作为事件发布者，
				// 可以存储所有事件监听者信息，并根据不同的事件，通知不同的事件监听者。
				initApplicationEventMulticaster();

				// 预留给 AbstractApplicationContext 的子类用于初始化其他特殊的 bean，
				// 该方法需要在所有单例 bean 初始化之前调用
				// 比如Web容器就会去初始化一些和主题展示相关的Bean（ThemeSource）
				onRefresh();

				// 注册监听器（检查监听器的bean并注册它们）
				registerListeners();

				//设置自定义的类型转化器ConversionService，
				// 设置自定义AOP相关的类LoadTimeWeaverAware，
				// 清除临时的ClassLoader
				// ，实例化所有的类（懒加载的类除外）
				finishBeanFactoryInitialization(beanFactory);

				// 初始化容器的生命周期事件处理器，（默认使用DefaultLifecycleProcessor），调用扩展了SmartLifecycle接口的start方法
				// 当Spring容器加载所有bean并完成初始化之后，会接着回调实现该接口的类中对应的方法（start()方法）
				// 并发布容器刷新完毕事件ContextRefreshedEvent给对应的事件监听者
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				//销毁已创建的Bean
				destroyBeans();

				// Reset 'active' flag.
				//取消refresh操作，重置容器的同步标识
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// 重置Spring内核中的共用的缓存，因为我们可能再也不需要单例bean的元数据了……
				resetCommonCaches();
			}
		}
	}
</code></pre>
<h2 id="四-容器获取bean">四、容器获取Bean</h2>
<blockquote>
<p>主要了解的是@Autowired注解的，使用类型的注入方式。</p>
</blockquote>
<p><strong>方法递归调用顺序</strong>：</p>
<ol>
<li>getBean()</li>
<li>dogetBean()</li>
<li>getSingleton()：从缓存中获取</li>
<li>createBeanInstance()：创建未赋值的Bean实例</li>
<li>addSingletonFactory()：为了防止循环引用，将对象引用放入三级缓存</li>
<li>populateBean：进行依赖注入</li>
</ol>
<h3 id="1-getbean">1. getBean</h3>
<blockquote>
<p>是AbstractAutowireCapableBeanFactory的getBean方法，真正工作的是doGetBean方法</p>
</blockquote>
<p><strong>核心逻辑</strong>：</p>
<ol>
<li>将GetBean方法传入的名字进行处理，比如是不是用&amp;符号打头，以及尝试从别名集合中获取真正的名字，可能会出现获取到的依然是别名，所以就会递归查询，直到查询不出别名</li>
<li>根据Bean的名字，尝试从缓存中获取单例Bean实例，可能是单例Bean或者FactoryBean本身，如果存在Bean实例直接返回，或者存在FactoryBean，会调用getObject方法返回Bean实例</li>
<li>循环依赖判断，就是A中存在属性B，B中存在属性A，就出现了循环的依赖问题，即A的创建依赖于B的创建，B的创建依赖于A的创建</li>
<li>递归去父容器获取BeanDefinition实例，最后会合并子类和父类的BeanDefinition，防止出现BeanDefinition过期的情况</li>
<li>递归实例化显示依赖的Bean，如果A中的depends-on属性指向B，则B要先被实例化，依赖关系会注册到Set中，保存了A依赖哪些以及哪些依赖A。如果人为定义的属性出现循环依赖，则会直接出现异常，因为Spring框架，认为这个创建顺序是必须要严格遵守的</li>
<li>根据不同的Scope采用不同的策略创建Bean，最后放入到一级缓存中，并将二级三级缓存清除，并且注册在Bean创建成功列表</li>
<li>对Bean进行类型检查</li>
</ol>
<p><strong>FactoryBean和ObjectBean的区别？</strong></p>
<ul>
<li>
<p>ObjectBean功能和FactoryBean类似，但是为了区别用户自定义的和框架自己使用的，采用了两套名字</p>
</li>
<li>
<p>框架使用ObjectBean接口的不同实现类，会产生不同Scope的实例对象</p>
</li>
</ul>
<h3 id="2-单例的三级缓存">2. 单例的三级缓存</h3>
<ul>
<li>先从<strong>singletonObjects这个一级缓存</strong>获取，主要包含最终形态的Bean实例</li>
<li>如果一级缓存没有获取到，就会给一级缓存加锁，<strong>从二级缓存获取，也就是earlySingletonObjects</strong>，因为前面已经加锁，所以二级缓存以及三级缓存都是采用的HashMap来提升性能，二级缓存是早期的bean实例，还没有给属性赋值</li>
<li>如果二级缓存没有获取到，就会<strong>从三级缓存获取，也就是singletonFactorys</strong>中获取，这里面存储的是ObjectBean，类似于FactoryBean。如果此时获取到，就会调用getObject方法，存入二级缓存，然后删除三级缓存，防止重复创建</li>
</ul>
<h3 id="3-如何判断是否是循环依赖">3. 如何判断是否是循环依赖？</h3>
<ol>
<li>
<p>创建一个Bean时，就会记录在一个列表中，单例模式会记录在Set集合中，而原型模式会记录在一个ThreadLocal中，确保一个线程创建一个</p>
</li>
<li>
<p>如果A依赖B，就会先创建B，B此时依赖A，就会再创建A，发现A正在被创建，就认为有循环依赖，防止doGetBean递归调用</p>
</li>
<li>
<p>支持单例模式的循环依赖</p>
</li>
<li>
<p>对原型模式，如果判断到循环依赖，就会抛出异常，是不支持的</p>
</li>
</ol>
<p><strong>源码：</strong></p>
<pre><code class="language-java">	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		//尝试从一级缓存里面获取完备的Bean
		Object singletonObject = this.singletonObjects.get(beanName);
		//如果完备的单例还没有创建出来，创建中的Bean的名字会被保存在singletonsCurrentlyInCreation中
		//因此看看是否正在创建
		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
			//尝试给一级缓存对象加锁，因为接下来就要对缓存对象操作了
			synchronized (this.singletonObjects) {
				//尝试从二级缓存earlySingletonObjects这个存储还没进行属性添加操作的Bean实例缓存中获取
				singletonObject = this.earlySingletonObjects.get(beanName);
				//如果还没有获取到并且第二个参数为true，为true则表示bean允许被循环引用
				if (singletonObject == null &amp;&amp; allowEarlyReference) {
					//从三级缓存singletonFactories这个ObjectFactory实例的缓存里尝试获取创建此Bean的单例工厂实例
					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
					//如果获取到工厂实例
					if (singletonFactory != null) {
						//调用单例工厂的getObject方法返回对象实例
						singletonObject = singletonFactory.getObject();
						//将实例放入二级缓存里
						this.earlySingletonObjects.put(beanName, singletonObject);
						//从三级缓存里移除
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
</code></pre>
<h3 id="4-dogetbean源代码">4. doGetBean源代码</h3>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
		//通过三种形式获取beanName
		// 一个是原始的beanName，一个是加了&amp;的，一个是别名
		final String beanName = transformedBeanName(name);
		Object bean;
		// 尝试从单例缓存集合里获取bean实例
		Object sharedInstance = getSingleton(beanName);
		//如果先前已经创建过单例Bean的实例，并且调用的getBean方法传入的参数为空
		//则执行if里面的逻辑
		//args之所以要求为空是因为如果有args，则需要做进一步赋值，因此无法直接返回
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isTraceEnabled()) {
				//如果Bean还在创建中，则说明是循环引用
				if (isSingletonCurrentlyInCreation(beanName)) {
                //...
                }
			}
			// 如果是普通bean，直接返回，如果是FactoryBean，则返回他的getObject
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}
		//若scope为prototype或者单例模式但是缓存中还不存在bean
		else {
			//如果scope为prototype并且显示还在创建中，则基本是循环依赖的情况
			//针对prototype的循环依赖，spring无解，直接抛出异常
			// A-&gt;B-&gt;A
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// 从当前容器中找不到指定名称的bean,此时递归去parentFactory查找
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				// 主要针对FactoryBean，将Bean的&amp;重新加上
				String nameToLookup = originalBeanName(name);
				//如果parent容器依旧是AbstractBeanFactory的实例
				//instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					//直接递归调用方法来查找
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				//....
			}
			//typeCheckOnly 是用来判断调用 getBean() 是否仅仅是为了类型检查获取 bean，而不是为了创建Bean
			if (!typeCheckOnly) {
				// 如果不是仅仅做类型检查则是创建bean
				markBeanAsCreated(beanName);
			}

			try {
				//将父类的BeanDefinition与子类的BeanDefinition进行合并覆盖
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				//对合并的BeanDefinition做验证，主要看属性是否为abstract的
				checkMergedBeanDefinition(mbd, beanName, args);
				// 获取当前Bean所有依赖Bean的名称
				String[] dependsOn = mbd.getDependsOn();
				// 如果当前Bean设置了dependsOn的属性
				//depends-on用来指定Bean初始化及销毁时的顺序
				//&lt;bean id=a Class=&quot;com.imooc.A&quot; depends-on=&quot;b&quot; /&gt;
				// &lt;bean id=b Class=&quot;com.imooc.B&quot; /&gt;
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						//校验该依赖是否已经注册给当前 bean,注意这里传入的key是当前的bean名称
						//这里主要是判断是否有以下这种类型的依赖：
						//&lt;bean id=&quot;beanA&quot; class=&quot;BeanA&quot; depends-on=&quot;beanB&quot;&gt;
						//&lt;bean id=&quot;beanB&quot; class=&quot;BeanB&quot; depends-on=&quot;beanA&quot;&gt;
						//如果有，则直接抛出异常
						if (isDependent(beanName, dep)) {
							//...
						}
						//缓存依赖调用，注意这里传入的key是被依赖的bean名称
						registerDependentBean(dep, beanName);
						//递归调用getBean方法，注册Bean之间的依赖（如C需要晚于B初始化，而B需要晚于A初始化
						// 初始化依赖的bean
						getBean(dep);

					}
				}

				//如果BeanDefinition为单例
				if (mbd.isSingleton()) {
					//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象
					sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// 显式从单例缓存中删除 bean 实例
							// 因为单例模式下为了解决循环依赖，可能它已经存在了，所以将其销毁
							destroySingleton(beanName);
							throw ex;
						}
					});
					// 如果是普通bean，直接返回，是FactoryBean，返回他的getObject
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					//Prototype每次都会创建一个新的对象
					Object prototypeInstance = null;
					//默认的功能是注册当前创建的prototype对象为正在创建中
					beforePrototypeCreation(beanName);
					//创建原型对象实例
					prototypeInstance = createBean(beanName, mbd, args);
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				//要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中
				//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中
				//比较常用，如：request、session、application等生命周期
						
		}

		//对创建的Bean实例对象进行类型检查
		if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
			//....
		}
		return (T) bean;
	}
</code></pre>
<h2 id="六-容器创建bean">六、容器创建Bean</h2>
<blockquote>
<p>这个是doGetBean方法里面的CreatBean</p>
</blockquote>
<h3 id="1-创建前的准备">1. 创建前的准备</h3>
<blockquote>
<p>AbstractAutowireCapableBeanFactory类的createBean方法</p>
</blockquote>
<ol>
<li>Bean类型的解析，主要是解析获取Class对象</li>
<li>处理方法覆盖，比如说lookup-method属性以及replaced-method属性指定的Bean中是否有这些方法，以及是否出现方法的重载，否则还需要对方法进行处理</li>
<li>做Bean实例化前的后置处理</li>
<li>最后调用doCreatBean方法进行创建</li>
</ol>
<p><strong>源码：</strong></p>
<pre><code class="language-java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
		//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载
		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
			//克隆一份BeanDefinition，用来设置上加载出来的class对象
			//之所以后续用该副本操作，是因为不希望将解析的class绑定到缓存里的BeanDefinition
			//因为class有可能是每次都需要动态解析出来的
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		//校验和准备Bean中的方法覆盖
		mbdToUse.prepareMethodOverrides();
		//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象
		//resolveBeforeInstantiation只是针对有自定义的targetsource，
		// 因为自定义的targetsource不是spring的bean那么肯定不需要进行后续的一系列的实例化,初始化。
		// 所以可以在resolveBeforeInstantiation直接进行proxy
		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		if (bean != null) {
			return bean;
		}
		//创建Bean的入口
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
	}
</code></pre>
<h3 id="2-docreatbean">2. doCreatBean</h3>
<ol>
<li>
<p>通过工厂方法比如说factory-method方法，或者使用无参构造器注入以及含参构造器注入最终创建一个无属性的Bean实例，在这一步会判断是否需要利用CGLIB替换方法</p>
</li>
<li>
<p>执行Bean实例化后的后置处理器，其中包含记录被@Autowired或者@Value方法标记的属性或者方法实例，便于后续的依赖处理，但是这个标记不会标记JDK自带的类，防止对JDK底层源码进行更改；也无法标记静态属性和方法</p>
</li>
<li>
<p>会创建BeanFactory注册到三级缓存中，并清空了二级缓存</p>
</li>
<li>
<p>判断是否Bean允许提前暴露，需要满足单例、支持循环依赖、以及正在被创建三个条件，这个Bean还没有填充属性，从BeanFactory获取实例，清除三级缓存，并放入二级缓存</p>
</li>
<li>
<p>填充Bean属性，执行populateBean方法</p>
</li>
<li>
<p>对Bean进行初始化操作，先判断是否实现了Aware接口，让用户感知到Bean创建，然后在执行初始化方法，最后执行Bean初始化完成的后置处理器</p>
</li>
<li>
<p>注册相关销毁逻辑</p>
</li>
<li>
<p>返回创建好的Bean</p>
</li>
</ol>
<p><strong>先注册在三级缓存，再从三级缓存取出实例化的原因？</strong></p>
<p><strong>源码：</strong></p>
<pre><code class="language-java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {
		// Instantiate the bean.
		//bean实例包装类
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			//从未完成创建的包装Bean缓存中清理并获取相关中的包装Bean实例，毕竟是单例的，只能存一份
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			//创建bean的时候，这里创建bean的实例有三种方法
			//1.工厂方法创建
			//2.构造方法的方式注入
			//3.无参构造方法注入
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		//获取被包装的Bean，后续对bean的改动相当于对Wrapper的改动，反之依然
		final Object bean = instanceWrapper.getWrappedInstance();
		//获取实例化对象的类型
		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}
		//调用BeanDefinition属性合并完成后的BeanPostProcessor后置处理器
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				//被@Autowired、@Value标记的属性在这里获取
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
 				mbd.postProcessed = true;
			}
		}
		//向容器中缓存单例模式的Bean对象，以防循环引用
		//判断是否是早期引用的bean，如果是，则允许其提前暴露引用
		//这里判断的逻辑主要有三个：
		//1.是否为单例
		//2.是否允许循环引用
		//3.是否是在创建中的bean
		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
						&quot;' to allow for resolving potential circular references&quot;);
			}
			//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用
			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
		}


		//Bean对象的初始化，依赖注入在此触发
		//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean
		Object exposedObject = bean;
		//填充bean实例的属性
		populateBean(beanName, mbd, instanceWrapper);
		//初始化bean，过程如下：
		//1：判断是否实现了BeanNameAware，BeanClassLoaderAware，
		//   BeanFactoryAware方法，如果有，则设置相关的属性
		//2: 调用bean初始化的前置（BeanPostProcessor）操作
		//3: 执行初始化的方法。
		//	如果有initializingBean，则调用afterPropertiesSet
		//	如果有InitMethod，则调用初始方法
		//4: 调用bean初始化的后置（BeanPostProcessor）操作
		exposedObject = initializeBean(beanName, exposedObject, mbd);
		//若允许循环依赖，则解决相关的循环依赖
		if (earlySingletonExposure) {
			//获取指定名称的已注册的单例模式Bean对象
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				//如果经过initializeBean执行后返回的bean还是同一个（不是代理对象实例,即没有被增强）
				if (exposedObject == bean) {
					// 确保根据名称获取到的的已注册的Bean和正在实例化的Bean是同一个
					exposedObject = earlySingletonReference;
				}
				//如果上面的if没通过，则表明引用的bean和注入的bean不一致，则需要看看依赖于此Bean的先前是否已经注入了不完善的Bean
				// allowRawInjectionDespiteWrapping 标注是否允许此Bean的原始类型被注入到其它Bean里面，
				// 即使自己最终会被包装（代理）
				// dependentBeanMap记录着每个依赖于此Bean的Bean实例集合
				//当发生循环引用时不允许新创建实例对象
				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
					//获取依赖于当前Bean的Bean实例
					for (String dependentBean : dependentBeans) {
						//移除掉只是用来进行类型检查的单例Bean
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					/**
					 * 因为bean创建后其所依赖的bean一定是已经创建的
					 * actualDependentBeans不为空则表示当前bean创建后其依赖的bean却没有全部创建完，也就是说存在循环依赖
					 */
					if (!actualDependentBeans.isEmpty()) {
						//....
					}
				}
			}
		}
		//注册Bean的销毁逻辑
		registerDisposableBeanIfNecessary(beanName, bean, mbd);
		return exposedObject;
	}
</code></pre>
<h3 id="3-如何解决循环依赖">3. 如何解决循环依赖</h3>
<blockquote>
<p>如果A依赖B，B依赖A</p>
</blockquote>
<ol>
<li>假设A先开始创建，会进行doCreateBean的处理，生成一个没有任何属性的实例</li>
<li>将A实例对应的ObjectFactory放入三级缓存，此时只有三级缓存保存了实例</li>
<li>对A进行属性赋值，此时会尝试获取实例B，由于还没有创建，就会递归进入doCreateBean创建实例B</li>
<li>将B实例对用的ObjectFactory放入三级缓存，此时三级缓存保存了A和B实例</li>
<li>对B实例进行赋值时，会调用getBean方法尝试从三级缓存中获取A实例，此时就可以获取到A的实例，并完成赋值</li>
<li>获取到A实例后，就会将该实例放入二级缓存，并清除三级缓存</li>
<li>方法返回A的属性赋值，将完整的B实例注册到A实例的属性中</li>
<li>两个实例放入一级缓存，清空其他的缓存</li>
</ol>
<h3 id="4-spring都会出现哪些情况的循环依赖">4. Spring都会出现哪些情况的循环依赖？</h3>
<ol>
<li>构造器循环依赖</li>
<li>Setter注入循环依赖</li>
</ol>
<p><strong>构造器循环依赖</strong></p>
<pre><code class="language-java">@Repository
public class Company {
	private Staff staff;
	@Autowired
	public Company(Staff staff){
		this.staff = staff;
	}
}

@Repository
public class Staff {
	private Company company;
	@Autowired
	public Staff(Company company){
		this.company = company;
	}
}

</code></pre>
<p><strong>Setter注入循环依赖</strong></p>
<pre><code class="language-java">@Repository
public class BoyFriend {
	@Autowired
	private GirlFriend girlFriend;
}

@Repository
public class GirlFriend {
	@Autowired
	private BoyFriend boyFriend;
}

</code></pre>
<ul>
<li>
<p><strong>不支持原型模式的循环依赖的</strong>：没有提供了三级缓存的机制支持，只能通过Bean名字放入缓存中阻断三级缓存</p>
</li>
<li>
<p><strong>对于构造器单例循环依赖问题</strong>：因为创建无属性Bean的时候，构造器依赖其他Bean，无法放入第三级缓存中，就会出现循环的调用</p>
</li>
</ul>
<h3 id="源码">源码</h3>
<pre><code class="language-java">	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
		//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载
		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
			//克隆一份BeanDefinition，用来设置上加载出来的class对象
			//之所以后续用该副本操作，是因为不希望将解析的class绑定到缓存里的BeanDefinition
			//因为class有可能是每次都需要动态解析出来的
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		//校验和准备Bean中的方法覆盖
		mbdToUse.prepareMethodOverrides();
		//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象
		//resolveBeforeInstantiation只是针对有自定义的targetsource，
		// 因为自定义的targetsource不是spring的bean那么肯定不需要进行后续的一系列的实例化,初始化。
		// 所以可以在resolveBeforeInstantiation直接进行proxy
		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		if (bean != null) {
			return bean;
		}
		//创建Bean的入口
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
	}
</code></pre>
<h2 id="七-容器的bean依赖注入">七、容器的Bean依赖注入</h2>
<blockquote>
<p>这个是doCreatBean方法里面的populateBean方法</p>
</blockquote>
<p><strong>处理逻辑</strong></p>
<ol>
<li>如果注册了后置处理器，要在设置属性前去修改Bean状态，也可以控制是否继续给Bean设置属性值，这时用户已经赋值了</li>
<li>针对XML配置，如果配置了是按名字装配或者按照类型，则先保存这个配置</li>
<li>调用后置处理器，对没有经过第二步处理的属性进行处理，比如说通过注解注入的，尝试从容器的缓存中获取，而且@Autowire并非非得按照类型来查找，在根据类型没有找到时，会尝试使用类型的名字按照名字装配或者按照别名装配</li>
<li>注解装配完成后，就会注入XML方式配置的</li>
<li>注入的Bean实例并非直接反射创建，而是还是要通过getBean方法从三级缓存获取或者创建一个新的，注入的方式还是通过反射设置</li>
</ol>
<p><strong>源码</strong></p>
<pre><code class="language-java">	protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
		// 给InstantiationAwareBeanPostProcessors最后一次机会在属性注入前修改Bean的属性值，也可以控制是否继续填充Bean
		// 具体通过调用postProcessAfterInstantiation方法，如果调用返回false,表示不必继续进行依赖注入，直接返回
		// 主要是让用户可以自定义属性注入。比如用户实现一个 InstantiationAwareBeanPostProcessor 类型的后置处理器，
		// 并通过 postProcessAfterInstantiation 方法向 bean 的成员变量注入自定义的信息。
		boolean continueWithPropertyPopulation = true;
		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						continueWithPropertyPopulation = false;
						break;
					}
				}
			}
		}
		//如果上面设置 continueWithPropertyPopulation = false，表明用户可能已经自己填充了
		// bean 的属性，不需要 Spring 帮忙填充了。此时直接返回即可
		if (!continueWithPropertyPopulation) {
			return;
		}
		// pvs是一个MutablePropertyValues实例，里面实现了PropertyValues接口，
		// 提供属性的读写操作实现，同时可以通过调用构造函数实现深拷贝
		//获取BeanDefinition里面为Bean设置上的属性值
		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
		// 根据Bean配置的依赖注入方式完成注入，默认是0，即不走以下逻辑，所有的依赖注入都需要在xml文件中有显式的配置
		// 如果设置了相关的依赖装配方式，会遍历Bean中的属性，根据类型或名称来完成相应注入，无需额外配置
		int resolvedAutowireMode = mbd.getResolvedAutowireMode();
		if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

			// 根据beanName进行autowiring自动装配处理
			// 	&lt;bean id=&quot;boyFriend&quot; class=&quot;com.imooc.dao.impl.BoyFriend&quot;  autowire=&quot;byName&quot;&gt;&lt;/bean&gt;
			if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);
			}

			//根据Bean的类型进行autowiring自动装配处理
			//	&lt;bean id=&quot;boyFriend&quot; class=&quot;com.imooc.dao.impl.BoyFriend&quot;  autowire=&quot;byType&quot;&gt;&lt;/bean&gt;
			if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);
			}
			pvs = newPvs;
		}
		// 容器是否注册了InstantiationAwareBeanPostProcessor
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		// 是否进行依赖检查，默认为false
		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

		PropertyDescriptor[] filteredPds = null;
		if (hasInstAwareBpps) {
			if (pvs == null) {
				pvs = mbd.getPropertyValues();
			}
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					//在这里会对@Autowired标记的属性进行依赖注入
					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
					if (pvsToUse == null) {
						if (filteredPds == null) {
							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
						}
						// 对解析完但未设置的属性再进行处理
						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvsToUse == null) {
							return;
						}
					}
					pvs = pvsToUse;
				}
			}
		}
		// 依赖检查，对应depend-on属性，3.0已经弃用此属性
		if (needsDepCheck) {
			// 过滤出所有需要进行依赖检查的属性编辑器
			if (filteredPds == null) {
				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			}
			checkDependencies(beanName, mbd, filteredPds, pvs);
		}

		if (pvs != null) {
			//最终将属性注入到Bean的Wrapper实例里，这里的注入主要是供
			//显式配置了autowiredbyName或者ByType的属性注入，
			//针对注解来讲，由于在AutowiredAnnotationBeanPostProcessor已经完成了注入，
			//所以此处不执行
			applyPropertyValues(beanName, mbd, bw, pvs);
		}
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】SpringAOP源码分析]]></title>
        <id>https://xzzz2020.github.io/post/JG9MpEbxa/</id>
        <link href="https://xzzz2020.github.io/post/JG9MpEbxa/">
        </link>
        <updated>2020-09-10T12:14:40.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-springaop%E7%9A%84%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B">一、SpringAOP的总体流程</a></li>
<li><a href="#%E4%BA%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E4%B8%8Aenableaspectjautoproxy%E5%B0%B1%E8%83%BD%E6%94%AF%E6%8C%81aop">二、为什么在启动类加上@EnableAspectJAutoProxy就能支持AOP</a>
<ul>
<li><a href="#%E4%B8%89-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90aop%E7%9A%84%E6%9C%8D%E5%8A%A1">三、如何注册解析AOP的服务？</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E5%8A%A0%E8%BD%BD%E5%88%86%E6%9E%90">四、横切逻辑加载分析</a>
<ul>
<li><a href="#1-targetsource%E6%8E%A5%E5%8F%A3">1. TargetSource接口</a></li>
<li><a href="#2-buildaspectjadvisors%E6%96%B9%E6%B3%95">2. buildAspectJAdvisors方法</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E7%BB%87%E5%85%A5">五、横切逻辑织入</a>
<ul>
<li><a href="#1-%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E7%9A%84%E7%BB%87%E5%85%A5%E6%96%B9%E6%B3%95%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%89%E4%B8%A4%E4%B8%AA">1. 横切逻辑的织入方法提供的有两个</a></li>
<li><a href="#2-%E6%B5%81%E7%A8%8B">2. 流程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-springaop的总体流程">一、SpringAOP的总体流程</h2>
<ul>
<li>注册解析AOP的服务</li>
<li>解析和加载横切逻辑</li>
<li>将横切逻辑织入目标Bean中</li>
</ul>
<h2 id="二-为什么在启动类加上enableaspectjautoproxy就能支持aop">二、为什么在启动类加上@EnableAspectJAutoProxy就能支持AOP</h2>
<p>注解有两个属性</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
   boolean proxyTargetClass() default false;   
   boolean exposeProxy() default false;
}
</code></pre>
<p><strong>proxyTargetClass</strong></p>
<ul>
<li>如果为true，则将全部使用CGLIb进行代理；如果为false，则会尽可能使用JDK的动态代理，如果对象没有实现接口，将会使用CGLIb</li>
</ul>
<p><strong>exposeProxy</strong></p>
<ul>
<li>
<p>决定是否可以将动态代理对象暴露出来</p>
</li>
<li>
<p>如果设置为true将会放入AopContext类的ThreadLocal属性中的中，这样就可以通过容器获取到该动态代理的对象</p>
</li>
</ul>
<p><strong>SpringAOP的流程</strong></p>
<ol>
<li>注册解析AOP的服务</li>
<li>解析和加载横切逻辑</li>
<li>将横切逻辑织入目标Bean中</li>
</ol>
<h3 id="三-如何注册解析aop的服务">三、如何注册解析AOP的服务？</h3>
<ul>
<li>主要依靠@Import(AspectJAutoProxyRegistrar.class)注解</li>
</ul>
<pre><code class="language-java">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

   
   @Override
   public void registerBeanDefinitions(
         AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
       //往容器注册一个AOP基于注解的自动代理创建器，负责动态代理的创建
      AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
		//注册注解的两个信息
      AnnotationAttributes enableAspectJAutoProxy =
            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
      if (enableAspectJAutoProxy != null) {
         if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
         }
         if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
         }
      }
   }

}
</code></pre>
<blockquote>
<p><strong>registerBeanDefinitions()方法有两个参数：</strong></p>
<ul>
<li>AnnotationMetadata：保存注解相关的信息</li>
<li>BeanDefinitionRegistry：往容器注册BeanDefinition</li>
</ul>
</blockquote>
<p><strong>该方法做的事情：</strong></p>
<ol>
<li>往容器注册一个AOP基于注解的自动代理创建器，负责动态代理的创建</li>
<li>根据注解属性，注册的相关配置</li>
</ol>
<p><strong>什么时候将配置注册到容器中？</strong></p>
<ul>
<li>在容器初始化执行Refresh方法的时候，通过容器级别的后置处理器注册的</li>
</ul>
<h2 id="四-横切逻辑加载分析">四、横切逻辑加载分析</h2>
<h3 id="1-targetsource接口">1. TargetSource接口</h3>
<ul>
<li>实现该接口，可以实现池化的操作，将存取代理类或者替换代理类</li>
</ul>
<p><strong>SingletonTargetSource</strong>：确保被代理的实例是单例的，定义了一个final的Object类，确保每次调用的都是同一个实例</p>
<pre><code class="language-java">private final Object target;
@Override
public Class&lt;?&gt; getTargetClass() {
	return this.target.getClass();
}
</code></pre>
<p><strong>ProtoTypeTargetSource</strong>：确保被代理的实例是多例的，每次调用时都会返回一个新的实例</p>
<pre><code class="language-java">@Override
public Object getTarget() throws BeansException {
   return newPrototypeInstance();
}
</code></pre>
<p><strong>其他的还有</strong></p>
<ul>
<li>提供池化的CommonsPool2TargetSource，类似于线程池</li>
<li>提供热交换的HotSwappableTargetSource，可以增删改查代理实例</li>
</ul>
<h3 id="2-buildaspectjadvisors方法">2. buildAspectJAdvisors方法</h3>
<ol>
<li>从容器中获取所有的beanName</li>
<li>遍历所有的beanName，解析出被@Aspect注解标记的类</li>
<li>提取Aspect类中的Advisors</li>
<li>将结果放入缓存</li>
</ol>
<pre><code class="language-java">public List&lt;Advisor&gt; buildAspectJAdvisors() {
	List&lt;String&gt; aspectNames = this.aspectBeanNames;

	if (aspectNames == null) {
		synchronized (this) {
			aspectNames = this.aspectBeanNames;
			if (aspectNames == null) {
				List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();
				//用于保存切面的名称的集合
				aspectNames = new ArrayList&lt;&gt;();
				//获取所有的beanName
				// AOP功能中在这里传入的是Object对象，代表去容器中获取到所有的组件的名称，然后再
				// 进行遍历，这个过程是十分的消耗性能的，所以说Spring会再这里加入了保存切面信息的缓存。
				String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
						this.beanFactory, Object.class, true, false);
				//遍历我们从IOC容器中获取处的所有Bean的名称
				for (String beanName : beanNames) {
					if (!isEligibleBean(beanName)) {
						continue;
					}
					//获取对应的bean的类型
					Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);
					if (beanType == null) {
						continue;
					}
					//提取@Aspect注解标记的Class
					if (this.advisorFactory.isAspect(beanType)) {
						//是切面类
						//加入到缓存中
						aspectNames.add(beanName);
						AspectMetadata amd = new AspectMetadata(beanType, beanName);
						if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
							MetadataAwareAspectInstanceFactory factory =
									new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
							//Aspect里面的advice和pointcut被拆分成一个个的advisor，
							// advisor里的advice和pointcut是1对1的关系
							List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
							if (this.beanFactory.isSingleton(beanName)) {
								//单例则直接将Advisor类存到缓存
								this.advisorsCache.put(beanName, classAdvisors);
							}
							else {
								// 否则将其对应的工厂缓存
								this.aspectFactoryCache.put(beanName, factory);
							}
							advisors.addAll(classAdvisors);
						}
						else {
							// Per target or per this.
							if (this.beanFactory.isSingleton(beanName)) {
								throw new IllegalArgumentException(&quot;Bean with name '&quot; + beanName +
										&quot;' is a singleton, but aspect instantiation model is not singleton&quot;);
							}
							MetadataAwareAspectInstanceFactory factory =
									new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
							this.aspectFactoryCache.put(beanName, factory);
							advisors.addAll(this.advisorFactory.getAdvisors(factory));
						}
					}
				}
				this.aspectBeanNames = aspectNames;
				return advisors;
			}
		}
	}

	if (aspectNames.isEmpty()) {
		return Collections.emptyList();
	}
	List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();
	for (String aspectName : aspectNames) {
		List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);
		if (cachedAdvisors != null) {
			advisors.addAll(cachedAdvisors);
		}
		else {
			MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
			advisors.addAll(this.advisorFactory.getAdvisors(factory));
		}
	}
	return advisors;
}
</code></pre>
<h2 id="五-横切逻辑织入">五、横切逻辑织入</h2>
<blockquote>
<p>在Bean完成初始化后，利用责任链模式进行横切逻辑的织入。</p>
</blockquote>
<h3 id="1-横切逻辑的织入方法提供的有两个">1. 横切逻辑的织入方法提供的有两个</h3>
<ul>
<li>第一个是正常流程的织入入口，通过后置处理器实现</li>
<li>第二个是循环依赖的织入入口，通过获取EarlyBeanReference实现</li>
</ul>
<h3 id="2-流程">2. 流程</h3>
<ul>
<li>
<p><strong>横切逻辑的织入前会进行一系列的判断</strong></p>
<ul>
<li>被织入的类名称不能是空</li>
<li>判断该类是否需要跳过织入或者是基础的类，比如实现了Advice、Pointcut等接口</li>
</ul>
</li>
<li>
<p><strong>获取合适的切面，利用AspectJ框架，进行类级别的初筛和方法级别的精确筛选，这些切面在容器创建的时候已经完成解析</strong></p>
<ul>
<li>初筛只能校验within的表达式，对于execution，只能检验精确到某个类的，表达式使用的包名加类名</li>
</ul>
</li>
<li>
<p><strong>创建Bean对应的代理，默认使用SingletonTargetSource用于封装实现类的信息，根据Bean是否实现了接口来决定使用JDK动态代理或者CGLib</strong></p>
</li>
<li>
<p><strong>将生成的动态代理，放入缓存中</strong></p>
</li>
</ul>
<pre><code class="language-java">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
		//已经被处理过
		if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) {
			return bean;
		}
		//不需要被织入逻辑的
		if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
			return bean;
		}
		//是不是基础的bean 是不是需要跳过的
		if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
			this.advisedBeans.put(cacheKey, Boolean.FALSE);
			return bean;
		}


		// 返回匹配当前Bean的所有Advice\Advisor\Interceptor
		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
		if (specificInterceptors != DO_NOT_PROXY) {
			this.advisedBeans.put(cacheKey, Boolean.TRUE);
			//创建Bean对应的代理，SingletonTargetSource用于封装实现类的信息
			Object proxy = createProxy(
					bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
			this.proxyTypes.put(cacheKey, proxy.getClass());
			return proxy;
		}
		//该Bean是不需要进行代理的，下次就不需要重复生成了
		this.advisedBeans.put(cacheKey, Boolean.FALSE);
		return bean;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】自定义SpringMVC]]></title>
        <id>https://xzzz2020.github.io/post/aAuoQMUUV/</id>
        <link href="https://xzzz2020.github.io/post/aAuoQMUUV/">
        </link>
        <updated>2020-09-10T12:13:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a>
<ul>
<li><a href="#1-springmvc%E7%9A%84%E5%BC%95%E5%87%BA">1. SpringMVC的引出</a></li>
<li><a href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89mvc%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD">2. 自定义MVC提供的功能</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%BB%BA%E7%AB%8B%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%99%A8">二、建立请求转发器</a>
<ul>
<li><a href="#1-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA">1. 请求的拦截</a></li>
<li><a href="#2-%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82">2. 责任链处理请求</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%99%A8">三、请求处理器</a>
<ul>
<li><a href="#1-%E8%AF%B7%E6%B1%82%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">1. 请求预处理器</a></li>
<li><a href="#2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E5%99%A8">2. 静态资源处理器</a></li>
<li><a href="#3-jsp%E5%A4%84%E7%90%86%E5%99%A8">3. JSP处理器</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-controller%E5%A4%84%E7%90%86%E5%99%A8">四、Controller处理器</a>
<ul>
<li><a href="#1-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E5%92%8C%E9%85%8D%E7%BD%AE%E7%B1%BB">1. 相关注解和配置类</a></li>
<li><a href="#2-controllerrequestprocessor">2. ControllerRequestProcessor</a></li>
<li><a href="#3-%E5%BB%BA%E7%AB%8Bcontroller%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">3. 建立Controller方法与请求的映射关系</a></li>
<li><a href="#4-%E7%BB%99%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC">4. 给需要执行的方法参数赋值</a></li>
<li><a href="#5-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E6%89%A7%E8%A1%8C%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C">5. 利用反射执行获取执行的结果</a></li>
<li><a href="#6-%E6%A0%B9%E6%8D%AE%E7%BB%93%E6%9E%9C%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">6. 根据结果设置结果渲染器</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">五、处理结果渲染器</a>
<ul>
<li><a href="#1-%E9%BB%98%E8%AE%A4%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">1. 默认结果渲染器</a></li>
<li><a href="#2-%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">2. 异常结果渲染器</a></li>
<li><a href="#3-%E6%89%BE%E4%B8%8D%E5%88%B0%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93%E5%99%A8">3. 找不到路径渲染器</a></li>
<li><a href="#4-json%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">4. Json结果渲染器</a></li>
<li><a href="#5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">5. 视图解析器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<h3 id="1-springmvc的引出">1. SpringMVC的引出</h3>
<ul>
<li>
<p>最开始都是用的Servlet</p>
</li>
<li>
<p>如果一个Servlet对应一个类，比如说商品类，但是如果我们除了需要查询产品还查询了订单，就需要访问两个Servlet</p>
</li>
<li>
<p>如果一个Servlet对应一个页面，比如说商品页，随着页面的增多，Servlet也会越来越多，同时如果一个页面有多个get请求，将无法处理</p>
</li>
</ul>
<p><strong>参照SpringMVC，仅通过DispatcherServlet进行请求派发这样可以让系统模块更加明确，该类的任务有</strong>：</p>
<ul>
<li>拦截全部请求</li>
<li>解析请求</li>
<li>派发给对应的Controller里面进行处理</li>
</ul>
<p><strong>通过下面的注解可以拦截到全部请求</strong></p>
<pre><code class="language-java">@WebServlet(&quot;/&quot;)
</code></pre>
<p><strong>下面的会对jsp请求也会进行拦截，如果我们在页面中转发到jsp，就会依然被拦截到这个类里</strong></p>
<pre><code class="language-java">@WebServlet(&quot;/*&quot;)
</code></pre>
<p>原因在tomcat的web.xml中，反斜杠是Servlet中特殊的匹配模式，优先级最低，比*.jsp优先级低，但是反斜杠星号属于路径匹配，优先级比*.jsp高</p>
<pre><code class="language-xml">&lt;!-- The mapping for the default servlet --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;default&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

 &lt;!-- The mappings for the JSP servlet --&gt;    
 &lt;servlet-mapping&gt;                                      
     &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;          
     &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;              
     &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;            
 &lt;/servlet-mapping&gt;                                     
</code></pre>
<h3 id="2-自定义mvc提供的功能">2. 自定义MVC提供的功能</h3>
<ul>
<li>
<p>对所有的请求结果进行转发，利用责任链模式处理对应的请求</p>
</li>
<li>
<p>进行编码相关的预处理</p>
</li>
<li>
<p>支持<strong>静态资源、JSP以及Controller</strong>的请求处理，<strong>需要被转发的Controller需要在类和方法上都加入@RequestMapping注解，目前只提供Get和Post两种请求方法</strong></p>
</li>
<li>
<p>提供<strong>基本类型</strong>的参数转换，将请求的参数赋值在方法上，但是<strong>要求每个参数都需要加上@RequestParam注解</strong></p>
</li>
<li>
<p><strong>如果方法上有@ResponseBody注解，将提供Json的视图渲染</strong></p>
</li>
<li>
<p><strong>如果方法上没有提供@ResponseBody注解，将提供ModelAndView的页面渲染，返回值可以是ModelAndView，或者String类型，渲染到JSP页面</strong></p>
</li>
</ul>
<h2 id="二-建立请求转发器">二、建立请求转发器</h2>
<h3 id="1-请求的拦截">1. 请求的拦截</h3>
<p><strong>建立DispatcherServlet</strong></p>
<ul>
<li>初始化容器</li>
<li>初始化请求处理器责任链</li>
<li>通过责任链模式来依次调用请求处理器对请求进行处理</li>
<li>对处理结果进行渲染</li>
</ul>
<pre><code class="language-java">/**
 * 1.完成框架的初始化
 * 2.对请求进行分发
 * 3.对结果进行渲染
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:05
 */
@WebServlet(&quot;/*&quot;)
public class DispatcherServlet extends HttpServlet {
    //处理器列表
    private List&lt;RequestProcessor&gt; Processor = new ArrayList&lt;&gt;();

    @Override
    public void init(){
        //1.初始化容器
        BeanContainer beanContainer = BeanContainer.getInstance();
        beanContainer.loadBeans(&quot;com.imooc&quot;);
        new AspectWeaver().doAop();
        new DependencyInjector().doIoc();
        //2.初始化请求处理器责任链
        Processor.add(new PreRequestProcessor());
        Processor.add(new StaticResourceRequestProcessor(getServletContext()));
        Processor.add(new JspRequestProcessor(getServletContext()));
        Processor.add(new ControllerRequestProcessor());
    }
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) {
        //1.创建责任链对象实例
        RequestProcessorChain requestProcessorChain = new RequestProcessorChain(Processor.iterator(), req, resp);
        //2.通过责任链模式来依次调用请求处理器对请求进行处理
        requestProcessorChain.doRequestProcessorChain();
        //3.对处理结果进行渲染
        requestProcessorChain.doRender();
    }
}
</code></pre>
<h3 id="2-责任链处理请求">2. 责任链处理请求</h3>
<pre><code class="language-java">/**
 * 责任链处理实例
 * 1.以责任链的模式执行注册的请求处理器
 * 2.委派给特定的Render实例对处理的结果进行渲染
 *
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:05
 */
@Data
@Slf4j
public class RequestProcessorChain {

    //请求处理器迭代器
    private final Iterator&lt;RequestProcessor&gt; requestProcessorIterator;
    //请求Request
    private final HttpServletRequest request;
    //请求Response
    private final HttpServletResponse response;
    //http请求方法
    private String requestMethod;
    //http请求路径
    private String requestPath;
    //请求状态码
    private int responseCode;
    //请求结果渲染器
    private ResultRender resultRender;

    public RequestProcessorChain(Iterator&lt;RequestProcessor&gt; requestProcessorIterator, HttpServletRequest req, HttpServletResponse resp) {
        this.requestProcessorIterator = requestProcessorIterator;
        this.request = req;
        this.response = resp;
        this.requestMethod = req.getMethod();
        this.requestPath = req.getPathInfo();
        this.responseCode = HttpServletResponse.SC_OK;
    }

    /**
     * 以责任链的模式处理请求
     */
    public void doRequestProcessorChain() {
        //1.通过迭代器遍历注册的请求处理器实现类列表
        try {
            while (requestProcessorIterator.hasNext()) {
                //2.直到某个请求处理器执行后返回为false为止
                RequestProcessor requestProcessor = requestProcessorIterator.next();
                boolean processStatue = requestProcessor.process(this);
                if (!processStatue) {
                    break;
                }
            }
        } catch (Exception e) {
            //3.期间如果出现异常，则交由内部异常渲染器处理
            this.resultRender = new InternalErrorResultRender();
            log.error(&quot;doRequestProcessorChain error:&quot;, e);
        }

    }

    /**
     * 结果渲染器
     */
    public void doRender() {
        //1.如果请求处理器实现类均未选择合适的渲染器，则使用默认的
        if (this.resultRender == null) {
            this.resultRender = new DefaultResultRender();
        }
        try {
            //2.调用渲染器的render方法对结果进行渲染
            resultRender.render(this);
        } catch (Exception e) {
            log.error(&quot;doRender error:&quot;, e);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<h2 id="三-请求处理器">三、请求处理器</h2>
<blockquote>
<p>采用责任链模式，如果没有被当前处理器处理，则交给下一个处理器处理，直到有处理器处理成功</p>
</blockquote>
<h3 id="1-请求预处理器">1. 请求预处理器</h3>
<pre><code class="language-java">/**
 * 请求预处理，包括进行统一的UTF-8编码以及路径处理
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:06
 */
@Slf4j
public class PreRequestProcessor implements RequestProcessor {
    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        // 1.设置请求编码，将其统一设置成UTF-8
        requestProcessorChain.getRequest().setCharacterEncoding(&quot;UTF-8&quot;);
        // 2.将请求路径末尾的/剔除，为后续匹配Controller请求路径做准备
        // （一般Controller的处理路径是/aaa/bbb，所以如果传入的路径结尾是/aaa/bbb/，
        // 就需要处理成/aaa/bbb）
        String requestPath = requestProcessorChain.getRequestPath();
        //http://localhost:8080/simpleframework requestPath=&quot;/&quot;
        if(requestPath.length() &gt; 1 &amp;&amp; requestPath.endsWith(&quot;/&quot;)){
            requestProcessorChain.setRequestPath(requestPath.substring(0, requestPath.length() - 1));
        }
        log.info(&quot;preprocess request {} {}&quot;, requestProcessorChain.getRequestMethod(), requestProcessorChain.getRequestPath());
        return true;
    }
}
</code></pre>
<h3 id="2-静态资源处理器">2. 静态资源处理器</h3>
<blockquote>
<p>利用的tomcat默认请求派发器RequestDispatcher处理</p>
</blockquote>
<pre><code class="language-java">/**
 * 静态资源请求的处理，包括但不限于图片、css、以及js文件等
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:08
 */
@Slf4j
public class StaticResourceRequestProcessor implements RequestProcessor {
    public static final String DEFAULT_TOMCAT_SERVLET = &quot;default&quot;;
    public static final String STATIC_RESOURCE_PREFIX = &quot;/static/&quot;;
    //tomcat默认请求派发器RequestDispatcher的名称
    RequestDispatcher defaultDispatcher;

    public StaticResourceRequestProcessor(ServletContext servletContext) {
        this.defaultDispatcher = servletContext.getNamedDispatcher(DEFAULT_TOMCAT_SERVLET);
        if(this.defaultDispatcher == null){
            throw new RuntimeException(&quot;There is no default tomcat servlet&quot;);
        }
        log.info(&quot;The default servlet for static resource is {}&quot;, DEFAULT_TOMCAT_SERVLET);
    }

    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        //1.通过请求路径判断是否是请求的静态资源 webapp/static
        if(isStaticResource(requestProcessorChain.getRequestPath())){
            //2.如果是静态资源，则将请求转发给default servlet处理
            defaultDispatcher.forward(requestProcessorChain.getRequest(), requestProcessorChain.getResponse());
            return false;
        }
        return true;
    }
    //通过请求路径前缀（目录）是否为静态资源 /static/
    private boolean isStaticResource(String path){
        return path.startsWith(STATIC_RESOURCE_PREFIX);
    }
}
</code></pre>
<h3 id="3-jsp处理器">3. JSP处理器</h3>
<blockquote>
<p>利用的tomcat的jspServlet处理</p>
</blockquote>
<pre><code class="language-java">/**
 * jsp资源请求处理
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:08
 */
public class JspRequestProcessor implements RequestProcessor {

    //jsp请求的RequestDispatcher的名称
    private static final String JSP_SERVLET = &quot;jsp&quot;;
    //Jsp请求资源路径前缀
    private static final String  JSP_RESOURCE_PREFIX = &quot;/templates/&quot;;

    /**
     * jsp的RequestDispatcher,处理jsp资源
     */
    private RequestDispatcher jspServlet;

    public JspRequestProcessor(ServletContext servletContext) {
        jspServlet = servletContext.getNamedDispatcher(JSP_SERVLET);
        if (null == jspServlet) {
            throw new RuntimeException(&quot;there is no jsp servlet&quot;);
        }
    }

    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        if (isJspResource(requestProcessorChain.getRequestPath())) {
            jspServlet.forward(requestProcessorChain.getRequest(), requestProcessorChain.getResponse());
            return false;
        }
        return true;
    }

    /**
     * 是否请求的是jsp资源
     */
    private boolean isJspResource(String url) {
        return url.startsWith(JSP_RESOURCE_PREFIX);
    }

}
</code></pre>
<h2 id="四-controller处理器">四、Controller处理器</h2>
<h3 id="1-相关注解和配置类">1. 相关注解和配置类</h3>
<h3 id="2-controllerrequestprocessor">2. ControllerRequestProcessor</h3>
<p><strong>功能</strong>：</p>
<ul>
<li>针对特定请求，选择匹配的Controllerf方法进行处理</li>
<li>解析出请求里的参数及其对应的值，并赋值给Controller方法的参数</li>
<li>选择合适的Render，为后续请求处理结果的渲染做准备</li>
</ul>
<h3 id="3-建立controller方法与请求的映射关系">3. 建立Controller方法与请求的映射关系</h3>
<blockquote>
<p>请求中包含的信息有路径和请求参数，所以需要根据这些信息找到对应的Controller方法</p>
</blockquote>
<p><strong>存储请求的信息</strong></p>
<pre><code class="language-java">/**
 * 存储http请求路径和请求方法
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/5 16:45
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class RequestPathInfo {
    //http请求方法
    private String httpMethod;
    //http请求路径
    private String httpPath;

}
</code></pre>
<p><strong>存储Controller以及方法的信息</strong></p>
<pre><code class="language-java">/**
 * 封装待执行的Controller及其方法实例和参数的映射
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/5 16:40
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ControllerMethod {
    //Controller对应的Class对象
    private Class&lt;?&gt; controllerClass;
    //执行的Controller方法实例
    private Method invokeMethod;
    //方法参数名称以及对应的参数类型
    private Map&lt;String,Class&lt;?&gt;&gt; methodParameters;
}
</code></pre>
<p><strong>建立的映射关系就是RequestPathInfo与ControllerMethod的，这样就可以根据请求定位到对应的方法</strong></p>
<pre><code class="language-java">private Map&lt;RequestPathInfo, ControllerMethod&gt; pathControllerMethodMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<h3 id="4-给需要执行的方法参数赋值">4. 给需要执行的方法参数赋值</h3>
<pre><code class="language-java">/**
 * 给方法赋值的工具类
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/7 16:10
 */
public class ConverterUtil {
    /**
     * 返回基本数据类型的空值
     *需要特殊处理的基本类型即int\double\short\long\byte\float\boolean
     * @param type 参数类型
     * @return 对应的空值
     */
    public static Object primitiveNull(Class&lt;?&gt; type) {
        if (type == int.class || type == double.class ||
                type == short.class || type == long.class ||
                type == byte.class || type == float.class) {
            return 0;
        } else if(type == boolean.class){
            return false;
        }
        return null;
    }
    /**
     * String类型转换成对应的参数类型
     *
     * @param type  参数类型
     * @param requestValue 值
     * @return 转换后的Object
     */
    public static Object convert(Class&lt;?&gt; type, String requestValue) {
        if(isPrimitive(type)){
            if(ValidationUtil.isEmpty(requestValue)){
                return primitiveNull(type);
            }
            if (type.equals(int.class) || type.equals(Integer.class)) {
                return Integer.parseInt(requestValue);
            } else if (type.equals(String.class)) {
                return requestValue;
            } else if (type.equals(Double.class) || type.equals(double.class)) {
                return Double.parseDouble(requestValue);
            } else if (type.equals(Float.class) || type.equals(float.class)) {
                return Float.parseFloat(requestValue);
            } else if (type.equals(Long.class) || type.equals(long.class)) {
                return Long.parseLong(requestValue);
            } else if (type.equals(Boolean.class) || type.equals(boolean.class)) {
                return Boolean.parseBoolean(requestValue);
            } else if (type.equals(Short.class) || type.equals(short.class)) {
                return Short.parseShort(requestValue);
            } else if (type.equals(Byte.class) || type.equals(byte.class)) {
                return Byte.parseByte(requestValue);
            }
            return requestValue;
        } else {
            throw new RuntimeException(&quot;count not support non primitive type conversion yet&quot;);
        }
    }

    /**
     * 判定是否基本数据类型(包括包装类以及String)
     *
     * @param type 参数类型
     * @return 是否为基本数据类型
     */
    private static boolean isPrimitive(Class&lt;?&gt; type) {
        return type == boolean.class
                || type == Boolean.class
                || type == double.class
                || type == Double.class
                || type == float.class
                || type == Float.class
                || type == short.class
                || type == Short.class
                || type == int.class
                || type == Integer.class
                || type == long.class
                || type == Long.class
                || type == String.class
                || type == byte.class
                || type == Byte.class
                || type == char.class
                || type == Character.class;
    }
}
</code></pre>
<h3 id="5-利用反射执行获取执行的结果">5. 利用反射执行获取执行的结果</h3>
<pre><code class="language-java">Object controller = beanContainer.getBean(controllerMethod.getControllerClass());
Method invokeMethod = controllerMethod.getInvokeMethod();
invokeMethod.setAccessible(true);
Object result;
try {
    if (methodParam.size()==0){
        result = invokeMethod.invoke(controller);
    }else {
        result = invokeMethod.invoke(controller,methodParam.toArray());
    }
} catch (IllegalAccessException e) {
    throw new RuntimeException(e);
} catch (InvocationTargetException e) {
    //如果是调用异常的话，需要通过e.getTargetException()
    // 去获取执行方法抛出的异常
    throw new RuntimeException(e.getTargetException());
}
</code></pre>
<h3 id="6-根据结果设置结果渲染器">6. 根据结果设置结果渲染器</h3>
<pre><code class="language-java">ResultRender resultRender;
boolean isJson = controllerMethod.getInvokeMethod().isAnnotationPresent(ResponseBody.class);
if (isJson){
    resultRender = new JsonResultRender(result);
}else {
    resultRender = new ViewResultRender(result);
}
requestProcessorChain.setResultRender(resultRender);
</code></pre>
<p><strong>完整代码如下</strong>：</p>
<pre><code class="language-java">/**
 * 将请求转发给对应的Controller进行处理
 *
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:10
 */
@Slf4j
public class ControllerRequestProcessor implements RequestProcessor {
    //IOC容器
    private BeanContainer beanContainer;
    //请求和Controller的映射
    private Map&lt;RequestPathInfo, ControllerMethod&gt; pathControllerMethodMap = new ConcurrentHashMap&lt;&gt;();

    /**
     * 依靠容器，建立起请求路径、请求方法与Controller方法实例的映射
     */
    public ControllerRequestProcessor() {
        this.beanContainer = BeanContainer.getInstance();
        // 获取被@RequestMapping标记的Controller类
        Set&lt;Class&lt;?&gt;&gt; requestMappingSet = beanContainer.getClassesByAnnotation(RequestMapping.class);
        // 建立映射
        initPathControllerMethodMap(requestMappingSet);
    }

    /**
     * 建立起请求路径、请求方法与Controller方法实例的映射
     *
     * @param requestMappingSet 需要被转发的Controller
     */
    private void initPathControllerMethodMap(Set&lt;Class&lt;?&gt;&gt; requestMappingSet) {
        if (ValidationUtil.isEmpty(requestMappingSet)) {//如果没有类被@RequestMapping标记
            return;
        }
        //1.遍历所有被@RequestMapping标记的类，获取类上面该注解的属性值作为一级路径
        for (Class&lt;?&gt; requestMappingClass : requestMappingSet) {
            //获取@RequestMapping注解
            RequestMapping requestMapping = requestMappingClass.getAnnotation(RequestMapping.class);
            //获取注解值
            String basePath = requestMapping.value();
            if (!basePath.startsWith(&quot;/&quot;)) {//如果不是以“/”开头，为了方便处理，加上“/”
                basePath = &quot;/&quot; + basePath;
            }
            //2.遍历类里所有被@RequestMapping标记的方法，获取方法上面该注解的属性值，作为二级路径
            Method[] methods = requestMappingClass.getDeclaredMethods();
            if (ValidationUtil.isEmpty(methods)) {
                continue;
            }
            for (Method method : methods) {
                if (method.isAnnotationPresent(RequestMapping.class)) {//获取方法被@RequestMapping标记的
                    //获取@RequestMapping注解
                    RequestMapping methodRequest = method.getAnnotation(RequestMapping.class);
                    //获取注解值
                    String methodPath = methodRequest.value();
                    if (!methodPath.startsWith(&quot;/&quot;)) {//如果不是以“/”开头，为了方便处理，加上“/”
                        methodPath = &quot;/&quot; + methodPath;
                    }
                    //拼接一级和二级路径路径
                    String url = basePath + methodPath;
                    //3.解析方法里被@RequestParam标记的参数，
                    // 获取该注解的属性值，作为参数名，
                    // 获取被标记的参数的数据类型，建立参数名和参数类型的映射
                    Map&lt;String, Class&lt;?&gt;&gt; methodParams = new HashMap&lt;&gt;();
                    //获取方法的参数
                    Parameter[] parameters = method.getParameters();
                    if (!ValidationUtil.isEmpty(parameters)) {
                        for (Parameter parameter : parameters) {
                            //获取方法参数上的注解属性
                            RequestParam requestParam = parameter.getAnnotation(RequestParam.class);
                            //目前暂定为Controller方法里面所有的参数都需要@RequestParam注解
                            if (requestParam == null) {//如果方法参数没有注解，则暂时报错
                                throw new RuntimeException(&quot;The parameter must have @RequestParam&quot;);
                            }
                            methodParams.put(requestParam.value(), parameter.getType());
                        }
                    }
                    //4.将获取到的信息封装成RequestPathInfo实例和ControllerMethod实例，放置到映射表里
                    String httpMethod = String.valueOf(methodRequest.method());//获取注解中所要求的请求方法
                    RequestPathInfo requestPathInfo = new RequestPathInfo(httpMethod, url);
                    //如果出现了重复的路径
                    if (this.pathControllerMethodMap.containsKey(requestPathInfo)) {
                        log.warn(&quot;duplicate url:{} registration，current class {} method{} will override the former one&quot;,
                                requestPathInfo.getHttpPath(), requestMappingClass.getName(), method.getName());
                    }
                    ControllerMethod controllerMethod = new ControllerMethod(requestMappingClass, method, methodParams);
                    this.pathControllerMethodMap.put(requestPathInfo, controllerMethod);
                }
            }
        }


    }

    /**
     * 处理请求
     *
     * @param requestProcessorChain 责任链
     * @return 返回一定成功
     * @throws Exception 处理出错会抛出异常
     */
    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        //1.解析HttpServletRequest的请求方法,请求路径，获取对应的ControllerMethod实例
        String method = requestProcessorChain.getRequestMethod();//获取请求的方法类型
        String path = requestProcessorChain.getRequestPath();//获取请求路径
        ControllerMethod controllerMethod = this.pathControllerMethodMap.get(new RequestPathInfo(method, path));//查找对应的路径和方法
        if (controllerMethod == null) {//找不到请求路径
            requestProcessorChain.setResultRender(new ResourceNotFoundResultRender(method, path));
            return false;
        }
        //2.解析请求参数，并传递给获取到的ControllerMethod实例去执行
        Object result = invokeControllerMethod(controllerMethod, requestProcessorChain.getRequest());
        //3.根据处理的结果，选择对应的render进行渲染
        setResultRender(result, controllerMethod, requestProcessorChain);
        return false;
    }

    /**
     * 根据处理的结果，选择对应的render进行渲染
     *
     * @param result                处理的结果
     * @param controllerMethod      执行的Controller及其方法
     * @param requestProcessorChain 请求处理链
     */
    private void setResultRender(Object result, ControllerMethod controllerMethod, RequestProcessorChain requestProcessorChain) {
        if (result == null) {
            return;
        }
        ResultRender resultRender;
        boolean isJson = controllerMethod.getInvokeMethod().isAnnotationPresent(ResponseBody.class);
        if (isJson) {
            resultRender = new JsonResultRender(result);
        } else {
            resultRender = new ViewResultRender(result);
        }
        requestProcessorChain.setResultRender(resultRender);
    }

    /**
     * 解析请求参数，并传递给获取到的ControllerMethod实例去执行
     *
     * @param controllerMethod 需要执行的Controller配置
     * @param request          http请求
     * @return 处理的结果
     */
    private Object invokeControllerMethod(ControllerMethod controllerMethod, HttpServletRequest request) {
        //1.从请求里获取GET或者POST的参数名及其对应的值
        Map&lt;String, String&gt; requestParamMap = new HashMap&lt;&gt;();
        //GET，POST方法的请求参数获取方式
        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
        for (Map.Entry&lt;String, String[]&gt; parameter : parameterMap.entrySet()) {
            if (ValidationUtil.isEmpty(parameter.getValue())) {
                //只支持一个参数对应一个值的形式
                requestParamMap.put(parameter.getKey(), parameter.getValue()[0]);
            }
        }
        //2.根据获取到的请求参数名及其对应的值，以及controllerMethod里面的参数和类型的映射关系，去实例化出方法对应的参数
        List&lt;Object&gt; methodParam = new ArrayList&lt;&gt;();
        Map&lt;String, Class&lt;?&gt;&gt; methodParameterMap = controllerMethod.getMethodParameters();
        for (String paramName : methodParameterMap.keySet()) {
            Class&lt;?&gt; type = methodParameterMap.get(paramName);
            String requestValue = requestParamMap.get(paramName);
            Object value;
            //只支持String 以及基础类型char,int,short,byte,double,long,float,boolean,及它们的包装类型
            if (requestValue == null) {
                //将请求里的参数值转成适配于参数类型的空值
                value = ConverterUtil.primitiveNull(type);
            } else {
                value = ConverterUtil.convert(type, requestValue);
            }
            methodParam.add(value);
        }
        //3.执行Controller里面对应的方法并返回结果
        Object controller = beanContainer.getBean(controllerMethod.getControllerClass());
        Method invokeMethod = controllerMethod.getInvokeMethod();
        invokeMethod.setAccessible(true);
        Object result;
        try {
            if (methodParam.size() == 0) {
                result = invokeMethod.invoke(controller);
            } else {
                result = invokeMethod.invoke(controller, methodParam.toArray());
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            //如果是调用异常的话，需要通过e.getTargetException()
            // 去获取执行方法抛出的异常
            throw new RuntimeException(e.getTargetException());
        }
        return result;
    }


}
</code></pre>
<h2 id="五-处理结果渲染器">五、处理结果渲染器</h2>
<h3 id="1-默认结果渲染器">1. 默认结果渲染器</h3>
<blockquote>
<p>如果请求处理器实现类均未选择合适的渲染器，则使用默认的结果渲染器</p>
</blockquote>
<pre><code class="language-java">if (this.resultRender == null) {
    this.resultRender = new DefaultResultRender();
}
</code></pre>
<p><strong>主要将处理的结果状态码返回，默认为200</strong></p>
<pre><code class="language-java">/**
 * 默认渲染器，只会返回状态码
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:28
 */
public class DefaultResultRender implements ResultRender {
    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        //将相应状态码设置到response中
        requestProcessorChain.getResponse().setStatus(requestProcessorChain.getResponseCode());
    }
}

</code></pre>
<h3 id="2-异常结果渲染器">2. 异常结果渲染器</h3>
<blockquote>
<p>以责任链的模式处理请求，期间如果出现异常，则交由内部异常渲染器处理</p>
</blockquote>
<pre><code class="language-java">/**
 * 以责任链的模式处理请求
 */
public void doRequestProcessorChain() {
    //1.通过迭代器遍历注册的请求处理器实现类列表
    try {
        while (requestProcessorIterator.hasNext()) {
            //2.直到某个请求处理器执行后返回为false为止
            RequestProcessor requestProcessor = requestProcessorIterator.next();
            boolean processStatue = requestProcessor.process(this);
            if (!processStatue) {
                break;
            }
        }
    } catch (Exception e) {
        //3.期间如果出现异常，则交由内部异常渲染器处理
        this.resultRender = new InternalErrorResultRender(e.getMessage());
        log.error(&quot;doRequestProcessorChain error:&quot;, e);
    }

}
</code></pre>
<p><strong>设置状态码500和异常信息</strong></p>
<pre><code class="language-java">/**
 * 处理在请求中出现的异常
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:31
 */
public class InternalErrorResultRender implements ResultRender {

    private String errorMsg;

    public InternalErrorResultRender(String errorMsg){
        this.errorMsg = errorMsg;
    }

    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        HttpServletResponse response = requestProcessorChain.getResponse();
        //设置状态码500和错误信息
        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,errorMsg);
    }
}
</code></pre>
<h3 id="3-找不到路径渲染器">3. 找不到路径渲染器</h3>
<blockquote>
<p>在根据请求路径转发到Controller时，找不到对应的对象或者方法，则使用该渲染器</p>
</blockquote>
<p><strong>返回404和请求的路径及方法</strong></p>
<pre><code class="language-java">/**
 * 渲染找不到资源结果的渲染器
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:32
 */
public class ResourceNotFoundResultRender implements ResultRender {

    private String httpMethod;
    private String httpPath;

    public ResourceNotFoundResultRender(String httpMethod, String httpPath) {
        this.httpMethod = httpMethod;
        this.httpPath = httpPath;
    }

    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        requestProcessorChain.getResponse().sendError(HttpServletResponse.SC_NOT_FOUND,
                &quot;获取不到对应的请求资源：请求路径[&quot; + httpPath + &quot;]&quot; + &quot;请求方法[&quot; + httpMethod + &quot;]&quot;);
    }
}
</code></pre>
<h3 id="4-json结果渲染器">4. Json结果渲染器</h3>
<blockquote>
<p>当方法上面使用@ResponseBody注解时，利用Gson将结果转换成Json数据返回</p>
</blockquote>
<pre><code class="language-java">/**
 * 将结果返回成Json数据
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:29
 */
public class JsonResultRender implements ResultRender {
    private Object jsonData;
    public JsonResultRender(Object jsonData) {
        this.jsonData = jsonData;
    }

    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        //设置响应头
        requestProcessorChain.getResponse().setContentType(&quot;application/json&quot;);
        requestProcessorChain.getResponse().setCharacterEncoding(&quot;UTF-8&quot;);
        //响应流写入经过Gson格式化的处理结果
        PrintWriter writer = requestProcessorChain.getResponse().getWriter();
        Gson gson = new Gson();
        String str = gson.toJson(jsonData);
        writer.write(str);
        writer.flush();
    }
}
</code></pre>
<h3 id="5-视图解析器">5. 视图解析器</h3>
<blockquote>
<p>当方法上面没用使用@ResponseBody注解时，将使用视图解析器</p>
</blockquote>
<p><strong>模仿Spring MVC 定义一个视图ModelAndView</strong></p>
<pre><code class="language-java">/**
 * 存储请求结果，以及显示该数据的视图
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/7 18:02
 */

public class ModelAndView {
    //页面所在的路径
    @Getter
    private String view;
    //页面的数据
    @Getter
    private Map&lt;String ,Object&gt; model = new HashMap&lt;&gt;();

    public ModelAndView setView(String view) {
        this.view = view;
        return this;
    }
    //这样可以使用一连串的设置
    //modelAndView.setView(&quot;addheadline.jsp&quot;).addViewData(&quot;aaa&quot;, &quot;bbb&quot;);
    public ModelAndView addViewData(String attributeName, Object attributeValue){
        model.put(attributeName,attributeValue);
        return this;
    }
}
</code></pre>
<p><strong>视图解析器则根据返回结果的不同，而进行跳转</strong></p>
<ul>
<li>如果是String数据，则创建一个ModelAndView对象，并将数据加入到视图地址</li>
<li>如果是ModelAndView，则会解析其中的视图地址和数据</li>
</ul>
<pre><code class="language-java">/**
 * 渲染页面，比如ModelAndView类型
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:29
 */
public class ViewResultRender implements ResultRender {
    public static final String VIEW_PATH = &quot;/templates/&quot;;

    private ModelAndView modelAndView;
    /**
     * 对传入的参数进行处理，并赋值给ModelAndView成员变量
     * @param mv
     */
    public ViewResultRender(Object mv) {
        if(mv instanceof ModelAndView){
            //1.如果入参类型是ModelAndView，则直接赋值给成员变量
            this.modelAndView = (ModelAndView)mv;
        } else if(mv instanceof  String){
            //2.如果入参类型是String，则为视图，需要包装后才赋值给成员变量
            this.modelAndView = new ModelAndView().setView((String)mv);
        } else {
            //3.针对其他情况，则直接抛出异常
            throw new RuntimeException(&quot;illegal request result type&quot;);
        }
    }

    /**
     * 将请求处理结果按照视图路径转发至对应视图进行展示
     * @param requestProcessorChain
     * @throws Exception
     */
    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        HttpServletRequest request = requestProcessorChain.getRequest();
        HttpServletResponse response = requestProcessorChain.getResponse();
        //视图路径
        String path = modelAndView.getView();
        Map&lt;String, Object&gt; model = modelAndView.getModel();
        for(Map.Entry&lt;String, Object&gt; entry : model.entrySet()){
            request.setAttribute(entry.getKey(), entry.getValue());
        }
        //JSP
        request.getRequestDispatcher(VIEW_PATH +path).forward(request, response);

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】自定义SpringIOC]]></title>
        <id>https://xzzz2020.github.io/post/axgzRz0gg/</id>
        <link href="https://xzzz2020.github.io/post/axgzRz0gg/">
        </link>
        <updated>2020-09-10T12:11:26.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%89%8B%E5%86%99springioc%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B">一、手写SpringIOC容器简介</a></li>
<li><a href="#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E6%B3%A8%E8%A7%A3">二、创建注解</a></li>
<li><a href="#%E4%B8%89-%E6%8F%90%E5%8F%96%E6%A0%87%E8%AE%B0%E5%AF%B9%E8%B1%A1">三、提取标记对象</a>
<ul>
<li><a href="#1-%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%8A%A0%E8%BD%BD">1. 指定范围加载</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%AE%9E%E7%8E%B0ioc%E5%AE%B9%E5%99%A8">四、实现IOC容器</a>
<ul>
<li><a href="#1-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%8D%95%E4%BE%8B">1. 枚举的单例</a></li>
<li><a href="#2-%E4%BF%9D%E5%AD%98class%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%BD%BD%E4%BD%93">2. 保存Class对象及其实例的载体</a></li>
<li><a href="#3-%E5%AE%B9%E5%99%A8%E5%8A%A0%E8%BD%BD">3. 容器加载</a></li>
<li><a href="#4-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">4. 容器的操作（增删改查）</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">五、依赖注入</a>
<ul>
<li><a href="#1-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E8%A7%A3">1. 依赖注入的注解</a></li>
<li><a href="#2-%E5%AF%B9%E6%9C%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">2. 对有注解的属性进行依赖注入</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-手写springioc容器简介">一、手写SpringIOC容器简介</h2>
<p><strong>已经实现的功能有</strong>：</p>
<ol>
<li><strong>提供注解@Service、@Component、@Controller、@Repositor，标记需要加载到IOC容器管理的类</strong></li>
<li>提供了一个ClassUtil工具类，<strong>支持加载指定包下及其子包所有.class文件</strong>，支持注入属性，支持通过反射class加载实例化对象（<strong>仅支持默认构造</strong>）</li>
<li>提供IOC容器BeanContainer，支持通过ClassUtil工具类，加载被注解标记的类，目前<strong>仅支持单例模式以及非懒加载的方式</strong></li>
<li><strong>提供IOC容器增产改的方法，获取IOC的Bean的方式有：通过class直接加载；获取某一个标记的注解所有class集合；获取全部的class集合；获取父类或者接口的实现类结合Class</strong></li>
<li><strong>提供依赖注入的注解@Autowired，仅支持注入到属性上，该注解提供一个value，用户可以指定获取具体的接口实现类的名称</strong></li>
<li>提供完成所有标记在IOC容器中对象属性依赖注入的类DependencyInjector，将扫描@Autowired，根据用户定义的注解value或者默认值注入到属性中</li>
</ol>
<blockquote>
<p>使用BeanContainer的loadBeans方法，指定框架需要管理的包路径，将相关类加入到IOC容器中，再利用DependencyInjector的doIoc方法实现属性的依赖注入。</p>
</blockquote>
<p><strong>实现的思路为</strong>：</p>
<ol>
<li>创建注解</li>
<li>提取标记对象</li>
<li>实现容器</li>
<li>依赖注入</li>
</ol>
<p><strong>提取标记对象</strong></p>
<ol>
<li>指定范围，获取范围内全部的类</li>
<li>遍历所有类，获取被注解标记的类并加载到容器里</li>
</ol>
<h2 id="二-创建注解">二、创建注解</h2>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {
}
</code></pre>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Controller {
}
</code></pre>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Repository {
}
</code></pre>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Service {
}
</code></pre>
<h2 id="三-提取标记对象">三、提取标记对象</h2>
<h3 id="1-指定范围加载">1. 指定范围加载</h3>
<ul>
<li>
<p>首先需要获取到一个类加载器，通过类加载器加载用户指定包的资源，类加载器详解，查看这个文章：<a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/">类加载器总结</a></p>
</li>
<li>
<p>获取类加载的方式，可以通过当前的线程获取</p>
</li>
</ul>
<pre><code class="language-java">/**
 * 获取类加载器
 *
 * @return 当前类加载器
 */
public static ClassLoader getClassLoader() {
    return Thread.currentThread().getContextClassLoader();
}
</code></pre>
<ul>
<li>由于用户传递过来的只是个包名称，而对于不同的机器，项目所在的位置不同，所以就需要通过类加载器获取到资源的具体路径</li>
</ul>
<pre><code class="language-java">URL url = classLoader.getResource(packageName.replace(&quot;.&quot;, &quot;/&quot;));
</code></pre>
<ul>
<li>getResource()接收的是一个以反斜杠分割的路径，而一般用户提供的都是以“.”分割的，所以我们需要替换成反斜杠</li>
<li>classLoader.getResource()方法返回的是一个URL，可以获取到协议，域名，端口号，路径，请求参数，如：https[协议]😕/www.xzzz2020.cn[域名]:80[端口号]/public/simplespring[路径]?id=xxx[请求参数]</li>
<li>而我们需要关注的是这样的URL：<strong>file:///F:/study/Spring</strong>，该资源可以定位本机的唯一资源，所以需要通过URL类中两个方法getProtocol()和getPath()获取定位包的文件协议和绝对路径</li>
<li>接着主要是递归调用目录所有.class文件，利用反射Class.forName方法创建实例，并加入到集合中</li>
</ul>
<p><strong>完整代码如下所示：</strong></p>
<pre><code class="language-java">/**
 * 类加载工具类
 * @author xzzz2020
 * @version 1.0
 * @date 2020/7/31 13:20
 */

@Slf4j
public final class ClassUtil {

    private static final String FILE_PROTOCLO = &quot;file&quot;;

    private ClassUtil() {
    }

    /**
     * 获取包下类的集合
     *
     * @param packageName 包名
     * @return 获取类的集合
     */
    public static Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName) {
        //1. 获取类的加载器，为了获取项目发布的实际路径
        ClassLoader classLoader = getClassLoader();
        //2. 通过类加载器获取到加载的资源信息
        URL url = classLoader.getResource(packageName.replace(&quot;.&quot;, &quot;/&quot;));
        if (url == null) {
            log.warn(&quot;unable to retrieve anything from package: &quot; + packageName);
            return null;
        } else {
            log.info(&quot;load path is &quot;+url.getProtocol()+&quot;://&quot;+url.getPath());
        }
        //3. 根据不同的资源类型，采用不同的方式获取资源的集合
        Set&lt;Class&lt;?&gt;&gt; classSet = null;
        //过滤出文件类型的资源
        if (url.getProtocol().equalsIgnoreCase(FILE_PROTOCLO)){
            classSet = new HashSet&lt;&gt;();
            File packageDirectory = new File(url.getPath());//获取文件的实际路径
            //递归遍历该目录下所有的class文件
            extractClassFile(classSet,packageDirectory,packageName);
        }
        return classSet;
    }

    /**
     * 递归遍历该目录下所有的class文件
     * @param emptyClassSet 装载目标类的集合
     * @param fileSource 文件或目录
     * @param packageName 加载的包路径
     */
    private static void extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName) {
        if (!fileSource.isDirectory()){

        }else {
            //列出当前目录的所有文件和文件夹
            File[] files = fileSource.listFiles(new FileFilter() {
                /**
                 * 该方法是过滤当前目录下的所有文件和目录
                 * @param file 文件目录
                 * @return 如果是目录，返回true，如果是.class文件，加载到容器中，其他的返回false
                 */
                @Override
                public boolean accept(File file) {
                    if (file.isDirectory()){
                        return true;
                    }else {
                        //获取文件的绝对值路径
                        String absoluteFilePath = file.getAbsolutePath();
                        if (absoluteFilePath.endsWith(&quot;.class&quot;)){
                            //如果是class文件，直接加载
                            addToClassSet(absoluteFilePath);
                        }
                        //TODO 此处可以加入针对其他类型资源的处理
                    }
                    return false;
                }

                /**
                 * 根据class文件的绝对值路径，获取并生成class对象，并放入classSet中
                 * @param absoluteFilePath 文件的绝对值路径
                 */
                private void addToClassSet(String absoluteFilePath) {
                    //1.从class文件的绝对值路径里提取出包含了package的类名
                    //如/Users/baidu/imooc/springframework/sampleframework/target/classes/cn/xzzz2020/entity/dto/MainPageInfoDTO.class
                    //需要弄成cn.xzzz2020.entity.dto.MainPageInfoDTO
                    absoluteFilePath  = absoluteFilePath.replace(File.separator, &quot;.&quot;);
                    String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));
                    className = className.substring(0,className.lastIndexOf(&quot;.&quot;));
                    //2.通过反射机制获取对应的Class对象并加入到classSet里
                    Class&lt;?&gt; targetClass = loadClass(className);
                    emptyClassSet.add(targetClass);
                }
            });
            //递归遍历全部目录
            if (files!=null){//如果file的数组为空，使用foreach，还是会抛出空指针异常
                for (File file : files) {
                    extractClassFile(emptyClassSet,file,packageName);
                }
            }

        }
    }

    /**
     * 获取类加载器
     *
     * @return 当前类加载器
     */
    public static ClassLoader getClassLoader() {
        return Thread.currentThread().getContextClassLoader();
    }

    /**
     * 获取class对象
     * @param className class全限定类名
     * @return
     */
    public static Class&lt;?&gt; loadClass(String className){
        try {
            return Class.forName(className);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            log.error(&quot;Load class error &quot; + e);
            throw new RuntimeException();
        }
    }
    
    
    /**
     * 实例化类对象
     * @param clazz 需要实例化的class
     * @param accessible 是否允许使用私有的构造函数
     * @param &lt;T&gt; 对象
     * @return
     */
    public static &lt;T&gt; T newInstance(Class&lt;?&gt; clazz,boolean accessible){
        try {
            Constructor constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(accessible);
            return (T) constructor.newInstance();
        } catch (Exception e) {
            log.error(&quot;newInstance &quot;+clazz+&quot; error &quot;+e);
            throw new RuntimeException();
        }
    }
    
    /**
     * 设置类的属性值
     * @param field 成员变量
     * @param target 类实例
     * @param value 成员变量的值
     * @param accessible 是否允许设置私有属性
     */
    public static void setField(Field field,Object target,Object value,boolean accessible){
        field.setAccessible(accessible);
        try {
            field.set(target,value);
        } catch (Exception e) {
            log.error(&quot;setFiled error &quot;,e);
            throw new RuntimeException(e);
        }
    }

}
</code></pre>
<h2 id="四-实现ioc容器">四、实现IOC容器</h2>
<p><strong>容器一般由以下组成部分：</strong></p>
<ul>
<li>保存Class对象及其实例的载体</li>
<li>容器的加载</li>
<li>容器的操作方式</li>
</ul>
<blockquote>
<p>容器首先是单例的，但是传统的单例只能避免多线程下重复创建的问题，面对反射的强大能力，很容易就被创建一个新的对象</p>
<p>而Java提供了一个枚举类的形式，可以从源码层面避免创建多个对象。</p>
</blockquote>
<h3 id="1-枚举的单例">1. 枚举的单例</h3>
<pre><code class="language-java">//设置私有构造器
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Slf4j
public class BeanContainer {

    /**
     * 获取容器实例
     * @return 容器
     */
    public static BeanContainer getInstance() {
        return BeanContainerHolder.HOLDER.getInstance();
    }

    private enum BeanContainerHolder{
        HOLDER;
        private BeanContainer instance;
        BeanContainerHolder(){
            instance = new BeanContainer();
        }

        public BeanContainer getInstance() {
            return instance;
        }
    }
}
</code></pre>
<h3 id="2-保存class对象及其实例的载体">2. 保存Class对象及其实例的载体</h3>
<p>为了方便调用，将采用map的方式创建载体，但是不是使用HashMap，而是ConcurrentHashMap以保证高并发下的容器线程安全。</p>
<pre><code class="language-java">//存放所有被标记的map
private final Map&lt;Class&lt;?&gt;,Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<h3 id="3-容器加载">3. 容器加载</h3>
<pre><code class="language-java">/**
 * 加载Bean到容器中
 * @param packageName 包名称
 */
public synchronized void loadBeans(String packageName){
    //判断是否重复加载
    if (isLoaded()){
        log.warn(&quot;BeanContainer has been loaded.&quot;);
        return;
    }
    //获取指定包下面的class对象
    Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(packageName);
    //判断能否加载对象
    if (ValidationUtil.isEmpty(classSet)){
        log.warn(&quot;This package &quot;+packageName+&quot; has nothing.&quot;);
        return;
    }
    for (Class&lt;?&gt; clazz :classSet){
        for (Class&lt;? extends Annotation&gt; annotation : BEAN_ANNOTATION) {
            //如果类上面标记了自定义的注解，就放入到容器中
            if (clazz.isAnnotationPresent(annotation)){
                beanMap.put(clazz,ClassUtil.newInstance(clazz,true));
            }
        }
    }
    loaded = true;
}
</code></pre>
<h3 id="4-容器的操作增删改查">4. 容器的操作（增删改查）</h3>
<pre><code class="language-java">/**
 * 判断是否过容器
 * @return true代表已经加载过容器了
 */
public boolean isLoaded() {
    return loaded;
}
/**
 * 获取加载到容器中bean实例的个数
 * @return
 */
public int getBeansSize(){
    return beanMap.size();
}
/**
 * 添加对象实例到容器中
 * @param clazz 指定对象
 * @param bean 指定实例
 * @return 添加的对象
 */
public Object addBean(Class&lt;?&gt; clazz,Object bean){
    return beanMap.put(clazz, bean);
}
/**
 * 删除容器中bean的实例
 * @param clazz 指定对象
 * @return 删除的对象
 */
public Object removeBean(Class&lt;?&gt; clazz){
    return beanMap.remove(clazz);
}
/**
 * 获取指定对象的实例
 * @param clazz 指定对象
 * @return 指定实例
 */
public Object getBean(Class&lt;?&gt; clazz){
    return beanMap.get(clazz);
}
/**
 * 获取容器中所有对象的集合
 * @return 对象集合
 */
public Set&lt;Class&lt;?&gt;&gt; getClasses(){
    return beanMap.keySet();
}
/**
 * 获取容器中所有实例化对象集合
 * @return 实例化对象集合
 */
public Set&lt;Object&gt; getBeans(){
    return new HashSet&lt;&gt;(beanMap.values());
}
/**
 * 根据注解获取对象集合
 * @param annotation 注解
 * @return
 */
public Set&lt;Class&lt;?&gt;&gt; getClassesByAnnotation(Class&lt;? extends Annotation&gt; annotation){
    //1.获取beanMap的所有class对象
    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();
    if(ValidationUtil.isEmpty(keySet)){
        log.warn(&quot;nothing in beanMap&quot;);
        return null;
    }
    //2.通过注解筛选被注解标记的class对象，并添加到classSet里
    Set&lt;Class&lt;?&gt;&gt; classSet = new HashSet&lt;&gt;();
    for (Class&lt;?&gt; clazz : keySet) {
        if (clazz.isAnnotationPresent(annotation)){
            classSet.add(clazz);
        }
    }
    return classSet.size()&gt;0?classSet:null;
}
/**
 * 通过接口或者父类获取实现类或者子类的Class集合，不包括其本身
 *
 * @param interfaceOrClass 接口Class或者父类Class
 * @return Class集合
 */
public Set&lt;Class&lt;?&gt;&gt; getClassesBySuper(Class&lt;?&gt; interfaceOrClass){
    //1.获取beanMap的所有class对象
    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();
    if(ValidationUtil.isEmpty(keySet)){
        log.warn(&quot;nothing in beanMap&quot;);
        return null;
    }
    //2.通过keySet的元素是否是传入的接口或者子类，如果是，并添加到classSet里
    Set&lt;Class&lt;?&gt;&gt; classSet = new HashSet&lt;&gt;();
    for (Class&lt;?&gt; clazz : keySet) {
        //isAssignableFrom可以判断是否是同一个类或者其超类
        if (interfaceOrClass.isAssignableFrom(clazz) &amp;&amp; !clazz.equals(interfaceOrClass)){
            classSet.add(clazz);
        }
    }
    return classSet.size()&gt;0?classSet:null;
}
</code></pre>
<h2 id="五-依赖注入">五、依赖注入</h2>
<h3 id="1-依赖注入的注解">1. 依赖注入的注解</h3>
<pre><code class="language-java">/**
 * @author xzzz2020
 * @version 1.0
 * @date 2020/7/31 17:06
 */

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Autowired {
    String value() default &quot;&quot;;
}
</code></pre>
<h3 id="2-对有注解的属性进行依赖注入">2. 对有注解的属性进行依赖注入</h3>
<pre><code class="language-java">/**
 * 提供依赖注入
 *
 * @author xzzz2020
 * @version 1.0
 * @date 2020/7/31 17:12
 */
@Slf4j
public class DependencyInjector {
    //Bean容器
    private BeanContainer beanContainer;

    public DependencyInjector() {
        beanContainer = BeanContainer.getInstance();
    }

    /**
     * 执行依赖注入
     */
    public void doIoc() {
        if (ValidationUtil.isEmpty(beanContainer.getClasses())) {
            log.warn(&quot;empty classset in BeanContainer&quot;);
            return;
        }
        //1.遍历Bean容器中所有的Class对象
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClasses();
        for (Class&lt;?&gt; clazz : classSet) {
            //2.遍历Class对象的所有成员变量
            Field[] fields = clazz.getDeclaredFields();
            if (ValidationUtil.isEmpty(fields)){
                continue;
            }
            //3.找出被Autowired标记的成员变量
            for (Field field : fields) {
                if (field.isAnnotationPresent(Autowired.class)){
                    //获取属性上面的注解，来解析属性
                    Autowired autowired = field.getAnnotation(Autowired.class);
                    String value = autowired.value();
                    //4.获取这些成员变量的类型
                    Class&lt;?&gt; fieldClazz = field.getType();
                    //5.获取这些成员变量的类型在容器里对应的实例
                    Object fieldValue = getFieldInstance(fieldClazz,value);
                    //获取不到对象，注入失败
                    if (fieldValue == null){
                        throw new RuntimeException(&quot;unable to inject relevant type，target fieldClass is:&quot; + fieldClazz.getName() + &quot; in &quot; +clazz.getSimpleName() );
                    }
                    //6.通过反射将对应的成员变量实例注入到成员变量所在类的实例里
                    Object targetBean = beanContainer.getBean(clazz);
                    ClassUtil.setField(field,targetBean,fieldValue,true);
                }
            }

        }

    }

    /**
     * 根据class对象获取其对象或者实现类
     * @param fieldClazz 属性定义的对象
     * @return
     */
    private Object getFieldInstance(Class&lt;?&gt; fieldClazz,String value) {
        Object fieldValue = beanContainer.getBean(fieldClazz);
        if (fieldValue!=null){
            return fieldClazz;
        }else {
           Class&lt;?&gt; implClass = getImplementClass(fieldClazz,value);
           if (implClass!=null){
               return beanContainer.getBean(implClass);
           }else {
               return null;
           }
        }
    }

    /**
     * 获取接口的实现类
     * @param fieldClazz 接口
     * @return
     */
    private Class&lt;?&gt; getImplementClass(Class&lt;?&gt; fieldClazz,String value) {
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesBySuper(fieldClazz);
        if (!ValidationUtil.isEmpty(classSet)){
            if (ValidationUtil.isEmpty(value)){//代表用户没有指定具体是那个实现类
                if (classSet.size()==1){
                    return classSet.iterator().next();
                }else {//如果该接口有多个实现类，则抛出异常
                    throw new RuntimeException(&quot;multiple implemented classes for &quot; + fieldClazz.getName() + &quot; please set @Autowired's value to pick one&quot;);
                }
            }else {//用户指定具体实现子类
                for (Class&lt;?&gt; clazz : classSet) {
                    if (value.equals(clazz.getSimpleName())){//是用户的指定类
                        return clazz;
                    }
                }
            }
        }
        return null;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】自定义SpringAOP]]></title>
        <id>https://xzzz2020.github.io/post/c2A2Jmewz/</id>
        <link href="https://xzzz2020.github.io/post/c2A2Jmewz/">
        </link>
        <updated>2020-09-10T12:07:20.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a>
<ul>
<li><a href="#1-aop%E7%9A%84%E5%BC%95%E5%87%BA">1. AOP的引出</a></li>
<li><a href="#2-%E8%87%AA%E7%A0%94aop%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD">2. 自研AOP提供的功能</a></li>
<li><a href="#3-aop%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">3. AOP的核心概念：</a></li>
<li><a href="#4-advice%E7%9A%84%E7%A7%8D%E7%B1%BB">4. Advice的种类：</a></li>
<li><a href="#5-%E5%88%87%E9%9D%A2%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">5. 切面执行顺序</a></li>
<li><a href="#6-introduction-%E5%BC%95%E5%85%A5%E5%9E%8Badvice">6. Introduction--引入型Advice</a></li>
<li><a href="#7-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">7. JDK动态代理</a></li>
<li><a href="#8-cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">8. CGLIb动态代理</a></li>
<li><a href="#9-springaop%E7%9A%84%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6">9. SpringAOP的底层机制</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%88%A9%E7%94%A8cglib%E5%AE%9E%E7%8E%B0aop%E9%80%BB%E8%BE%91">二、利用CGLib实现AOP逻辑</a>
<ul>
<li><a href="#1-%E5%AE%8C%E6%88%90%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%88%9B%E5%BB%BA">1. 完成注解的创建</a></li>
<li><a href="#2-%E5%88%87%E9%9D%A2%E6%A8%A1%E6%9D%BF%E7%B1%BB">2. 切面模板类</a></li>
<li><a href="#3-%E8%A2%AB%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E7%BB%87%E5%85%A5%E5%AE%9E%E7%8E%B0">3. 被代理类的织入实现</a></li>
<li><a href="#4-%E6%89%A7%E8%A1%8C%E5%AE%B9%E5%99%A8%E7%9A%84aop%E6%93%8D%E4%BD%9C">4. 执行容器的AOP操作</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%BC%95%E5%85%A5aspectj%E6%A1%86%E6%9E%B6">三、引入AspectJ框架</a>
<ul>
<li><a href="#1-aspectj%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">1. AspectJ框架简介</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2. 环境配置</a></li>
<li><a href="#3-%E8%A7%A3%E6%9E%90aspect%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E5%AE%9A%E4%BD%8D%E8%A2%AB%E7%BB%87%E5%85%A5%E7%9B%AE%E6%A0%87">3. 解析Aspect表达式并定位被织入目标</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<h3 id="1-aop的引出">1. AOP的引出</h3>
<p><strong>在开发中除了有业务需求，也会存在系统需求：</strong></p>
<ul>
<li><strong>添加日志信息</strong>：为每个方法添加统计统计</li>
<li>**添加系统权限校验：**针对某些方法进行限制</li>
<li><strong>事务控制</strong>：针对持久化的数据，进行事务的精细控制</li>
</ul>
<p><strong>面向对象编程需要在每个方法加入通用的代码，代码没有被复用，同时增加维护成本</strong></p>
<p>软件工程里面有一个概念叫做关注点分离，即不同的问题交给不同的部分去解决，面向切面编程（AOP）就是一种关注点分离的技术。</p>
<p>将业务功能代码和系统层面代码分离，系统通用化功能的代码实现就是切面Aspect。Aspect之于AOP，相当于class之于OOP，Bean之于IOC。</p>
<h3 id="2-自研aop提供的功能">2. 自研AOP提供的功能</h3>
<ul>
<li>
<p>利用CGLIB实现对目标类方法的增强</p>
<ul>
<li>定义MethodInterceptor实现类，完成对方法的增强，methodProxy的invokeSuper方法复杂执行原定的方法逻辑，在这个方法执行前后以及出现异常的时候，可以织入相关逻辑。同时定义了@Order注解，对切面按照指定的顺序执行。</li>
<li>利用Enhancer的create方法，传入目标类和对方法增强的织入逻辑，动态产生一个增强后的类，替换掉原来的类</li>
</ul>
</li>
<li>
<p>引入AspectJ的表达式解析能力，更加灵活的定义切点</p>
<ul>
<li><strong>PointcutParser</strong>：提供对表达式语法的支持，利用parsePointcutExpression方法，解析表达式，将返回一个PointcutExpression接口的实现类</li>
<li><strong>PointcutExpression接口</strong>：用于验证类或者方法是否符合表达式规则，couldMatchJoinPointsInType方法提供类的粗检查，只能校验within的表达式，其他的都会表达true；matchesMethodExecution方法提供对方法的精确检查</li>
</ul>
</li>
</ul>
<h3 id="3-aop的核心概念">3. AOP的核心概念：</h3>
<ul>
<li>**切面Aspect：**将横切关注点逻辑逻辑进行模块化封装的实体对象</li>
<li>**通知Advice：**好比是Class里面的方法，还定义了织入逻辑的时机</li>
<li>**连接点JoinPoint：**允许使用Advice的地方</li>
<li>**切入点PointCut：**定义一系列规则对JoinPoint进行筛选</li>
<li>**目标对象Target：**符合PointCut的对象</li>
<li><strong>织入</strong>：将Aspect模块化的横切关注点集成到OOP里</li>
<li>**织入器：**完成织入过程的执行者，如ajc</li>
</ul>
<h3 id="4-advice的种类">4. Advice的种类：</h3>
<blockquote>
<p>需要注意一点@Around注解如果使用了try..catch..，就会让@AfterThrowing注解失败</p>
</blockquote>
<ul>
<li>**BeforeAdvice：**在JoinPoint前被执行的Advice，无法阻止JoinPoint的执行，除非发生了异常</li>
<li>**AfterAdvice：**好比try..catch..finally里面的finally方法，不管方法是否发生异常，都会最终执行</li>
<li>**AfterReturningAdvice：**在JoinPoint正常执行后，才能正在执行，如果出现异常，则无法执行</li>
<li>**AfterThrowingAdvice：**在JoinPoint在执行时抛出才会触发</li>
<li>**AroundAdvice：**可以在JoinPoint执行前后进行织入，也可以决定JoinPoint是否需要执行</li>
</ul>
<p><strong>分拆的原因</strong>：丰富Advice的语义，可以单独将某个环节拆出来用，并能依据不同场景，最小化织入Advice</p>
<h3 id="5-切面执行顺序">5. 切面执行顺序</h3>
<blockquote>
<p>多个Aspect可以使用@Order进行排序，数值越小越先执行</p>
</blockquote>
<ol>
<li>@Around，JoinPoint的proceed方法执行前</li>
<li>@Before，在@Around选择执行时触发，在执行前织入</li>
<li>@Around方法执行以及执行后逻辑</li>
<li>@After</li>
<li>如果正常执行，是@AfterReturning，出现异常是@AfterThrowing</li>
</ol>
<h3 id="6-introduction-引入型advice">6. Introduction--引入型Advice</h3>
<ul>
<li>为目标类引入新接口，而不需要目标类做任何实现</li>
<li>使得目标类在使用过程中转型成新接口对象，调用新接口方法</li>
</ul>
<h3 id="7-jdk动态代理">7. JDK动态代理</h3>
<h3 id="8-cglib动态代理">8. CGLIb动态代理</h3>
<ul>
<li>不要求被代理类实现接口</li>
<li>内部主要封装了ASM Java字节码操作框架，可以帮助我们安全的操作字节码</li>
<li>动态生成一个子类以覆盖非final的方法，绑定钩子回调自定义拦截器</li>
</ul>
<p><strong>被代理类：</strong></p>
<pre><code class="language-java">public class CommonPayment {
    public void pay() {
        System.out.println(&quot;个人名义或者公司名义都可以走这个支付通道&quot;);
    }
}
</code></pre>
<p><strong>方法拦截器：</strong></p>
<pre><code class="language-java">public class AlipayMethodInterceptor implements MethodInterceptor {
    /**
     *
     * @param proxy 生成的代理对象
     * @param method 被增强的方法
     * @param args 方法的参数
     * @param methodProxy 增强后的方法
     * @return 方法的返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        beforePay();
        Object result = methodProxy.invokeSuper(proxy,args);
        afterPay();
        return result;
    }

    private void afterPay() {
        System.out.println(&quot;支付给公司&quot;);
    }

    private void beforePay() {
        System.out.println(&quot;从银行取款&quot;);
    }

}
</code></pre>
<p><strong>Cglib工具类</strong>：</p>
<pre><code class="language-java">public class CglibUtil {
    public static &lt;T&gt; T creatProxy(T targetObject, MethodInterceptor interceptor){
        Object proxy = Enhancer.create(targetObject.getClass(), interceptor);
        return (T) proxy;
    }
}
</code></pre>
<p><strong>JDK动态代理和Cglib的区别？</strong></p>
<blockquote>
<p>JDK动态代理做了很多优化，所以性能和Cglib差异不大</p>
</blockquote>
<ul>
<li>JDK动态代理是基于反射实现的，要求业务类必须实现接口，是JDK原生，在JVM运行更可靠，可以减少依赖</li>
<li>Cglib基于ASM机制实现，通过生成业务类的子类作为代理类，无需实现接口，能实现代理类的无侵入</li>
</ul>
<h3 id="9-springaop的底层机制">9. SpringAOP的底层机制</h3>
<ul>
<li>是Cglib与JDK动态代理共存的</li>
<li><strong>默认策略</strong>：如果Bean实现了接口采用JDK动态代理的方式，否则使用CGlib</li>
</ul>
<h2 id="二-利用cglib实现aop逻辑">二、利用CGLib实现AOP逻辑</h2>
<blockquote>
<p>由于CGLib不需要实现接口，实现比较简单</p>
</blockquote>
<h3 id="1-完成注解的创建">1. 完成注解的创建</h3>
<p><strong>标记类为切面，实现横切逻辑</strong></p>
<pre><code class="language-java">//只能注入到类上
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Aspect {
    /*
    * 需要被织入横切逻辑的注解标签
    */
    Class&lt;? extends Annotation&gt; value();
}
</code></pre>
<p><strong>标记切面的执行顺序</strong></p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Order {
    /*
    值越小，越先执行
     */
    int value() default Integer.MAX_VALUE;
}
</code></pre>
<h3 id="2-切面模板类">2. 切面模板类</h3>
<blockquote>
<p>切面需要继承该类，并重写相应的方法实现横切逻辑</p>
<p>如果没有重写，则相应方法为空，不影响结果</p>
</blockquote>
<pre><code class="language-java">public abstract class DefaultAspect {
    /**
     * 事前拦截
     * @param targetClass 被代理的目标类
     * @param method 被代理的目标方法
     * @param args 被代理的目标方法对应的参数列表
     * @throws Throwable
     */
    public void before(Class&lt;?&gt; targetClass, Method method, Object[] args) throws Throwable{

    }
    /**
     * 事后拦截
     * @param targetClass 被代理的目标类
     * @param method 被代理的目标方法
     * @param args 被代理的目标方法对应的参数列表
     * @param returnValue 被代理的目标方法执行后的返回值
     * @throws Throwable
     */
    public Object afterReturning(Class&lt;?&gt; targetClass, Method method, Object[] args, Object returnValue) throws Throwable{
        return returnValue;
    }
    /**
     *
     * @param targetClass 被代理的目标类
     * @param method 被代理的目标方法
     * @param args 被代理的目标方法对应的参数列表
     * @param e 被代理的目标方法抛出的异常
     * @throws Throwable
     */
    public void afterThrowing(Class&lt;?&gt; targetClass, Method method, Object[] args,  Throwable e) throws Throwable{

    }
}
</code></pre>
<h3 id="3-被代理类的织入实现">3. 被代理类的织入实现</h3>
<blockquote>
<ul>
<li>
<p>实现CGLib中MethodInterceptor接口的intercept方法，实现被代理类的切入逻辑</p>
</li>
<li>
<p>会自动对传入的切面按照order排序</p>
</li>
</ul>
</blockquote>
<pre><code class="language-java">public class AspectListExecutor implements MethodInterceptor {
    //被代理的类
    private Class&lt;?&gt; targetClass;
    //排过序的Aspect列表
    @Getter
    private List&lt;AspectInfo&gt; sortedAspectInfos;

    public AspectListExecutor(Class&lt;?&gt; targetClass, List&lt;AspectInfo&gt; aspectInfos) {
        this.targetClass = targetClass;
        this.sortedAspectInfos = sortAspectInfoList(aspectInfos);
    }

    /**
     * 根据aspectInfos的Order属性值进行排序
     *
     * @param aspectInfos
     * @return
     */
    private List&lt;AspectInfo&gt; sortAspectInfoList(List&lt;AspectInfo&gt; aspectInfos) {
        aspectInfos.sort(new Comparator&lt;AspectInfo&gt;() {
            @Override
            public int compare(AspectInfo o1, AspectInfo o2) {
                //按照order的大小排序
                return o1.getOrderIndex() - o2.getOrderIndex();
            }
        });
        return aspectInfos;
    }

    /**
     * 实现被代理类的织入逻辑
     * @param proxy 生成的代理对象
     * @param method 被增强的方法
     * @param args 方法的参数
     * @param methodProxy 增强后的方法
     * @return 方法的返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        Object returnValue = null;
        if (ValidationUtil.isEmpty(sortedAspectInfos)){
            return null;
        }
        try {
            //1.按照order的顺序升序执行完所有Aspect的before方法
            invokeBeforeAdvices(method,args);
            //2.执行被代理类的方法
            returnValue = methodProxy.invokeSuper(proxy,args);
            //3.如果被代理方法正常返回，则按照order的顺序降序执行完所有Aspect的afterReturning方法
            returnValue = invokeAfterReturningAdvice(method,args,returnValue);
        } catch (Throwable throwable) {
            //4.如果被代理方法抛出异常，则按照order的顺序降序执行完所有Aspect的afterThrowing方法
            invokeAfterThrowingAdvices(method,args,throwable);
        }
        return returnValue;
    }

    //如果被代理方法抛出异常，则按照order的顺序降序执行完所有Aspect的afterThrowing方法
    private void invokeAfterThrowingAdvices(Method method, Object[] args, Throwable throwable) throws Throwable {
        for(int i = sortedAspectInfos.size()-1;i&gt;=0;i--){
           sortedAspectInfos.get(i).getDefaultAspect().afterThrowing(targetClass,method,args,throwable);
        }
    }

    //如果被代理方法正常返回，则按照order的顺序降序执行完所有Aspect的afterReturning方法
    private Object invokeAfterReturningAdvice(Method method, Object[] args, Object returnValue) throws Throwable {
        Object result = null;
        for(int i = sortedAspectInfos.size()-1;i&gt;=0;i--){
            result = sortedAspectInfos.get(i).getDefaultAspect().afterReturning(targetClass,method,args,returnValue);
        }
        return result;
    }

    //按照order的顺序升序执行完所有Aspect的before方法
    private void invokeBeforeAdvices(Method method, Object[] args) throws Throwable {
        for (AspectInfo sortedAspectInfo : sortedAspectInfos) {
            sortedAspectInfo.getDefaultAspect().before(targetClass,method,args);
        }
    }
}
</code></pre>
<h3 id="4-执行容器的aop操作">4. 执行容器的AOP操作</h3>
<p><strong>基本逻辑为：</strong></p>
<ol>
<li>将所有被@Aspect注解标记的切面类获取</li>
<li>根据切面类的切入点不同，进行分类</li>
<li>根据不同的切入点，生成该切入点的动态代理类，替换掉容器中没有被代理的类</li>
</ol>
<pre><code class="language-java">public class AspectWeaver {
    private BeanContainer beanContainer;

    public AspectWeaver() {
        beanContainer = BeanContainer.getInstance();
    }

    public void doAop() {
        //1.获取所有的切面类
        Set&lt;Class&lt;?&gt;&gt; aspectSet = beanContainer.getClassesByAnnotation(Aspect.class);
        if (ValidationUtil.isEmpty(aspectSet)) {
            return;
        }
        //2.将切面类按照不同的织入目标分类
        Map&lt;Class&lt;? extends Annotation&gt;, List&lt;AspectInfo&gt;&gt; categorizedMap = new HashMap&lt;&gt;();
        for (Class&lt;?&gt; aspectClass : aspectSet) {
            //验证切面
            if (verifyAspect(aspectClass)) {
                categorizeAspect(categorizedMap, aspectClass);
            } else {
                //不遵守规范则直接抛出异常
                throw new RuntimeException(&quot;@Aspect and @Order must be added to the Aspect class, and Aspect class must extend from DefaultAspect&quot;);
            }
        }
        //3.按照不同的织入目标，分别去按序织入Aspect的逻辑
        if (!ValidationUtil.isEmpty(categorizedMap)){
            for (Class&lt;? extends Annotation&gt; category : categorizedMap.keySet()) {
                weaveByCategory(category,categorizedMap.get(category));
            }
        }
    }

    private void weaveByCategory(Class&lt;? extends Annotation&gt; category, List&lt;AspectInfo&gt; aspectInfos) {
        //1.获取被代理类的集合
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesByAnnotation(category);
        if (ValidationUtil.isEmpty(classSet)){
            return;
        }
        //2.遍历被代理类，分别为每个被代理类生成动态代理实例
        for (Class&lt;?&gt; targerClass : classSet) {
            //创建动态代理对象
            AspectListExecutor aspectListExecutor = new AspectListExecutor(targerClass,aspectInfos);
            //本质调用的这个Enhancer.create(targetClass,interceptor);
            Object proxyBean = ProxyCreator.createProxy(targerClass, aspectListExecutor);
            //3.将动态代理的实例对象添加到容器中，取代未被代理前的实例
            beanContainer.addBean(targerClass,proxyBean);
        }
    }

    //将切面类按照不同的织入目标分类
    private void categorizeAspect(Map&lt;Class&lt;? extends Annotation&gt;, List&lt;AspectInfo&gt;&gt; categorizedMap, Class&lt;?&gt; aspectClass) {
        Order orderTag = aspectClass.getAnnotation(Order.class);
        Aspect aspectTag = aspectClass.getAnnotation(Aspect.class);
        DefaultAspect bean = (DefaultAspect) beanContainer.getBean(aspectClass);
        AspectInfo aspectInfo = new AspectInfo(orderTag.value(),bean);
        //获取织入点的集合
        List&lt;AspectInfo&gt; infoList = categorizedMap.getOrDefault(aspectTag.value(), new ArrayList&lt;AspectInfo&gt;());
        infoList.add(aspectInfo);
        categorizedMap.put(aspectTag.value(),infoList);
    }

    //框架中一定要遵守给Aspect类添加@Aspect和@Order标签的规范，同时，必须继承自DefaultAspect.class
    //此外，@Aspect的属性值不能是它本身
    private boolean verifyAspect(Class&lt;?&gt; aspectClass) {
        return aspectClass.isAnnotationPresent(Aspect.class)
                &amp;&amp; aspectClass.isAnnotationPresent(Order.class)
                &amp;&amp; DefaultAspect.class.isAssignableFrom(aspectClass)
                &amp;&amp; aspectClass.getAnnotation(Aspect.class).value() != Aspect.class;
    }
}

/**
 * 创建动态代理对象
 * @author xzzz2020
 * @version 1.0
 * @date 2020/8/8 11:33
 */
public class ProxyCreator {

    public static Object createProxy(Class&lt;?&gt; targetClass, MethodInterceptor interceptor){
        return Enhancer.create(targetClass,interceptor);
    }
}

</code></pre>
<h2 id="三-引入aspectj框架">三、引入AspectJ框架</h2>
<blockquote>
<p>让Pointcut更加灵活，引入AspectJ的切面表达式和相关的定位解析机制</p>
</blockquote>
<h3 id="1-aspectj框架简介">1. AspectJ框架简介</h3>
<ul>
<li>定义了切面语法以及切面语法的解析机制</li>
<li>提供了强大的织入工具，由于Cglib只支持方法的织入，而AspectJ可以支持所有的织入，比如说属性或者构造函数</li>
</ul>
<p><strong>支持多种时机的织入，</strong></p>
<ul>
<li><strong>编译时织入（静态织入）</strong>：利用ajc编译器而不是Javac编译器，将源文件编译成class文件，并将切面逻辑织入到class文件</li>
<li><strong>编译后织入（静态织入）</strong>：先利用Javac将源文件编译成class文件，再利用ajc将切面逻辑织入到class文件</li>
<li><strong>类加载期织入（动态织入，Load Time Weaving）</strong>：利用java agent，在类加载的时候织入切面逻辑</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>
<p>相比于Spring性能更高，Spring是在类加载后才去生成一个动态代理的对象，而AspectJ是在编译期或者类加载时期完成切面逻辑的替换</p>
<blockquote>
<p>SpringAOP在容器Refresh时已经完成了加载，同时类是单例的，存储在缓存中，实际使用时性能差距并不大</p>
</blockquote>
</li>
</ul>
<p><strong>对于Spring而言仅仅使用了AspectJ的切面语法，并没用使用ajc编译器</strong></p>
<ul>
<li>避免增加用户的学习成本，即使用20%的学习成本满足80%的需求</li>
<li>只是默认不使用，如果想用ajc还是可以引入的</li>
<li>织入机制还是沿用了CGLIB以及JDK动态代理机制</li>
</ul>
<h3 id="2-环境配置">2. 环境配置</h3>
<p><strong>引入aspectjweaver的JAR包，以支持表达式的解析。</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>修改@Aspect注解</strong></p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Aspect {
    String pointcut();
}
</code></pre>
<h3 id="3-解析aspect表达式并定位被织入目标">3. 解析Aspect表达式并定位被织入目标</h3>
<p><strong>有两个关键的类</strong></p>
<ul>
<li><strong>PointcutParser</strong>：提供对表达式语法的支持，利用parsePointcutExpression方法，解析表达式，将返回一个PointcutExpression接口的实现类</li>
<li><strong>PointcutExpression接口</strong>：用于验证类或者方法是否符合表达式规则，couldMatchJoinPointsInType方法提供类的粗检查，只能校验within的表达式，其他的都会表达true；matchesMethodExecution方法提供对方法的精确检查</li>
</ul>
<pre><code class="language-java">public class PointcutLocator {
    //表达式解析器，判断类和方法是否符合表达式
    private PointcutExpression pointcutExpression;

    public PointcutLocator(String expression){
        //Pointcut解析器,支持所有AspectJ的所有语法树，解析String类型的Pointcut语法
        PointcutParser pointcutParser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingContextClassloaderForResolution(
                PointcutParser.getAllSupportedPointcutPrimitives()
        );
        this.pointcutExpression = pointcutParser.parsePointcutExpression(expression);
    }

    /**
     * 判断传入的Class对象是否符合Pointcut表达式（初筛）
     * @param targetClass 目标类
     * @return 是否匹配
     */
    public boolean roughMatches(Class&lt;?&gt; targetClass){
        //只能校验within的表达式，其他的都会表达true
        return pointcutExpression.couldMatchJoinPointsInType(targetClass);
    }

    /**
     * 判断传入的Method对象是否符合Pointcut表达式（精确筛选）
     * @param method 目标方法
     * @return 是否匹配
     */
    public boolean accurateMatches(Method method){
        ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);
        //判断是否完全匹配
        return shadowMatch.alwaysMatches();
    }
}
</code></pre>
<p><strong>修改AspectInfo类，提供对表达式解析的支持</strong></p>
<pre><code class="language-java">@AllArgsConstructor
@Getter
@ToString
public class AspectInfo {
    //Aspect的执行顺序
    private  int OrderIndex;
    //Aspect
    private  DefaultAspect defaultAspect;

    private PointcutLocator pointcutLocator;

}
</code></pre>
<p><strong>修改doAop的逻辑以支持表达式</strong></p>
<pre><code class="language-java">public class AspectWeaver {
    private BeanContainer beanContainer;

    public AspectWeaver() {
        beanContainer = BeanContainer.getInstance();
    }

    public void doAop() {
        //1.获取所有的切面类
        Set&lt;Class&lt;?&gt;&gt; aspectSet = beanContainer.getClassesByAnnotation(Aspect.class);
        if (ValidationUtil.isEmpty(aspectSet)) {
            return;
        }
        //2.拼装AspectInfoList
        List&lt;AspectInfo&gt; aspectInfoList = packAspectInfoList(aspectSet);
        //3.遍历容器的所有类
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClasses();
        for (Class&lt;?&gt; targetClass : classSet) {
            //排除切面类本身
            if(!targetClass.isAnnotationPresent(Aspect.class)){
                //4.粗筛符合条件的切面
                List&lt;AspectInfo&gt; roughMatchedAspectList = collectRoughMatchedAspectListForSpecificClass(aspectInfoList,targetClass);
                //5.尝试进行Aspect织入
                wrapIfNecessary(roughMatchedAspectList,targetClass);
            }
        }


    }

    /**
     *
     * @param roughMatchedAspectList
     * @param targetClass
     */
    private void wrapIfNecessary(List&lt;AspectInfo&gt; roughMatchedAspectList, Class&lt;?&gt; targetClass) {
        if(!ValidationUtil.isEmpty(roughMatchedAspectList)){
            //创建动态代理对象
            AspectListExecutor aspectListExecutor = new AspectListExecutor(targetClass,roughMatchedAspectList);
            Object proxy = ProxyCreator.createProxy(targetClass, aspectListExecutor);
            beanContainer.addBean(targetClass,proxy);
        }
    }

    /**
     * 粗筛选出存在对应切点的切面逻辑
     * @param aspectInfoList 切面集合
     * @param targetClass 目标类
     * @return
     */
    private List&lt;AspectInfo&gt; collectRoughMatchedAspectListForSpecificClass(List&lt;AspectInfo&gt; aspectInfoList, Class&lt;?&gt; targetClass) {
        List&lt;AspectInfo&gt; roughMatchedAspectList = new ArrayList&lt;&gt;();
        for (AspectInfo aspectInfo : aspectInfoList) {
            //粗筛
            if (aspectInfo.getPointcutLocator().roughMatches(targetClass)){
                roughMatchedAspectList.add(aspectInfo);
            }
        }
        return roughMatchedAspectList;
    }

    /**
     * 验证被@Aspect注解标记的类是否符合要求
     * 如果符合要求，取出所需的Pointcut表达式，Order值以及对应的Bean
     * @param aspectSet
     * @return
     */
    private List&lt;AspectInfo&gt; packAspectInfoList(Set&lt;Class&lt;?&gt;&gt; aspectSet) {
        List&lt;AspectInfo&gt; aspectInfos = new ArrayList&lt;&gt;();
        for (Class&lt;?&gt; aspectClass : aspectSet) {
            if (verifyAspect(aspectClass)){
                Order orderTag = aspectClass.getAnnotation(Order.class);
                Aspect aspectTag = aspectClass.getAnnotation(Aspect.class);
                DefaultAspect defaultAspect = (DefaultAspect) beanContainer.getBean(aspectClass);
                //初始化表达式定位器
                PointcutLocator pointcutLocator = new PointcutLocator(aspectTag.pointcut());
                AspectInfo aspectInfo = new AspectInfo(orderTag.value(),defaultAspect,pointcutLocator);
                aspectInfos.add(aspectInfo);
            }else {
                //不遵守规范则直接抛出异常
                throw new RuntimeException(&quot;@Aspect and @Order must be added to the Aspect class, and Aspect class must extend from DefaultAspect&quot;);
            }
        }
        return aspectInfos;
    }

    //框架中一定要遵守给Aspect类添加@Aspect和@Order标签的规范，同时，必须继承自DefaultAspect.class
    //此外，@Aspect的属性值不能是它本身
    private boolean verifyAspect(Class&lt;?&gt; aspectClass) {
        return aspectClass.isAnnotationPresent(Aspect.class) &amp;&amp;
                aspectClass.isAnnotationPresent(Order.class) &amp;&amp;
                DefaultAspect.class.isAssignableFrom(aspectClass);
    }

}
</code></pre>
<p><strong>在织入之前做一次精确的判断</strong></p>
<pre><code class="language-java">@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    Object returnValue = null;
    //对代理类进行精筛
    collectAccurateMatchedAspectList(method);
    if (ValidationUtil.isEmpty(sortedAspectInfos)){
        return methodProxy.invokeSuper(proxy,args);
    }
    try {
        //1.按照order的顺序升序执行完所有Aspect的before方法
        invokeBeforeAdvices(method,args);
        //2.执行被代理类的方法
        returnValue = methodProxy.invokeSuper(proxy,args);
        //3.如果被代理方法正常返回，则按照order的顺序降序执行完所有Aspect的afterReturning方法
        returnValue = invokeAfterReturningAdvice(method,args,returnValue);
    } catch (Throwable throwable) {
        //4.如果被代理方法抛出异常，则按照order的顺序降序执行完所有Aspect的afterThrowing方法
        invokeAfterThrowingAdvices(method,args,throwable);
    }
    return returnValue;
}

    /**
     * 对代理类进行精筛
     * @param method
     */
    private void collectAccurateMatchedAspectList(Method method) {
        if (!ValidationUtil.isEmpty(sortedAspectInfos)){
            Iterator&lt;AspectInfo&gt; iterator = sortedAspectInfos.iterator();
            while (iterator.hasNext()){
                AspectInfo aspectInfo = iterator.next();
                if (!aspectInfo.getPointcutLocator().accurateMatches(method)){
                    iterator.remove();
                }
            }
        }
    }
</code></pre>
]]></content>
    </entry>
</feed>