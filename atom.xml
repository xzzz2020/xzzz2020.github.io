<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-06-26T01:30:35.849Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[贪心策略]]></title>
        <id>https://xzzz2020.github.io/post/-Soxdr6Ou/</id>
        <link href="https://xzzz2020.github.io/post/-Soxdr6Ou/">
        </link>
        <updated>2020-06-25T13:55:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E8%B4%AA%E5%BF%83%E7%9A%84%E7%89%B9%E7%82%B9">贪心的特点</a></li>
<li><a href="#%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90">实际例子</a>
<ul>
<li><a href="#%E7%A1%AC%E5%B8%81%E6%94%AF%E4%BB%98%E9%97%AE%E9%A2%98">硬币支付问题</a></li>
<li><a href="#poj_1700">POJ_1700</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">区间调度问题（二维数组排序）</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9">区间选点</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98">区间覆盖问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="简介">简介</h2>
<ul>
<li>无论是DFS还是BFS都是遍历解空间</li>
<li>动态规划和贪心算法都是一种递推算法，运用<strong>局部最优解</strong>来推到全局最优解</li>
<li>是对<strong>遍历解空间</strong>的一种优化</li>
<li>当问题具有<strong>最优子结构</strong>的时候，可以用动归，而贪心是动归的特例。</li>
</ul>
<h2 id="贪心的特点">贪心的特点</h2>
<ul>
<li><strong>只看眼前</strong>。根据某种规则，不断的选取当前策略，最终找到最优解</li>
<li><strong>主要需要不断的举例，去猜测出一个贪心策略。</strong></li>
</ul>
<p><strong>注意</strong>：当前最优的未必是整体最优</p>
<h2 id="实际例子">实际例子</h2>
<h3 id="硬币支付问题">硬币支付问题</h3>
<blockquote>
<p>硬币问题<br>
有1元,5元,10元,50元,100元,500元的硬币各c1,c5,c10,c50,c100,c500枚.<br>
现在要用这些硬币来支付A元,最少需要多少枚硬币?<br>
假定本题至少存在一种支付方案.<br>
0≤ci≤10^9<br>
0≤A≤10^9<br>
输入:<br>
第一行有六个数字,分别代表从小到大6种面值的硬币的个数<br>
第二行为A,代表需支付的A元<br>
样例:<br>
输入<br>
3 2 1 3 0 2</p>
</blockquote>
<blockquote>
<p>620<br>
输出<br>
6</p>
</blockquote>
<pre><code class="language-java"> /**
  * 尽量先用大面值,因为不用大面值,将使用更多的小面值硬币,一定得不到最优解
  */
public class Main {
    static int [] cin = new int[6];

    public static void main(String[] args) throws InterruptedException {
        Scanner scanner = new Scanner(System.in);

        int money ;
        int ans = 0;
        for (int i = 0; i &lt; 6; i++) {
            cin[i] = scanner.nextInt();
        }
        int [] coins = new int[]{1,5,10,50,100,500};
        money = scanner.nextInt();
        for (int i = 5; i &gt;=0; i--) {
            int x = money/coins[i];//金额有多少个coins[i]
            int t = Math.min(cin[i],x);//当前面值的硬币有cin[i]个
            ans += t;
            money -= t*coins[i];
        }
        System.out.println(ans);
    }

}
</code></pre>
<h3 id="poj_1700">POJ_1700</h3>
<blockquote>
<p>N个人过河，船每次最多只能坐两个人，船载每个人过河的所需时间不同，问最快的过河时间。</p>
<p>有N个人要渡河，但是只有一艘船，船上每次最多只能载两个人，渡河的速度由两个人中较慢的那个决定，小船来回载人直到所有人都渡河，求最短的渡河时间。</p>
<p>输入的每种情况的第一行包含N，第二行包含N个整数，表示每个人过河的时间。每个案例前面都有一个空行。不会有超过1000人，没有人会花超过100秒的时间穿越。</p>
<p>对于每个测试用例，打印一行，其中包含所有N个人过河所需的总秒数。</p>
<p>Sample Input<br>
1<br>
4<br>
1 2 5 10<br>
Sample Output<br>
17</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/20200201205225396.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>可以发现，4个人以上时，前四轮都是将最慢的两个渡过河。</strong></p>
<pre><code class="language-java">public class Case02_POJ_1700 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int i = 0; i &lt; T; i++) {
            int n = sc.nextInt();
            int[] speed = new int[n];
            for (int j = 0; j &lt; n; j++) {
                speed[j] = sc.nextInt();
            }
            //排序
            Arrays.sort(speed);
            f(n, speed);
        }
    }

    /**
     * speed已经排序
     *
     * @param n
     * @param speed
     */
    private static void f(int n, int[] speed) {
        int left = n;
        int ans = 0;
        while (left &gt; 0) {
            if (left == 1) {//只有1人
                ans += speed[0];
                break;
            } else if (left == 2) {//只有两人
                ans += speed[1];
                break;
            } else if (left == 3) {//有三人
                ans += speed[2] + speed[0] + speed[1];
                break;
            } else {//通过两种策略来回两趟，渡过最慢的两个人
                //1，2出发，1返回，最后两名出发，2返回
                int s1 = speed[1] + speed[0] + speed[left - 1] + speed[1];
                //1，3出发，1返回，1，4出发，1返回，1，2过河
                int s2 = speed[left - 1] + speed[left - 2] + 2 * speed[0];
                ans += Math.min(s1, s2);
                left -= 2;//左侧是渡河的起点，left代表左侧的剩余人数
            }
        }
        System.out.println(ans);
    }
</code></pre>
<h3 id="区间调度问题二维数组排序">区间调度问题（二维数组排序）</h3>
<blockquote>
<p>有n项工作,每项工作分别在si时间开始,在ti时间结束.<br>
对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.<br>
此外,参与工作的时间段不能重复(即使是开始的瞬间和结束的瞬间的重叠也是不允许的).<br>
你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?<br>
1≤n≤100000<br>
1≤si≤ti≤10^9<br>
输入:<br>
第一行:n<br>
第二行:n个整数空格隔开,代表n个工作的开始时间<br>
第三行:n个整数空格隔开,代表n个工作的结束时间<br>
样例输入:<br>
5<br>
1 3 1 6 8<br>
3 5 2 9 10<br>
样例输出:<br>
3<br>
说明:选取工作1,3,5</p>
</blockquote>
<p><strong>面向对象的排序思想</strong>：</p>
<ul>
<li>将不同的维度，比如说身高、体重、年龄，进行打包。</li>
<li>将对象的一些操作打包到一起，操作可以直接影响数据。</li>
</ul>
<pre><code class="language-java">//贪心策略：选择结束时间最早的
public class Case03_区间调度问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] s = new int[n];
        int[] t = new int[n];
        //建立开始时间和终止时间的打包对象
        Job[] jobs = new Job[n];
        for (int i = 0; i &lt; n; i++) {
            s[i] = sc.nextInt();
        }
        for (int i = 0; i &lt; n; i++) {
            t[i] = sc.nextInt();
        }
        for (int i = 0; i &lt; n; i++) {
            jobs[i] = new Job(s[i], t[i]);
        }

        Arrays.sort(jobs);
        //此时数据按照终止时间和开始时间由小到大排序
        int res = f(n, jobs);
        System.out.println(res);
    }

    private static int f(int n, Job[] jobs) {
        int cnt = 1;
        int y = jobs[0].t;//先选择最小的终止时间
        for (int i = 0; i &lt; n; i++) {//选择下一个终止时间最早的
            if (jobs[i].s &gt; y) {
                cnt++;
                y = jobs[i].t;
            }
        }
        return cnt;
    }

    /**
     * 必须实现排序规则
     */
    private static class Job implements Comparable&lt;Job&gt; {
        int s;
        int t;

        public Job(int s, int t) {
            this.s = s;
            this.t = t;
        }
		
        //排序规则
        @Override
        public int compareTo(Job other) {
            int x = this.t - other.t;
            if (x == 0)//如果终止的时间相同，则比较开始时间
                return this.s - other.s;
            else
                return x;
        }
    }
}
</code></pre>
<h3 id="区间选点">区间选点</h3>
<blockquote>
<p>题意:有n个如下形式的条件:<br>
ai bi ci,表示在区间[ai, bi]内至少要选择ci个整数点.（不同区间内含的点可以是同一个）<br>
问你满足n个条件的情况下,最少需要选多少个点?<br>
Sample Input<br>
5<br>
3 7 3<br>
8 10 3<br>
6 8 1<br>
1 3 1<br>
10 11 1<br>
Sample Output<br>
6</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625174049315.png" alt="image-20200625174049315" style="zoom: 80%;" />
<pre><code class="language-java">public class Case04_区间选点问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Interval[] intervals = new Interval[n];
        for (int i = 0; i &lt; n; i++) {
            intervals[i] = new Interval(sc.nextInt(), sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(intervals);//按区间右端点排序

        int max = intervals[n - 1].t;//右端最大值
        int[] axis = new int[max + 1];//标记数轴上的点是否已经被选中
        for (int i = 0; i &lt; n; i++) {
            //1.查阅区间中有多少个点
            int s = intervals[i].s;//起点
            int t = intervals[i].t;//终点
            int cnt = sum(axis, s, t);//找到这个区间已经选点的数量，sums[t] - sums[s - 1];//效率低
            //  2.如果不够，从区间右端开始标记，遇标记过的就跳过
            intervals[i].c -= cnt;//需要新增的点的数量
            while (intervals[i].c &gt; 0) {
                if (axis[t] == 0) {//从区间终点开始选点
                    axis[t] = 1;
                    // updateSums(t,sums);//更新前缀和
                    intervals[i].c--;//进一步减少需要新增的点的数量
                    t--;
                } else {//这个点已经被选过了，不选择重复的点
                    t--;
                }
            }
        }
        System.out.println(sum(axis, 0, max));
    }

    /**
     * 统计数轴axis上s-t区间已经有多少个点被选中
     * @param axis
     * @param s
     * @param t
     * @return
     */
    private static int sum(int[] axis, int s, int t) {
        int sum = 0;
        for (int i = s; i &lt;= t; i++) {
            sum += axis[i];
        }
        return sum;
    }
    
    private static class Interval implements Comparable&lt;Interval&gt; {
        int s;//起点
        int t;//终点
        int c;//区间需求

        public Interval(int s, int t, int c) {
            this.s = s;
            this.t = t;
            this.c = c;
        }
		
        //按照终点由小到大排序
        @Override
        public int compareTo(Interval other) {
            int x = this.t - other.t;
            if (x == 0)
                return this.s - other.s;
            else
                return x;
        }
    }

}
</code></pre>
<h3 id="区间覆盖问题">区间覆盖问题</h3>
<p><code>如果给定一堆线段，给定一个区间，看最少需要几个线段才能完全覆盖这个区间。</code></p>
<p><strong>解决思路</strong>：</p>
<ul>
<li>
<p>设区间起点为start，终点为end，所需线段数目为ans</p>
</li>
<li>
<p>首先线段中的终点，小于区间的起点，则该线段肯定无法覆盖</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625213133071.png" alt="image-20200625213133071" style="zoom:67%;" />
</li>
<li>
<p>同理如果区间的终点，大于线段的起点，则也一定无法覆盖</p>
</li>
<li>
<p>接着就需要<strong>保存线段终点大于等于区间起点且线段起点小于等于区间终点的线段</strong></p>
</li>
<li>
<p>对上面的线段<strong>根据起点的大小排序</strong></p>
</li>
<li>
<p>接着此时的寻找线段起点小于start同时终点最远的线段，并该终点设置为新的start，将ans+1<br>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625213909588.png" alt="image-20200625213909588" style="zoom: 67%;" /></p>
</li>
<li>
<p>重复上述步骤直到找到终点大于end的</p>
</li>
</ul>
<blockquote>
<p>题目：给出n条线段，以及最大长度m，问最少需要多少条才能覆盖1-m这个区间，当无法全部覆盖的时候输出-1</p>
<p>Sample Input<br>
3 10<br>
1 7<br>
3 6<br>
6 10<br>
Sample Output<br>
2</p>
</blockquote>
<pre><code class="language-java">public class Case05_区间覆盖问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int T = sc.nextInt();
        Job[] jobs = new Job[N];
        for (int i = 0; i &lt; N; i++) {
            jobs[i] = new Job(sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(jobs);
        int start = 1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右
        int end = 1;
        int ans = 1;
        for (int i = 0; i &lt; N; i++) {
            int s = jobs[i].s;
            int t = jobs[i].t;
            if (i == 0 &amp;&amp; s &gt; 1) break;//第一个起点比区间起点小，则一定无法覆盖

            if (s &lt;= start) {//当前区间有可能覆盖start
                end = Math.max(t, end);//寻找起点小于start同时终点最远的线段
            } else {//说明已经没有线段再比start小，开始下一个区间
                ans++;//上一个目标覆盖已经达成，计数加1
                start = end + 1;//更新起点，设置一个新的覆盖目标
                if (s &lt;= start) {
                    end = Math.max(t, end);
                } else {//当前的起点如果比end大，则后面的都一定大，无法继续覆盖
                    break;
                }
            }
            if (end &gt;= T) {//当前的end超越了线段的右侧，则不需要继续判断了
                break;
            }
        }
        if (end &lt; T)//如果没有覆盖
            System.out.println(-1);
        else
            System.out.println(ans);
    }

    private static class Job implements Comparable&lt;Job&gt; {
        int s;
        int t;

        public Job(int s, int t) {
            this.s = s;
            this.t = t;
        }

        /**按照区间起点排序*/
        @Override
        public int compareTo(Job other) {
            int x = this.s - other.s;
            if (x == 0)
                return this.t - other.t;
            else
                return x;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第七章操作系统接口]]></title>
        <id>https://xzzz2020.github.io/post/KpZgrFFRY/</id>
        <link href="https://xzzz2020.github.io/post/KpZgrFFRY/">
        </link>
        <updated>2020-06-23T13:03:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">命令接口实现</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="命令接口实现">命令接口实现</h2>
<p><strong>分为下图所示的两个模块实现</strong>：</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205644062.png" alt="image-20200623205644062" style="zoom: 50%;" />
<p><strong>终端处理程序，接收键盘的输入，并将命令执行的结果回显在显示器上，功能包括</strong>：</p>
<ul>
<li>字符接收</li>
<li>字符缓冲</li>
<li>回送显示</li>
<li>屏幕编辑</li>
<li>特殊字符的处理</li>
</ul>
<p><strong>命令解释程序，从.输入缓冲区中取出数据，然后识别命令、执行命令,最后把结果放到输出缓冲区中。</strong></p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205922735.png" alt="image-20200623205922735" style="zoom: 80%;" />
<h2 id="系统调用">系统调用</h2>
<p><strong>什么是系统调用？</strong></p>
<ul>
<li>系统调用是操作系统提供给应用程序的一-种过程调用，保护操作系统程序不被用户，<br>
程序破坏。</li>
<li>系统调用是操作系统的程序接口。</li>
</ul>
<p><strong>系统调用与一般的过程调用不同</strong>：</p>
<ul>
<li>系统调用处理程序运行在内核态，而一般的过程调用运行在用户态;</li>
<li>系统调用需要借助软中断实现，而- -般过程调用不需要;</li>
<li>系统调用从内核返回时，要进行决策是否运行调度算法，而一般过程调用不需要;</li>
<li>系统调用可以嵌套调用，但调用深度有一定的限制，而一般过程调用没有深度限制;</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第六章文件管理]]></title>
        <id>https://xzzz2020.github.io/post/7ZUXXwU1m/</id>
        <link href="https://xzzz2020.github.io/post/7ZUXXwU1m/">
        </link>
        <updated>2020-06-23T12:52:11.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">文件及其逻辑结构</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6">顺序文件</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6">索引文件</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6">索引顺序文件</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6%E5%92%8C%E5%93%88%E5%B8%8C%E6%96%87%E4%BB%B6">直接文件和哈希文件</a></li>
</ul>
</li>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E8%A6%81%E6%B1%82">目录的要求</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">文件的物理结构（***）</a>
<ul>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">连续分配</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D">链接分配</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D">索引分配</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86">空闲空间管理</a>
<ul>
<li><a href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95">空闲表法</a></li>
<li><a href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95">空闲链表法</a></li>
<li><a href="#%E4%BD%8D%E8%A7%86%E5%9B%BE%E6%B3%95">位视图法（***）</a></li>
<li><a href="#%E6%88%90%E7%BB%84%E9%93%BE%E8%A1%A8%E6%B3%95">成组链表法</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B">文件系统软件模型</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7">对象及其属性</a></li>
<li><a href="#%E5%AF%B9%E5%AF%B9%E8%B1%A1%E6%93%8D%E7%BA%B5%E5%92%8C%E7%AE%A1%E7%90%86%E7%9A%84%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88">对对象操纵和管理的软件集合</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">文件系统接口</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB">文件共享</a></li>
<li><a href="#%E8%AF%BE%E6%9C%AC%E4%B9%A0%E9%A2%98">课本习题</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="文件及其逻辑结构">文件及其逻辑结构</h2>
<p><strong>文件概念</strong>：由创建者所定义、具有文件名的一组相关元素的集合，可分为结构文件和无结构文件两种。</p>
<p><strong>文件逻辑结构概念</strong>：文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性，又称为文件组织。</p>
<h3 id="顺序文件">顺序文件</h3>
<ul>
<li>顺序文件由数据依次排列组成。</li>
<li>顺序文件可分为串结构文件和有序结构文件。、
<ul>
<li>串结构文件按记录存入文件的时间先后排列。</li>
<li>有序结构按关键字值大小排列。</li>
</ul>
</li>
<li>顺序文件又分为定长记录文件和变长记录文件。</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623182042483.png" alt="image-20200623182042483" style="zoom:80%;" />
<h3 id="索引文件">索引文件</h3>
<p>若顺序文件是<strong>变长记录文件</strong>，可按记录号或关键字为每条记录建立一个索引文件，存储记录在顺序文件中的位置信息。</p>
<p>索引文件是定长的文件。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623182705177.png" alt="image-20200623182705177" style="zoom: 80%;" />
<h3 id="索引顺序文件">索引顺序文件</h3>
<ul>
<li><strong>索引文件太长会要求更多的I/O次数，直接影响了文件的读/写效率。</strong></li>
<li>索引顺序文件先<strong>对顺序文件按记录号或关键字排序分组</strong>，然后对组的第一个记录索引。</li>
</ul>
<h3 id="直接文件和哈希文件">直接文件和哈希文件</h3>
<ul>
<li>
<p><strong>直接文件</strong>是一种特殊的哈希文件,记录关键字值决定了记录在顺序文件中的位置。</p>
</li>
<li>
<p><strong>哈希文件</strong>则由关键字值通过哈希函数计算获得记录在顺序文件中的位置。</p>
</li>
</ul>
<h2 id="目录的要求">目录的要求</h2>
<ol>
<li>实现“按名存取”。</li>
<li>提高对目录的检索速度。</li>
<li>文件共享。</li>
<li>允许文件重名。</li>
</ol>
<h2 id="文件的物理结构">文件的物理结构（***）</h2>
<p><strong>概念</strong>：文件的物理结构指文件的外存分配组织管理方式</p>
<blockquote>
<p>文件占用的外存空间以块或簇等逻辑单位计量</p>
</blockquote>
<h3 id="连续分配">连续分配</h3>
<blockquote>
<p>文件数据连续存储可以提高存取速度，但限制了文件动态增长。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623195227779.png" alt="image-20200623195227779" style="zoom: 80%;" />
<h3 id="链接分配">链接分配</h3>
<blockquote>
<p>隐式链接，链接指针包含在给文件分配的块中，目录中仅包含文件的起始块和结束块(或长度)。</p>
<ul>
<li>链接指针分散在多个块中，不利于安全措施的实现</li>
</ul>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623200229916.png" alt="image-20200623200229916" style="zoom:67%;" />
<blockquote>
<p>显示链接：将所有的链接信息提取放到文件分配表中</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623200341171.png" alt="image-20200623200341171" style="zoom: 67%;" />
<h3 id="索引分配">索引分配</h3>
<ul>
<li>
<p>在链接分配中，文件块链接指针离散存储,造成文件占用块号解析效率不高。</p>
</li>
<li>
<p>索引分配方式就是将块号集中存放。</p>
</li>
</ul>
<p><strong>单级索引（一级索引）</strong></p>
<p>用一个块来记录文件占用的所有块号,我们称之为索引块</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201033041.png" alt="image-20200623201033041" style="zoom:67%;" />
<p><strong>二级索引</strong></p>
<blockquote>
<p>因为一个索引块的大小有限，但是多级索引需要检索多次，会影响性能</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201015773.png" alt="image-20200623201015773" style="zoom:67%;" />
<p><strong>混合索引(直接地址、-级索引、两级索引、三级索引方式)</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201148989.png" alt="image-20200623201148989" style="zoom:80%;" />
<h2 id="空闲空间管理">空闲空间管理</h2>
<h3 id="空闲表法">空闲表法</h3>
<ul>
<li>若干连续的空闲块组合成一个空闲区。</li>
<li>空闲表法将所有的空闲区记录在一张表里， 包括项号、起始空闲块号、空闲块数等。</li>
</ul>
<h3 id="空闲链表法">空闲链表法</h3>
<p>空闲链表法是以空闲块或空闲区为结点构成一个链表结构。</p>
<h3 id="位视图法">位视图法（***）</h3>
<blockquote>
<p>用一位二进制表示，1代表已分配，0代表空闲。</p>
</blockquote>
<ul>
<li>块号从0开始，BitsOfLine 是一行有多少位，如char类型为8位</li>
<li>block = line X BitsOfLine + column</li>
<li>line = block/BitsOfLine</li>
<li>column = block%BitsOfLine</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201428546.png" alt="image-20200623201428546" style="zoom: 80%;" />
<h3 id="成组链表法">成组链表法</h3>
<blockquote>
<p>用树的结构表示</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201544463.png" alt="image-20200623201544463" loading="lazy"></figure>
<h2 id="文件系统软件模型">文件系统软件模型</h2>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623202429515.png" alt="image-20200623202429515" style="zoom:67%;" />
<h3 id="对象及其属性">对象及其属性</h3>
<ul>
<li>文件系统对象</li>
<li>超级块对象</li>
<li>文件</li>
<li>目录</li>
<li>索引结点</li>
<li>数据块</li>
</ul>
<h3 id="对对象操纵和管理的软件集合">对对象操纵和管理的软件集合</h3>
<ul>
<li>对文件的读/写</li>
<li>对目录文件的读/写</li>
<li>对磁盘空闲空间的管理</li>
<li>将文件的逻辑地址转换为物理地址</li>
<li>对文件的保护与共享;</li>
</ul>
<h3 id="文件系统接口">文件系统接口</h3>
<ul>
<li>基于文件名(路径)、文件逻辑地址(相对于文件起始地址的偏移)给用户提供各种操作。</li>
<li>常用的文件操作有，创建文件、删除文件、读文件、写文件、设置文件读1写位置、打开文件、关闭文件等。</li>
</ul>
<h2 id="文件共享">文件共享</h2>
<ul>
<li>基于索引结点的共享方式</li>
<li>基于符号链的共享方式</li>
</ul>
<h2 id="课本习题">课本习题</h2>
<ol>
<li>
<p><strong>11 在 UNIX 中，如果一个盘块的大小为   1KB ，每个盘块号占                4 个字节，即每块可放                256个地址。请转换下列文件的字节偏移量为物理地址。</strong></p>
<p><strong>⑴ 9999 ； ⑵ 18000 ；⑶ 420000</strong></p>
<p>答：首先将逻辑文件的字节偏移量转换为逻辑块号和块内偏移量   ,就是将 [字节偏移量 ]/[ 盘块大小 ]，商为逻辑块号，<code>余数是块内偏移量</code>。在  FCB 中，第 0-9 个地址为直接地址，第  10 个为一次间接地址，第 11 个地址为二次间接地址，第 12 个地址为三次间接地址。</p>
<p>再将文件的逻辑块号转换为物理块号。使用多重索引结构，在索引节点中根据逻辑块号通过直接索引或间接索引找到对应的物理块号。</p>
<ul>
<li>
<p>9999/1024=9余 783 ，则逻辑块号为9 ，直接索引第9个地址得到物理块号，块内偏移地址为 783 。</p>
</li>
<li>
<p>18000/1024=17  余 592 ，则逻辑块号为10&lt;17&lt;10+256，通过一次间接索引在第10个地址可得到物理块号，块内偏移地址为592 。</p>
</li>
<li>
<p>420000/1024=410 余160 ，则逻辑块号为 10+256&lt;410 ，通过二次间接索引在第 11 个地址可得到一次间址，再由此得到二次间址，再找到物理块号，其块内偏移地址160 。</p>
</li>
</ul>
</li>
<li>
<p><strong>某操作系统磁盘文件空间共   500 块，若用字长为 32 位的位示图管理磁盘空间，试问：</strong></p>
<p><strong>（1）位示图需要多少字？</strong></p>
<p><strong>（2）第 i 字第 j 位对应的块号是多少？</strong></p>
<p><strong>（3）给出申请 /归还一块的工作流程。</strong></p>
<p>答：</p>
<p>（1）位示图需要的字数计算：  INT （ 500/32 ） =16个字。</p>
<p>（2）块号 b=(i-1)*32+j</p>
<p>（3 ）申请的过程：顺序扫描位示图、找到空闲块并分配、修改位示图map[i,j]=1 。归还的过程：找到回收盘块在位示图中的行和列，修改位示图map[i,j]=0 。</p>
</li>
</ol>
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194032746.png" alt="image-20200623194032746" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194102600.png" alt="image-20200623194102600" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194242927.png" alt="image-20200623194242927" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205009523.png" alt="image-20200623205009523" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205103341.png" alt="image-20200623205103341" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第五章设备管理]]></title>
        <id>https://xzzz2020.github.io/post/mxhiqNcFj/</id>
        <link href="https://xzzz2020.github.io/post/mxhiqNcFj/">
        </link>
        <updated>2020-06-23T09:01:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB">设备分类</a></li>
<li><a href="#io%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">I/O设备控制方式</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">程序查询方式</a></li>
<li><a href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">通道控制方式</a></li>
<li><a href="#dma%E6%96%B9%E5%BC%8F%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">DMA方式（直接存储器访问方式）</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F">中断方式</a></li>
</ul>
</li>
<li><a href="#io%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%8A%9F%E8%83%BD">I/O系统的软件模型及功能</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6">设备独立性软件</a></li>
<li><a href="#spooling">Spooling</a></li>
<li><a href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86">缓冲管理</a>
<ul>
<li><a href="#%E5%9B%9B%E7%A7%8D%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5">四种缓冲策略</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D">设备分配</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BC%9A%E8%AE%A1%E7%AE%97">磁盘调度算法（会计算***）</a>
<ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1">先来先服务</a></li>
<li><a href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4">最短寻道时间</a></li>
<li><a href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">扫描算法（电梯调度算法）</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95">循环扫描算法</a></li>
</ul>
</li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="设备分类">设备分类</h2>
<p><strong>按信息交换单位分类</strong>：</p>
<ul>
<li><strong>块设备</strong>：数据传送以块为单位，传输速率较高，可寻址; I/O访问常采用DMA方式。</li>
<li><strong>字符设备</strong>：数据传送以字符为单位，传输速率较低，不可寻址; I/0访问常采用中断方式。</li>
</ul>
<p><strong>按设备的的共享属性分类</strong>：</p>
<ul>
<li><strong>独占设备</strong>：一段时间内只允许一个进程使用，属于临界资源。</li>
<li><strong>共享设备</strong>：在一-段时间，允许多个进程同时访问，共享设备必须是<code>可寻址</code>和<code>可随机访问</code>的设备。</li>
<li><strong>虚拟设备</strong>：将一台独占设备变换为若干个逻辑设备,如虚拟存储器、虚拟终端。</li>
</ul>
<h2 id="io设备控制方式">I/O设备控制方式</h2>
<h3 id="程序查询方式">程序查询方式</h3>
<blockquote>
<p>不停的检查设备的状态，造成CPU资源的浪费，优点是比较简单</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623154822643.png" alt="image-20200623154822643" style="zoom: 80%;" />
<h3 id="通道控制方式">通道控制方式</h3>
<p><strong>通道程序由一系列通道指令构成，包含以下信息</strong>：</p>
<ul>
<li><strong>操作码</strong>：读、写、控制等;</li>
<li><strong>内存地址</strong>：读写内存的始址;</li>
<li><strong>计数</strong>：指令的读写字节数;</li>
</ul>
<p><strong>通道程序示例</strong>：</p>
<ul>
<li>
<p>通道程序结束位P，1表示通道指令是通道程序的最后一条指令。</p>
</li>
<li>
<p>记录结束位Record, 0表示通道指令与下一条通道指令所处理的数据块属于同- -个记录，1表示通道指令所处理的数据块是记录的最后一块数据。</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160021122.png" alt="image-20200623160021122" style="zoom:80%;" />
<h3 id="dma方式直接存储器访问方式">DMA方式（直接存储器访问方式）</h3>
<blockquote>
<p>DMA方式以<strong>块</strong>为单位传送数据，仅在数据块传送前和传送结束时,才需要处理机干预。</p>
</blockquote>
<p><strong>包含四类寄存器</strong>：</p>
<ul>
<li><strong>数据寄存器</strong>：缓存从设备到内存，或从内存到设备的数据;</li>
<li><strong>数据计数寄存器</strong>：存储要读/写的字节数;</li>
<li><strong>内存地址寄存器</strong>：存放内存起始地址; .</li>
<li><strong>控制/状态寄存器</strong>：接收处理机发来的1/O命令或有关控制信息，以及设备发送的状态信息;</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623155319789.png" alt="image-20200623155319789" style="zoom:80%;" />
<h3 id="中断方式">中断方式</h3>
<blockquote>
<p>驱动程序向处理机发出启动I/O设备指令后阻塞，处理机转向处理其它工作。</p>
<p>设备完成数据传送后，I/O控制器向处理机发送中断请求。处理机收到中断请求信号转向中断处理程序，中断处理程序将数据寄存器中的数据送到指定内存单元，并唤醒阻塞进程。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623155132894.png" alt="image-20200623155132894" style="zoom:80%;" />
<h2 id="io系统的软件模型及功能">I/O系统的软件模型及功能</h2>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160245567.png" alt="image-20200623160245567" style="zoom:67%;" />
<h2 id="设备独立性软件">设备独立性软件</h2>
<ul>
<li>
<p>设备独立性指应用程序独立于具体使用的物理设备。</p>
</li>
<li>
<p>为了实现设备独立性而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>概念，在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。</p>
</li>
</ul>
<p><strong>设备独立性软件的功能</strong>：</p>
<ol>
<li>
<p>向用户层(或文件层)软件提供统一接口。</p>
</li>
<li>
<p>执行设备的公有操作，如<code>逻辑设备名映射为物理设备名</code>、独立设备的分配与回收、对设备进行保护、缓冲管理、差错控制、提供独立于物理设备的逻辑块。</p>
</li>
</ol>
<p><strong>设备独立性实现</strong>：构建一个逻辑设备表，实现逻辑设备名到物理设备名的映射</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623161100037.png" alt="image-20200623161100037" style="zoom:67%;" />
<h2 id="spooling">Spooling</h2>
<blockquote>
<p>在联机情况下<strong>实现的同时输入/输出操作</strong>称为Spooling，或称为假脱机操作,即数据的输入、输出不再由外围控制机管理,而<strong>改为进程执行</strong>。</p>
</blockquote>
<p><strong>Spooling系统的组成</strong>：</p>
<ul>
<li>输入进程SPi和输出进程SPo</li>
<li>输入和输出缓冲区</li>
<li>输入和输出井</li>
</ul>
<p><strong>Spooling系统应用--共享打印机</strong>：</p>
<ul>
<li>将所有打印请求挂在打印机请求队列上。</li>
<li>把打印数据放入到输出井上。</li>
<li>打印机驱动进程依次完成打印机请求队列上的任务。</li>
</ul>
<p><strong>Spooling系统的特点</strong>：</p>
<ul>
<li>
<p>提高了I/O速度。</p>
</li>
<li>
<p>将独占设备改造成共享设备。</p>
</li>
<li>
<p>实现了设备的虚拟化。</p>
</li>
</ul>
<h2 id="缓冲管理">缓冲管理</h2>
<p><strong>目的</strong>：减少低速设备对高速的干扰。</p>
<h3 id="四种缓冲策略">四种缓冲策略</h3>
<p><strong>1. 单缓冲</strong></p>
<ul>
<li>
<p>由于处理机与I/O设备的并行性，用户进程对一块缓冲区数据的<strong>处理时间等价于Max(C，T)+M</strong>。</p>
</li>
<li>
<p>需要注意的是<strong>传送和计算或输入无法同时计算</strong></p>
</li>
<li>
<p>此时<strong>生产者是设备</strong>，<strong>消费者是用户进程</strong>，生产者和消费者都只有一个，不存在互斥</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623162724656.png" alt="image-20200623162724656" style="zoom:67%;" />
<p><strong>2. 双缓冲</strong></p>
<ul>
<li>数据被采集到缓冲区和数据从缓冲区传送到用户进程空间再被计算可以并行执行;</li>
<li>用户进程对一块缓冲区数据的处理时间等价于Max (C、T) ;如果C&gt;T,则CPU可以连续地工作;如果C&lt;T,则I/0设备可以连续地工作;</li>
<li>双缓冲适用于<strong>I/O设备与用户进程速度基本匹配的场合</strong>;</li>
<li>此时<strong>设备输入数据和用户进程取数据可以同时进行</strong></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623163234512.png" alt="image-20200623163234512" loading="lazy"></figure>
<p><strong>3. 循环缓冲</strong></p>
<ul>
<li>适用于<strong>I/O设备与用户进程速度差异较大的场合</strong></li>
<li>循环缓冲的使用：
<ul>
<li>GetBuf过程，从循环缓冲中获取一个满缓冲区或一个空缓冲区;</li>
<li>ReleaseBuf过程，向循环缓冲中释放一个空缓冲区或一个满缓冲区;</li>
</ul>
</li>
</ul>
<p><strong>4. 缓冲池（***）</strong></p>
<p><strong>三种缓冲队列</strong></p>
<ul>
<li>
<p>空缓冲队列emq</p>
</li>
<li>
<p>输入缓冲队列inq,装满输入数据</p>
</li>
<li>
<p>输出缓冲队列outq,装满输出数据</p>
</li>
</ul>
<p><strong>四种缓冲区</strong></p>
<ul>
<li>
<p>收容输入数据缓冲区hin</p>
</li>
<li>
<p>提取输入数据缓冲区sin</p>
</li>
<li>
<p>收容输出数据缓冲区hout</p>
</li>
<li>
<p>提取输出数据缓冲区sout</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623163922409.png" alt="image-20200623163922409" style="zoom:67%;" />
<h2 id="设备分配">设备分配</h2>
<ul>
<li><strong>安全分配</strong>：进程发出I/0请求后，便进入阻塞状态,直到I/O操作完成时才被唤醒。摒弃&quot;请求和保持”死锁必要条件之一， 缺点是进程进展缓慢。</li>
<li><strong>不安全分配</strong>：进程发出I/O请求后仍继续运行，需要时又发出第二C 个、第三个I/O请求等，效率高，缺点是可能造成死锁。</li>
</ul>
<h2 id="磁盘调度算法会计算">磁盘调度算法（会计算***）</h2>
<p><strong>注意</strong>：每次寻道都会改变当前所在磁道</p>
<h3 id="先来先服务">先来先服务</h3>
<blockquote>
<p>按照请求顺序进行寻道</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623164405289.png" alt="image-20200623164405289" style="zoom:67%;" />
<h3 id="最短寻道时间">最短寻道时间</h3>
<blockquote>
<p>每次寻找离当前磁道最近的请求，会导致饥饿现象，默写请求可能很久都难以调度</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623164703834.png" alt="image-20200623164703834" style="zoom:67%;" />
<h3 id="扫描算法电梯调度算法">扫描算法（电梯调度算法）</h3>
<blockquote>
<p>磁头可以朝着增加的方向移动也会朝着减少的方向移动，可以避免饥饿现象的发生</p>
</blockquote>
<ul>
<li>先寻找离当前磁头最近的磁道且需要比当前磁道大</li>
<li>当不存在比当前磁道更大的时候，磁头需要调转方向，朝着减少的方向移动.</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165335882.png" alt="image-20200623165335882" style="zoom:67%;" />
<h3 id="循环扫描算法">循环扫描算法</h3>
<p><strong>改进</strong>：当移动到不存在比当前磁道更大的时候，不再调转方向，从0开始继续寻找</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165646915.png" alt="image-20200623165646915" style="zoom:67%;" />
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160324835.png" alt="image-20200623160324835" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160342737.png" alt="image-20200623160342737" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623161956615.png" alt="image-20200623161956615" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623162055577.png" alt="image-20200623162055577" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165845231.png" alt="image-20200623165845231" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165920362.png" alt="image-20200623165920362" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165946217.png" alt="image-20200623165946217" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四章存储器管理]]></title>
        <id>https://xzzz2020.github.io/post/HB2L7VswF/</id>
        <link href="https://xzzz2020.github.io/post/HB2L7VswF/">
        </link>
        <updated>2020-06-23T02:20:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5">程序的链接与装入</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5">程序的装入</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5">程序的链接</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">连续存储分配方式</a>
<ul>
<li><a href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">单一连续分配</a></li>
<li><a href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">固定分区分配方式</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">动态分区分配（***）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">基本分页存储管理方式</a>
<ul>
<li><a href="#%E9%A1%B5%E8%A1%A8">页表</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84">地址变换机构（***）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">基本分段存储管理方式</a>
<ul>
<li><a href="#%E6%AE%B5%E8%A1%A8">段表</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-2">地址变换机构（***）</a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">分页和分段的主要区别</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">虚拟存储器（***）</a>
<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81">虚拟存储器实现方法的硬件支持</a>
<ul>
<li><a href="#%E5%88%86%E9%A1%B5%E8%AF%B7%E6%B1%82%E7%B3%BB%E7%BB%9F">分页请求系统</a></li>
<li><a href="#%E5%88%86%E6%AE%B5%E8%AF%B7%E6%B1%82%E7%B3%BB%E7%BB%9F">分段请求系统</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法（***）</a>
<ul>
<li><a href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%90%86%E6%83%B3%E5%8C%96">最佳置换算法（理想化）</a></li>
<li><a href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">先进先出页面置换算法</a></li>
<li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lru">最近最久未使用置换算法（LRU）</a></li>
<li><a href="#clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">clock置换算法</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%80%E8%BF%91%E6%9C%AA%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">简单clock置换算法（最近未访问页面置换算法）</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E5%9E%8Bclock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">改进型clock置换算法</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E6%9C%AA%E4%BD%BF%E7%94%A8lfu">最近最少未使用（LFU）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="程序的链接与装入">程序的链接与装入</h2>
<h3 id="程序的装入">程序的装入</h3>
<p><strong>目的</strong>：是将代码装入内存准备执行</p>
<ol>
<li><strong>绝对装入方式</strong></li>
<li><strong>可重定位装入方式</strong>：</li>
<li><strong>动态运行时的装入方式</strong>：增加一个重定位寄存器，通过硬件完成地址的修正。真实地址等于<strong>逻辑地址+重定位寄存器上的地址</strong><br>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622175520753.png" alt="image-20200622175520753" style="zoom:67%;" /></li>
</ol>
<h3 id="程序的链接">程序的链接</h3>
<p><strong>目的</strong>：将目标模块相对独立的地址空间合并成一个地址空间。</p>
<p>​</p>
<ol>
<li><strong>静态链接方式</strong>
<ul>
<li>对相对地址进行修改</li>
<li>变换外部调用符号</li>
</ul>
</li>
<li><strong>装入时动态链接</strong></li>
<li><strong>运行时动态链接</strong></li>
</ol>
<h2 id="连续存储分配方式">连续存储分配方式</h2>
<p><strong>目的</strong>：给每一个程序分配一片连续的存储空间，容量为程序运行时所需的最大空间。</p>
<p><strong>指标</strong>：碎片率，越小越好。</p>
<h3 id="单一连续分配">单一连续分配</h3>
<p><strong>内存分为系统区和用户区</strong></p>
<ul>
<li>用户区一次只能装入一个程序运行</li>
<li>系统区装入操作系统</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622181950847.png" alt="image-20200622181950847" style="zoom:50%;" />
<h3 id="固定分区分配方式">固定分区分配方式</h3>
<p><strong>将内存划分成固定数目的区域，如图所示</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182210610.png" alt="image-20200622182210610" style="zoom: 67%;" />
<p>为了实现内存的管理，<strong>需要建立固定分区表（数组实现）</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182308481.png" alt="image-20200622182308481" style="zoom:67%;" />
<p><strong>程序的大小和分区大小不能完全匹配</strong>，所以需要分配大于等于程序大小的内存，分区中浪费的空间称为<strong>内碎片</strong></p>
<h3 id="动态分区分配">动态分区分配（***）</h3>
<p><strong>操作系统不预设固定数目分区，按照程序内存需求为其划分，内存中分区数目动态变化。</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182722198.png" alt="image-20200622182722198" style="zoom:50%;" />
<p><strong>数据结构</strong>：</p>
<ul>
<li>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182822266.png" alt="image-20200622182822266" style="zoom:50%;" />
</li>
<li>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182958683.png" alt="image-20200622182958683" style="zoom: 67%;" />
</li>
</ul>
<p><strong>分配算法：</strong></p>
<ul>
<li><strong>首次适应算法</strong>：空闲分区以地址递增的顺序排列，<code>每次从链首开始顺序查找</code>，直到找到一个大小能满足要求的空闲分区为止。然后再按照程序的要求大小，从该空闲分区中划分出一块内存空间给请求者，余下的空闲部分仍留在空闲链表中。<code>特点是低端或高端地址空间被频繁使用。</code></li>
<li><strong>循环首次适应算法</strong>：在首次适应算法的基础上，<code>每次查找时从上次找到空闲分区的下一个空闲分区开始查找。特点是空闲分区使用均匀，但是会缺乏大的空闲分区。</code></li>
<li><strong>最佳适应算法</strong>：能满足要求、又是最小的空闲分区分配给作业，避免&quot;大材小用”。特点:分区按照大小顺序排列。</li>
<li><strong>最差适应算法</strong>：每次从空闲分区中选择最大的空闲分区分配给程序，以便切割剩余的空闲分区空间更大。</li>
</ul>
<p>切割操作会产生一些空间过小，总是不会分配给程序，这些空间被称作<strong>外碎片</strong>。</p>
<pre><code>### 可重定位分区分配
</code></pre>
<p><strong>紧凑</strong>：通过移动程序，将外碎片合并一个大的空闲分区</p>
<h2 id="基本分页存储管理方式">基本分页存储管理方式</h2>
<p><strong>离散分配的基本单位是页</strong></p>
<h3 id="页表">页表</h3>
<p><strong>解决了逻辑地址到物理地址的转换的问题：</strong></p>
<ul>
<li>将程序逻辑地址空间划分成固定大小的页面;</li>
<li>内存划分成等大小的页框;</li>
<li><code>页表实现页面到页框的索引;</code></li>
<li>页表项个数由程序的逻辑地址空间决定，页表项位数由页框起始物理地址位数决定。</li>
</ul>
<p><strong>记录了页面和页框号（每个页框的起始地址）的对应关系，如下图所示</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622191317403.png" alt="image-20200622191317403" style="zoom:67%;" />
<p>页表<strong>存储了页框的起始物理地址</strong>，需要一个连续的存储空间实现随机访问，对于<strong>逻辑地址相当于页号+页内偏移</strong>。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622200719784.png" alt="image-20200622200719784" style="zoom:80%;" />
<h3 id="地址变换机构">地址变换机构（***）</h3>
<ul>
<li>先让页号与页表基址相加得到<strong>页框号</strong></li>
<li>再让页框号与页内偏移相加得到<strong>物理地址</strong></li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622200925736.png" alt="image-20200622200925736" style="zoom:80%;" />
<h2 id="基本分段存储管理方式">基本分段存储管理方式</h2>
<ul>
<li><strong>离散分配的基本单位是端</strong></li>
<li><strong>采用二维逻辑地址结构，由段号加段内偏移构成</strong></li>
</ul>
<h3 id="段表">段表</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622201627033.png" alt="image-20200622201627033" style="zoom: 67%;" />
<h3 id="地址变换机构-2">地址变换机构（***）</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622201656943.png" alt="image-20200622201656943" style="zoom:80%;" />
<h3 id="分页和分段的主要区别">分页和分段的主要区别</h3>
<ul>
<li>页是信息的物理单位；段是信息的逻辑单位。</li>
<li>页大小固定；段大小不固定。</li>
<li>分页采用一维线性逻辑地址，分段采用二维逻辑地址。</li>
</ul>
<h2 id="虚拟存储器">虚拟存储器（***）</h2>
<p><strong>概念</strong>：虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器，其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度,每位成本接近外存。</p>
<h3 id="虚拟存储器实现方法的硬件支持">虚拟存储器实现方法的硬件支持</h3>
<h4 id="分页请求系统">分页请求系统</h4>
<ol>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ol>
<h4 id="分段请求系统">分段请求系统</h4>
<ol>
<li>请求分段的端表机制</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ol>
<h3 id="页面置换算法">页面置换算法（***）</h3>
<p><strong>页面中断</strong>：发生页面的置换</p>
<h4 id="最佳置换算法理想化">最佳置换算法（理想化）</h4>
<blockquote>
<p>置换以后永不使用或者最长时间不使用的页面</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622203218539.png" alt="image-20200622203218539" style="zoom: 80%;" />
<ul>
<li>发生3次缺页中断和页面中断</li>
</ul>
<h4 id="先进先出页面置换算法">先进先出页面置换算法</h4>
<blockquote>
<p>淘汰最先进入的页面，即选择在内存中驻留时间最久的页面予以淘汰。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622203901808.png" alt="image-20200622203901808" style="zoom:80%;" />
<h4 id="最近最久未使用置换算法lru">最近最久未使用置换算法（LRU）</h4>
<blockquote>
<p>选择最近最久未使用的页面予以淘汰，即当前使用次数最少的页面。</p>
</blockquote>
<p><strong>实现方式</strong>：</p>
<ul>
<li>利用栈保存当前使用的各个页面的页面号,每当进程访问某页面时，便将该页面的页面号从栈中弹出，并将它压入栈顶。<code>因此，栈底是最近最久未使用的页面。</code></li>
<li>使用寄存器，每一次访问都会在寄存器加一，每次置换选择寄存器中次数最少的页面</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622204543566.png" alt="image-20200622204543566" style="zoom:80%;" />
<h4 id="clock置换算法">clock置换算法</h4>
<h5 id="简单clock置换算法最近未访问页面置换算法">简单clock置换算法（最近未访问页面置换算法）</h5>
<ul>
<li>将所有的页面组成一个循环链表,并为每个页面添加一个访问位A。</li>
<li>当一个页面被访问时，将其A位设置为1。</li>
<li>置换过程是从pointer开始，<strong>若该页面的A位为1,将其设置为0,并使pointer指向下一个页面</strong>，直到找到A位为0的页面;<strong>若该页面的A位为0，则将其置换出内存</strong>，并用换入的页面占用换出页面的页框，使pointer指向下一个页面。</li>
<li>如果第一轮没有找到，则执行第二轮，由于第一轮将所有页面的A都设置为0，则一定能在第二轮找到</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101130548.png" alt="image-20200623101130548" style="zoom: 67%;" />
<h5 id="改进型clock置换算法">改进型clock置换算法</h5>
<p><strong>增加一个修改为M，页面状态可以分为四类</strong>：</p>
<ul>
<li>1类(A=0，M=0) ，未访问未修改;</li>
<li>2类(A=0，M= 1)，未访问.已修改;</li>
<li>3类(A=1，M=0)，已访问未修改;</li>
<li>4类(A=1, M= 1) ，已访问已修改;</li>
</ul>
<p><strong>置换过程</strong>：</p>
<ol>
<li>从pointer开始寻找<strong>1类</strong>页面，直到找到1类页面结束，或者扫描完一遍进入第II步。</li>
<li>从pointer开始寻找<strong>2类</strong>页面， 直到找到2类页面结束，或者扫描完一遍进入第I步。在本步每扫描完一个页面，<strong>须将页面的访问位修改为0</strong>。</li>
<li>重复l和II。(一 定可以找到置换的页。)</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101334666.png" alt="image-20200623101334666" style="zoom:80%;" />
<h4 id="最近最少未使用lfu">最近最少未使用（LFU）</h4>
<blockquote>
<p>在最近时期内选择使用次数最少的页面作为淘汰页</p>
</blockquote>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622181520299.png" alt="image-20200622181520299" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190511957.png" alt="image-20200622190511957" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190706448.png" alt="image-20200622190706448" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190752961.png" alt="image-20200622190752961" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622202031148.png" alt="image-20200622202031148" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101755205.png" alt="image-20200623101755205" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第三章进程同步与死锁]]></title>
        <id>https://xzzz2020.github.io/post/vUwZiOAP9/</id>
        <link href="https://xzzz2020.github.io/post/vUwZiOAP9/">
        </link>
        <updated>2020-06-22T09:25:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>
<ul>
<li><a href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">整型信号量</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E6%80%A7%E4%BF%A1%E5%8F%B7%E9%87%8F">记录性信号量（***）</a></li>
<li><a href="#and%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">AND型信号量</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8">信号量的应用（***）</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5">利用信号量实现互斥</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">利用信号量实现前驱关系</a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D">资源的分配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98">同步的问题</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">死锁的相关概念</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">处理死锁的基本方法</a>
<ul>
<li><a href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81">预防死锁</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81">避免死锁（***）</a>
<ul>
<li><a href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法（***）</a></li>
</ul>
</li>
<li><a href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81">检测死锁</a></li>
<li><a href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81">解除死锁</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="进程同步">进程同步</h2>
<p><strong>临界资源</strong>：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源</p>
<p><strong>临界区</strong>：每个进程中访问临界资源的代码</p>
<p><strong>实现互斥的结构</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622150153590.png" alt="image-20200622150153590" style="zoom: 67%;" />
<p><strong>硬件实现</strong>：</p>
<ul>
<li><strong>关中断</strong>：让处理机始终执行一个程序，不进行程序的切换</li>
<li><strong>指令</strong></li>
</ul>
<p><strong>同步应该遵循的规则</strong>：</p>
<ul>
<li><strong>空闲让进</strong>：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</li>
<li><strong>忙则等待</strong>：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</li>
<li><strong>有限等待</strong>：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</li>
<li><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;</li>
</ul>
<p><strong>前驱图：</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622150703762.png" alt="image-20200622150703762" style="zoom:67%;" />
<blockquote>
<p><strong>若想执行S2，则需要先执行S1。</strong></p>
</blockquote>
<h2 id="信号量">信号量</h2>
<h3 id="整型信号量">整型信号量</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622151744719.png" alt="image-20200622151744719" style="zoom:67%;" />
<h3 id="记录性信号量">记录性信号量（***）</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622151852525.png" alt="image-20200622151852525" style="zoom:67%;" />
<h3 id="and型信号量">AND型信号量</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622154354678.png" alt="image-20200622154354678" style="zoom:80%;" />
<h3 id="信号量的应用">信号量的应用（***）</h3>
<h4 id="利用信号量实现互斥">利用信号量实现互斥</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153000297.png" alt="image-20200622153000297" style="zoom:50%;" />
<p><strong>实现算法</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153444468.png" alt="image-20200622153444468" style="zoom:50%;" />
<p><strong>符合</strong>：空闲让进，忙则等待和有限等待</p>
<h4 id="利用信号量实现前驱关系">利用信号量实现前驱关系</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153525416.png" alt="image-20200622153525416" style="zoom: 67%;" />
<h4 id="资源的分配">资源的分配</h4>
<p>申请资源时需要执行P操作，释放资源时执行V操作</p>
<h2 id="同步的问题">同步的问题</h2>
<ul>
<li>生产者-消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者-写者问题</li>
</ul>
<h2 id="进程间通信">进程间通信</h2>
<p><strong>低级通信</strong>：信号量机制</p>
<p><strong>高级通讯</strong>：共享存储器系统、消息传递系统、管道通信。</p>
<h2 id="死锁的相关概念">死锁的相关概念</h2>
<p><strong>可抢占资源</strong>：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。</p>
<p><strong>不可抢占的资源</strong>：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</p>
<p><strong>死锁的定义</strong>：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。</p>
<p><strong>产生死锁的原因</strong>：</p>
<ul>
<li>竞争不可抢占资源引发死锁。</li>
<li>竞争可消耗资源引发死锁。</li>
<li>进程推进顺序不当引发死锁。</li>
</ul>
<h2 id="处理死锁的基本方法">处理死锁的基本方法</h2>
<h3 id="预防死锁">预防死锁</h3>
<ul>
<li>破坏“请求和保持条件”</li>
<li>破坏“不可抢占条件”</li>
<li><strong>破坏“循环等待条件”</strong>：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，<mark><strong>必须按照从1到4或者从4到1的顺序申请</strong></mark>。</li>
</ul>
<h3 id="避免死锁">避免死锁（***）</h3>
<p><strong>安全状态</strong>：安全状态，是指系统能按某种顺序(P1, P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,<mark><strong>直到满足每个进程对资源的最大需求</strong></mark>，使每个进程都可以顺利地完成。</p>
<p><strong>不安全状态</strong>：如果系统无法找到这样一个安全序列， 称系统处于不安全状态。</p>
<blockquote>
<p>要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622165340017.png" alt="image-20200622165340017" style="zoom:67%;" />
<ul>
<li>根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态</li>
</ul>
<h4 id="银行家算法">银行家算法（***）</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170224200.png" alt="image-20200622170224200" style="zoom:80%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170321644.png" alt="image-20200622170321644" style="zoom:80%;" />
<ul>
<li>先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。</li>
<li>寻找安全序列的方式只有两种：<strong>每次都从最上面开始</strong>；<strong>按照从上到下顺序循环</strong></li>
</ul>
<p><strong>应用</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170415300.png" alt="image-20200622170415300" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170922576.png" alt="image-20200622170922576" style="zoom:67%;" />
<p><strong>如果单向顺序，查找安全序列的流程为</strong>：</p>
<ol>
<li>判断P0，返现剩余资源不能满足。<strong>判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。</strong></li>
<li>继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。<strong>判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。</strong></li>
<li><strong>继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。</strong></li>
<li>P0、 P1结束，直接跳过。<strong>判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。</strong></li>
<li>P0、 P1、P2、P3结束，直接跳过。<strong>判断P4，发现满足，则释放P4分配的资源。</strong></li>
<li><strong>最终的安全序列为：P1、P3、P0、P2、P4。</strong></li>
<li><strong>确认分配</strong>。</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172205550.png" alt="image-20200622172205550" style="zoom:67%;" />
<ul>
<li><strong>此时找不到安全序列，拒绝分配。</strong></li>
</ul>
<h3 id="检测死锁">检测死锁</h3>
<h3 id="解除死锁">解除死锁</h3>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172918571.png" alt="image-20200622172918571" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172948218.png" alt="image-20200622172948218" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173016842.png" alt="image-20200622173016842" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173053665.png" alt="image-20200622173053665" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173114342.png" alt="image-20200622173114342" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173233127.png" alt="image-20200622173233127" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第二章处理机管理]]></title>
        <id>https://xzzz2020.github.io/post/IyZhCzd1C/</id>
        <link href="https://xzzz2020.github.io/post/IyZhCzd1C/">
        </link>
        <updated>2020-06-22T06:30:37.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F">程序的执行方式</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%96%B9%E5%BC%8F">顺序方式（*）</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C">并发执行（***）</a></li>
<li><a href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C">并行执行</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">进程的状态</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb">进程控制块（PCB）</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%93%8D%E4%BD%9C">进程的四个操作</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">进程的创建</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2">进程的终止</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92">进程的阻塞和进程的唤醒</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5">进程调度概念</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</a></li>
<li><a href="#%E8%A1%A1%E9%87%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87">衡量调度算法指标</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97">进程调度算法（计算***）</a>
<ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">先来先服务调度算法（***）</a></li>
<li><a href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">短作业优先调度算法（***）</a></li>
<li><a href="#%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">高优先权调度算法（***）</a></li>
<li><a href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">高响应比优先调度算法</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">时间片轮转调度算法（***）</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级队列调度算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级反馈队列调度算法</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="程序的执行方式">程序的执行方式</h2>
<h3 id="顺序方式">顺序方式（*）</h3>
<p>内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着<strong>严格的先后次序</strong></p>
<p><strong>顺序执行的特点</strong>：</p>
<ul>
<li><strong>顺序性</strong>：程序执行有着明确的先后顺序</li>
<li><strong>封闭性</strong>：程序运行时独占所有资源</li>
<li><strong>可再现性</strong>：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同</li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>无法满足高性能</li>
</ul>
<h3 id="并发执行">并发执行（***）</h3>
<p>并发指一段时间内执行多个程序。多个程序同时进入内存，轮流<strong>交替执行</strong>。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622092827851.png" alt="image-20200622092827851" style="zoom:67%;" />
<p><strong>并发执行的特点</strong>：</p>
<ul>
<li>
<p><strong>间断性</strong>：交替执行就是走走停停</p>
</li>
<li>
<p><strong>失去了封闭性</strong>：程序不再独占系统资源</p>
</li>
<li>
<p><strong>不可再现性</strong>：程序执行有多种结果。</p>
</li>
</ul>
<h3 id="并行执行">并行执行</h3>
<p>同一时刻有多个程序执行，只能在多处理机上实现</p>
<h2 id="进程">进程</h2>
<p>进程是研究并发方式下，程序的执行。</p>
<p><strong>进程的概念</strong>：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。</p>
<blockquote>
<p><strong>进程实体</strong>：由程序段、相关数据段和PCB组成</p>
</blockquote>
<h3 id="进程的特征">进程的特征</h3>
<ul>
<li><mark><strong>并发性</strong></mark>， 多个进程在一段时 间内同存于内存中同时运行</li>
<li><mark><strong>动态性</strong></mark>，进程由创建而产生，由调度而执行，由撤消而消亡。</li>
<li><strong>独立性</strong>，进程是能独立运行、资源分配、调度的基本单位。</li>
<li><strong>结构性</strong>，进程映像由程序、数据、栈和进程控制块( PCB )构成。</li>
<li><strong>异步性</strong>，进程按各自独立、不可预知的速度向前推进。</li>
</ul>
<h3 id="进程的状态">进程的状态</h3>
<p><strong>有三个状态</strong>：</p>
<ul>
<li><strong>就绪状态</strong>：指程序已经处于准备好运行的状态。</li>
<li><strong>执行状态</strong>：指程序已经获得CPU，正在执行。</li>
<li><strong>阻塞状态</strong>：指程序的执行因为某些原因无法继续执行。</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622093952609.png" alt="image-20200622093952609" style="zoom:50%;" />
<h3 id="进程控制块pcb">进程控制块（PCB）</h3>
<ul>
<li>用来描述进程的基本情况和活动过程，进而控制和管理进程。（<strong>类似于学籍、户口等</strong>）</li>
<li>进程创建时会建立一个PCB，结束时会收回PCB</li>
</ul>
<p><strong>进程控制块中的信息</strong>：</p>
<ul>
<li><strong>进程标识符</strong>：包括内部标识符和外部标识符。</li>
<li><strong>处理机状态</strong>：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。</li>
<li><strong>进程控制信息</strong>：程序栈和数据地址，同步和通信机制，资源清单,链接指针。</li>
<li><strong>进程调度信息</strong></li>
</ul>
<p><strong>进程控制块中的组织方式</strong></p>
<ol>
<li>
<p><strong>线性方式</strong></p>
</li>
<li>
<p><strong>链接方式</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622095654092.png" alt="image-20200622095654092" style="zoom:50%;" />
</li>
<li>
<p><strong>索引方式</strong></p>
</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622095909769.png" alt="image-20200622095909769" style="zoom:50%;" />
<h2 id="进程控制">进程控制</h2>
<ul>
<li>
<p>进程控制用于创建、终止、阻塞和唤醒进程。</p>
</li>
<li>
<p>进程控制由操作系统内核原语来实现。</p>
<blockquote>
<p>原语是由若干条指令组成，用于完成一定功能的一个<strong>过程</strong>，所有的指令<strong>要么全做，要么全不做</strong>。（<strong>一个函数</strong>）</p>
</blockquote>
</li>
</ul>
<p><strong>用户态</strong>：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。</p>
<p><strong>系统态（内核态）</strong>：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。</p>
<h3 id="进程的四个操作">进程的四个操作</h3>
<h4 id="进程的创建">进程的创建</h4>
<p><strong>引起进程创建的事件</strong>：</p>
<ul>
<li>用户执行应用程序。</li>
<li>用户登录。</li>
<li>启动服务。</li>
<li>程序创建进程。</li>
</ul>
<p><strong>进程创建的过程</strong>（必须要求是原语）：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源，如内存空间等</li>
<li>初始化PCB</li>
<li>将进程插入就绪队列</li>
</ol>
<h4 id="进程的终止">进程的终止</h4>
<p><strong>引起进程终止的事件</strong>：</p>
<ul>
<li>正常结束。</li>
<li>异常结束。</li>
<li>外界干预。</li>
</ul>
<p><strong>进程的终止过程</strong>：</p>
<ul>
<li>
<p>检查进程状态。</p>
</li>
<li>
<p>有无子孙需要终止。</p>
</li>
<li>
<p>归还进程全部资源。</p>
</li>
<li>
<p>将PCB从进程中移除。</p>
</li>
</ul>
<h4 id="进程的阻塞和进程的唤醒">进程的阻塞和进程的唤醒</h4>
<h2 id="进程调度概念">进程调度概念</h2>
<p><strong>处理机调度的层次</strong>：</p>
<ul>
<li>高级调度</li>
<li>低级调度</li>
<li>中级调度</li>
</ul>
<p><strong>引起进程调度的事件</strong>：</p>
<ul>
<li>进程终止。</li>
<li>进程创建。</li>
<li>进程阻塞。</li>
<li>进程唤醒。</li>
<li>外部设备中断。</li>
</ul>
<p>进程切换时需要保存和恢复现场。</p>
<h3 id="进程调度的方式">进程调度的方式</h3>
<ul>
<li>
<p><strong>抢占式调度</strong>：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。</p>
</li>
<li>
<p><strong>非抢占式调度</strong>：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（<strong>只有时间片用完才能调度</strong>）</p>
</li>
</ul>
<h3 id="衡量调度算法指标">衡量调度算法指标</h3>
<p><strong>面向用户（***）</strong>：</p>
<ul>
<li><strong>平均周转时间</strong>：所有周转时间求平均。</li>
<li><strong>带权周转时间</strong>：一个程序的周转时间除以服务的时间。（&gt;=1）</li>
<li><strong>平均带权周转时间</strong>：对带权周转时间求平均。</li>
</ul>
<blockquote>
<p><strong>周转时间</strong>：从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
</blockquote>
<p><strong>面向系统</strong>：</p>
<ul>
<li><strong>吞吐量</strong>：在单位时间内系统所完成的作业数。</li>
<li><strong>处理机利用率</strong>：在过去一 段时间内CPU被占用的时间总和。</li>
<li><strong>各类资源的平衡利用率</strong>：保证系统所有的资源被合理利用。</li>
</ul>
<h2 id="进程调度算法计算">进程调度算法（计算***）</h2>
<h3 id="先来先服务调度算法">先来先服务调度算法（***）</h3>
<blockquote>
<p><strong>先来的进程先抢到CPU，有利于长作业，不利于短作业</strong></p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622112903214.png" alt="image-20200622111911566" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622112903214.png" alt="image-20200622112903214" style="zoom:67%;" />
<h3 id="短作业优先调度算法">短作业优先调度算法（***）</h3>
<blockquote>
<p><strong>在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。</strong></p>
<p><strong>只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。</strong></p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622113117858.png" alt="image-20200622113117858" style="zoom:67%;" />
<p><strong>非抢占方式：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622114213680.png" alt="image-20200622114213680" loading="lazy"></figure>
<p><strong>抢占式：</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622114634375.png" alt="image-20200622114634375" style="zoom:67%;" />
<h3 id="高优先权调度算法">高优先权调度算法（***）</h3>
<blockquote>
<p>按照优先权重分配CPU，优先数越小，优先权越大</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622115711510.png" alt="image-20200622115711510" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622120734094.png" alt="image-20200622120734094" style="zoom:50%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622120734094.png" alt="image-20200622120720361" style="zoom:50%;" />
<h3 id="高响应比优先调度算法">高响应比优先调度算法</h3>
<blockquote>
<p>按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久</p>
<p>响应比 = 等待时间/服务时间</p>
</blockquote>
<h3 id="时间片轮转调度算法">时间片轮转调度算法（***）</h3>
<blockquote>
<p>按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。</p>
<p>假设时间片为2。</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200624101953231.png" alt="image-20200624101953231" style="zoom:80%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622122733994.png" alt="image-20200622122330474" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622122733994.png" alt="image-20200622122733994" style="zoom:50%;" />
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<blockquote>
<p>优先调度优先级高的</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622122939586.png" alt="image-20200622122939586" style="zoom:50%;" />
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<blockquote>
<p>解决了低优先级队列长时间无法调度的问题</p>
</blockquote>
<h2 id="线程">线程</h2>
<p><strong>为什么提出线程？</strong></p>
<ul>
<li>进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。</li>
<li>一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。</li>
</ul>
<p><strong>线程概念</strong>：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。</p>
<p>如下图所示，每个线程都会有个栈，一共有三个线程：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622142107384.png" alt="image-20200622142107384" style="zoom: 80%;" />
<p><strong>线程的特点</strong>：</p>
<ul>
<li>一个线程<strong>拥有少量的资源</strong>，记录在<strong>线程控制块中</strong>。轻型实体，线程基本上不拥有资源，或者是有较少的资源;</li>
<li>一个进程的所有线程共享进程所拥有的全部资源。</li>
<li>线程是处理机调度的基本单位，多个线程可以并发执行。</li>
</ul>
<p><strong>线程与进程的比较</strong>：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623095239272.png" alt="image-20200623095239272" loading="lazy"></figure>
<p><strong>线程的实现方式</strong>：</p>
<ul>
<li><strong>内核级线程</strong>：所有创建、切换等都需要内核的支持，开销较大（<strong>适合多处理器系统</strong>）</li>
<li><strong>用户级线程</strong>：可以不需要进入内核态创建，但是切换进程需要进入内核（<strong>开销小</strong>）</li>
<li><strong>组合方式</strong>：建立内核级线程与用户级线程的关系。</li>
</ul>
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622093526050.png" alt="image-20200622093526050" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622100444854.png" alt="image-20200622100444854" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622100540099.png" alt="image-20200622100540099" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622103623435.png" alt="image-20200622103623435" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622103657071.png" alt="image-20200622103657071" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622143148015.png" alt="image-20200622143148015" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一章操作系统引论]]></title>
        <id>https://xzzz2020.github.io/post/ZBrN48x_g/</id>
        <link href="https://xzzz2020.github.io/post/ZBrN48x_g/">
        </link>
        <updated>2020-06-21T12:49:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95">操作系统发展</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD">操作系统的功能</a>
<ul>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86">处理机管理</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98">存储器管理（内存）</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8io%E8%AE%BE%E5%A4%87">设备管理（高效使用IO设备）</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">操作系统接口</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">操作系统的基本特征</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8">操作系统的作用</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">设计目标</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">操作系统结构</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="操作系统发展">操作系统发展</h2>
<ul>
<li><strong>无操作系统</strong></li>
<li><strong>单道批处理系统</strong></li>
<li><strong>多道批处理系统</strong>：多个程序交替使用CPU，目的是提高CPU的利用率</li>
<li><strong>分时系统</strong>：使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了<code>时分复用技术</code></li>
<li><strong>实时系统</strong>：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对<code>时间要求苛刻</code></li>
</ul>
<h2 id="操作系统的功能">操作系统的功能</h2>
<h3 id="处理机管理">处理机管理</h3>
<ol>
<li>进程控制</li>
<li>进程调度</li>
<li>进程同步</li>
<li>进程通信</li>
<li>死锁</li>
</ol>
<h3 id="存储器管理内存">存储器管理（内存）</h3>
<ol>
<li>内存分配</li>
<li>内存共享</li>
<li>内存扩充</li>
<li>内存保护</li>
</ol>
<h3 id="设备管理高效使用io设备">设备管理（高效使用IO设备）</h3>
<ol>
<li>设备处理</li>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备的独立性</li>
<li>设备的虚拟性</li>
</ol>
<h3 id="文件管理">文件管理</h3>
<ol>
<li>文件读/写</li>
<li>目录管理</li>
<li>存储空间管理</li>
<li>文件共享、存储性能优化、存储可靠性和数据一致性</li>
</ol>
<h3 id="操作系统接口">操作系统接口</h3>
<ol>
<li>
<p>图形接口</p>
</li>
<li>
<p>系统调用</p>
</li>
<li>
<p>命令调用</p>
<p>​	<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202748865.png" alt="image-20200621202748865" style="zoom: 50%;" /></p>
</li>
</ol>
<h2 id="操作系统的基本特征">操作系统的基本特征</h2>
<ul>
<li><strong>并发性</strong>：多个程序在同一时间间隔执行</li>
<li><strong>共享性</strong>：多个并发的程序共同使用计算机资源，提高计算机资源的利用率</li>
<li><strong>虚拟性</strong>：有时分复用和空分复用两种技术</li>
<li><strong>异步性</strong>：表现为多任务执行的无序性，主要应对阻塞</li>
</ul>
<h2 id="操作系统的作用">操作系统的作用</h2>
<p>操作系统(Operating System, OS)是<strong>一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。</strong></p>
<ul>
<li><strong>是用户和计算机系统之间的接口</strong></li>
<li><strong>是系统资源的管理者</strong></li>
<li><strong>扩充计算机的功能，实现对计算机的抽象</strong></li>
</ul>
<h2 id="设计目标">设计目标</h2>
<ul>
<li><strong>方便性</strong></li>
<li><strong>有效性</strong></li>
<li><strong>扩充性</strong></li>
<li><strong>开放性</strong></li>
</ul>
<h2 id="操作系统结构">操作系统结构</h2>
<ol>
<li>无操作系统结构</li>
<li>模块化结构</li>
<li>层次结构</li>
<li>微内核结构</li>
</ol>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621201525920.png" alt="image-20200621201525920" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202025346.png" alt="image-20200621201751451" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621201850031.png" alt="image-20200621201850031" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202047000.png" alt="image-20200621202047000" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202056968.png" alt="image-20200621202056968" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621203755881.png" alt="image-20200621203755881" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621203910781.png" alt="image-20200621203910781" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020最新-Java面试]]></title>
        <id>https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/</id>
        <link href="https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/">
        </link>
        <updated>2020-06-18T12:29:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：<a href="https://blog.csdn.net/qq_43040688/article/details/105819866">https://blog.csdn.net/qq_43040688/article/details/105819866</a></p>
</blockquote>
<p>这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。</p>
<br>
<br>
<br>
<br>
<br>
<h2 id="一-数据库">一. 数据库</h2>
<h3 id="11-关系型数据库">1.1 关系型数据库</h3>
<h4 id="mysql已更新">MySQL(已更新)</h4>
<p>推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》<br>
<code>对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句</code></p>
<table>
<thead>
<tr>
<th>SQL语句学习</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105346357">https://blog.csdn.net/qq_43040688/article/details/105346357</a></td>
</tr>
<tr>
<td>重点部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105348610">https://blog.csdn.net/qq_43040688/article/details/105348610</a></td>
</tr>
<tr>
<td>扩展部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105381801">https://blog.csdn.net/qq_43040688/article/details/105381801</a></td>
</tr>
</tbody>
</table>
<p><code>接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构</code></p>
<table>
<thead>
<tr>
<th>SQL高级部分</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL体系结构和存储引擎介绍</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105393816">https://blog.csdn.net/qq_43040688/article/details/105393816</a></td>
</tr>
<tr>
<td>InnoDB存储引擎</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105415093">https://blog.csdn.net/qq_43040688/article/details/105415093</a></td>
</tr>
<tr>
<td>MySQL 索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105419053">https://blog.csdn.net/qq_43040688/article/details/105419053</a></td>
</tr>
<tr>
<td>MySQL创建高性能的索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105454477">https://blog.csdn.net/qq_43040688/article/details/105454477</a></td>
</tr>
<tr>
<td>MySQL查询性能优化</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105456790">https://blog.csdn.net/qq_43040688/article/details/105456790</a></td>
</tr>
<tr>
<td>MySQL锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105440448">https://blog.csdn.net/qq_43040688/article/details/105440448</a></td>
</tr>
<tr>
<td>MySQL事务</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441274">https://blog.csdn.net/qq_43040688/article/details/105441274</a></td>
</tr>
<tr>
<td>MySQL备份</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441944">https://blog.csdn.net/qq_43040688/article/details/105441944</a></td>
</tr>
<tr>
<td>MySQL架构</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105450005">https://blog.csdn.net/qq_43040688/article/details/105450005</a></td>
</tr>
<tr>
<td>MySQL高级特性</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105465192">https://blog.csdn.net/qq_43040688/article/details/105465192</a></td>
</tr>
<tr>
<td>分库分表的高频面试题</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105594653">https://blog.csdn.net/qq_43040688/article/details/105594653</a></td>
</tr>
</tbody>
</table>
<h3 id="12-非关系型数据库">1.2 非关系型数据库</h3>
<h4 id="redis">Redis</h4>
<h2 id="二-java基础">二、Java基础</h2>
<h3 id="21-java虚拟机已更新">2.1 Java虚拟机（已更新）</h3>
<p>虛拟机推荐 <strong>《深入理解Java虚拟机》</strong> 这本书，重点学习一下<code>内存</code>、<code>垃圾回收</code>、<code>类加载机制</code>这几部分内容。</p>
<table>
<thead>
<tr>
<th>JVM内存结构</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>JVM简介</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104964070">https://blog.csdn.net/qq_43040688/article/details/104964070</a></td>
</tr>
<tr>
<td>程序计数器和虚拟机栈</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104970081">https://blog.csdn.net/qq_43040688/article/details/104970081</a></td>
</tr>
<tr>
<td>本地方法栈和堆</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104972811">https://blog.csdn.net/qq_43040688/article/details/104972811</a></td>
</tr>
<tr>
<td>方法区</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104982648">https://blog.csdn.net/qq_43040688/article/details/104982648</a></td>
</tr>
<tr>
<td>直接内存</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104996032">https://blog.csdn.net/qq_43040688/article/details/104996032</a></td>
</tr>
</tbody>
</table>
<h3 id="22-java并发已更新">2.2 Java并发（已更新）</h3>
<blockquote>
<p>Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久</p>
</blockquote>
<h4 id="java并发基础">Java并发基础</h4>
<blockquote>
<p>学习Java并发，需要先掌握线程的一些基础知识<br>
这些基础知识的组合构成了后面的设计模式</p>
</blockquote>
<ul>
<li>首先应该了解如何启动一个多线程，即<strong>使用Runnable、Callable、Thread</strong>；还需要了解线程启动后的<strong>生命周期</strong>，<strong>了解了不用实现方式的差别</strong>，最重要的<strong>研读Thread的源码</strong>，详情参考：<code>Java多线程起步</code>，<code>Thread构造函数源码分析</code></li>
<li>需要学习<strong>Thread常用API</strong>以及<strong>三种关闭线程的方式</strong>，详情参考：<code>Thread的API</code></li>
<li>需要了解<strong>this锁</strong>和<strong>class锁</strong>，详情参考：<code>Java多线程之认识“锁”</code></li>
<li>需要了解<strong>线程间的通讯</strong>，最基本的就是消费者和生产者模型，需要深入了解了<strong>wait、sleep、notify、nitifyAll</strong>的机制和差异，对于<strong>wait set</strong>要有个清晰的认识，详情参考：<code>Java多线程之线程间的通讯</code></li>
<li>需要尝试自定义了一个<strong>Boolean锁</strong>，了解了<strong>加锁和释放锁的过程</strong>，实现了获取正在阻塞的线程；需要了解<strong>线程运行时出现异常的处理方式</strong><br>
，详情参考：<code>自定义Boolean锁&amp;捕获线程中的异常</code></li>
<li>需要学习了<strong>线程组的概念以及常用API</strong>，如interrupt，setDaemon，activeCount，enumerate， 详情参考：<code>线程组</code></li>
<li>需要<strong>自定义了一个线程池</strong>，对线程池的处理机制有了较深的理解，详情参考：<code>自定义线程池</code></li>
</ul>
<table>
<thead>
<tr>
<th>Java并发基础</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java多线程起步</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/103979628">https://blog.csdn.net/qq_43040688/article/details/103979628</a></td>
</tr>
<tr>
<td>Thread构造函数源码分析</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105543926">https://blog.csdn.net/qq_43040688/article/details/105543926</a></td>
</tr>
<tr>
<td>Thread的API</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105747547">https://blog.csdn.net/qq_43040688/article/details/105747547</a></td>
</tr>
<tr>
<td>Java多线程之认识“锁”</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105752943">https://blog.csdn.net/qq_43040688/article/details/105752943</a></td>
</tr>
<tr>
<td>Java多线程之线程间的通讯</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105754406">https://blog.csdn.net/qq_43040688/article/details/105754406</a></td>
</tr>
<tr>
<td>自定义Boolean锁&amp;捕获线程中的异常</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105771445">https://blog.csdn.net/qq_43040688/article/details/105771445</a></td>
</tr>
<tr>
<td>线程组</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105774614">https://blog.csdn.net/qq_43040688/article/details/105774614</a></td>
</tr>
<tr>
<td>自定义线程池</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105786243">https://blog.csdn.net/qq_43040688/article/details/105786243</a></td>
</tr>
</tbody>
</table>
<h4 id="多线程的设计模式">多线程的设计模式</h4>
<blockquote>
<p>Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合<font color = "red">以满足应用需求</font><br>
<strong>下面有十四个多线程的设计模式，帮助理解后面的JUC包。</strong></p>
</blockquote>
<ul>
<li>
<p>第一个设计模式是：<strong>观察者模式</strong>。需要定义一个<strong>主题</strong>，一个<strong>观察者</strong>。<font color = "purple">主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。</font>详情参考：<code>观察者模式</code></p>
</li>
<li>
<p>第二个设计模式是：<strong>单例模式</strong>。解决方式有三种：<font color = "purple">第一种是double check方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static 类实现；第三种是利用enum类实现。</font>详情参考：<code>单例模式</code></p>
</li>
<li>
<p>第三个设计模式是<strong>单线程执行模式</strong>。<font color = "purple">就是在同一时刻只能有一个对共享资源进行操作。</font>详情参考：<code>单线程执行设计模式</code></p>
</li>
<li>
<p>第四个设计模式<strong>不可变对象设计模式</strong>。<font color = "purple">是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。</font>详情参考：<code>不可变对象设计模式</code></p>
</li>
<li>
<p>第五个设计模式<strong>确保挂起设计模式</strong>。<font color = "purple">当线程在工作时，如果来了其他任务，将任务放入到队列中等待。</font>详情参考：<code>确保挂起设计模式</code></p>
</li>
<li>
<p>第六个设计模式<strong>Balking设计模式</strong>。<font color = "purple">当工作已经执行过了，就直接return，防止重复的工作，提高效率。</font>详情参考：<code>Balking设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>生产者-消费者设计模式</strong>。<font color = "purple">如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。</font>详情参考：<code>生产者-消费者设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>读写锁的设计模式</strong>。<font color = "purple">读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能</font>。详情参考：<code>读写锁的设计模式</code></p>
</li>
<li>
<p>第八个设计模式<strong>Thread-Per-Message</strong>。<font color = "purple">每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。</font>详情参考：<code>Thread-Per-Message</code></p>
</li>
<li>
<p>第九个设计模式 <strong>Worker 设计模式</strong>。<font color = "purple">需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。</font><br>
详情参考：<code>Worker 设计模式</code></p>
</li>
<li>
<p>第十个设计模式<strong>Future设计模式</strong>。<font color = "purple">通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。</font>详情参考：<code>Future设计模式</code></p>
</li>
<li>
<p>第十一个设计模式<strong>两阶段终止设计模式</strong>。<font color = "purple">当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。</font>详情参考：<code>两阶段终止设计模式</code></p>
</li>
<li>
<p>第十二个设计模式<strong>线程保险箱设计模式</strong>。<font color = "purple">利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。</font >详情参考：<code>线程保险箱设计模式</code>和<code>上下文设计模式</code></p>
</li>
<li>
<p>第十三个设计模式<strong>Active Objects 设计模式</strong>。<font color = "purple">接受异步调用的主动方法。可以主动异步的执行一些任务。</font>详情参考：<code>Active Objects 设计模式</code></p>
</li>
<li>
<p>第十四个设计模式<strong>Count Down设计模式</strong>。<font color = "purple">多个子任务执行，主任务等待子任务全部执行完，再执行</font>详情参考：<code>Count Down设计模式</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>多线程的设计模式</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>观察者模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105835544">https://blog.csdn.net/qq_43040688/article/details/105835544</a></td>
</tr>
<tr>
<td>单例模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105798423">https://blog.csdn.net/qq_43040688/article/details/105798423</a></td>
</tr>
<tr>
<td>单线程执行设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105856901">https://blog.csdn.net/qq_43040688/article/details/105856901</a></td>
</tr>
<tr>
<td>不可变对象设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105865371">https://blog.csdn.net/qq_43040688/article/details/105865371</a></td>
</tr>
<tr>
<td>确保挂起设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105886681">https://blog.csdn.net/qq_43040688/article/details/105886681</a></td>
</tr>
<tr>
<td>Balking设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105890674">https://blog.csdn.net/qq_43040688/article/details/105890674</a></td>
</tr>
<tr>
<td>生产者-消费者设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105891561">https://blog.csdn.net/qq_43040688/article/details/105891561</a></td>
</tr>
<tr>
<td>读写锁的设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105857920">https://blog.csdn.net/qq_43040688/article/details/105857920</a></td>
</tr>
<tr>
<td>Thread-Per-Message</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892219">https://blog.csdn.net/qq_43040688/article/details/105892219</a></td>
</tr>
<tr>
<td>Worker 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105894685">https://blog.csdn.net/qq_43040688/article/details/105894685</a></td>
</tr>
<tr>
<td>Future设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105868293">https://blog.csdn.net/qq_43040688/article/details/105868293</a></td>
</tr>
<tr>
<td>两阶段终止设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892777">https://blog.csdn.net/qq_43040688/article/details/105892777</a></td>
</tr>
<tr>
<td>线程保险箱设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105887378">https://blog.csdn.net/qq_43040688/article/details/105887378</a></td>
</tr>
<tr>
<td>上下文设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105888242">https://blog.csdn.net/qq_43040688/article/details/105888242</a></td>
</tr>
<tr>
<td>Active Objects 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105895280">https://blog.csdn.net/qq_43040688/article/details/105895280</a></td>
</tr>
<tr>
<td>Count Down设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892054">https://blog.csdn.net/qq_43040688/article/details/105892054</a></td>
</tr>
</tbody>
</table>
<h4 id="java高并发与jvm的关系">Java高并发与JVM的关系</h4>
<blockquote>
<p>主要是学习<code>wait set</code>、<code>JMM模型</code></p>
</blockquote>
<p><strong>JMM模型中有四个内容</strong>，主要参看博客：<code>Java多线程之内存模型三大特性</code>。如果想学习更多，请学习JVM的部分。</p>
<ul>
<li><strong>解决高速缓存中数据不一致性的问题</strong>——总线锁（效率低）、高速缓存一致性协议，英特尔</li>
<li><strong>高并发的三个要求</strong>——原子性、可见性、有序性</li>
<li><strong>happens-before</strong></li>
<li><strong>指令重排序</strong></li>
</ul>
<p>Java多线程之内存模型三大特性：<a href="https://blog.csdn.net/qq_43040688/article/details/105823532">https://blog.csdn.net/qq_43040688/article/details/105823532</a></p>
<h4 id="原子包">原子包</h4>
<p><strong>CAS</strong>  ：</p>
<ul>
<li>乐观锁，CompareAndSwap。</li>
<li>优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。</li>
<li>缺点：在竞争激烈的情况下，浪费CUP资源。</li>
<li>还有一个问题是ABA问题，解决方法是：加一个版本号。</li>
<li>详情参考：<code>CAS</code></li>
</ul>
<p><strong>UnSafe类</strong></p>
<ul>
<li>内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式</li>
<li>获取Unsafe需要通过<code>反射</code>Unsafe类的属性</li>
<li>常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现</li>
<li>详情参考：<code>UnSafe类</code></li>
</ul>
<p><strong>AtomicInteger和AtomicBoolean</strong>：</p>
<ul>
<li>是保证原子性的对象。</li>
<li>利用的CAS</li>
<li>详情参考：<code>AtomicInteger</code>和<code>AtomicBoolean</code></li>
</ul>
<p><strong>AtomicReference</strong></p>
<ul>
<li>是一个利用CAS帮助对象保证原子性的</li>
<li>但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：<code>CAS</code></li>
<li>详情参考：<code>AtomicReference</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAS</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105914717">https://blog.csdn.net/qq_43040688/article/details/105914717</a></td>
</tr>
<tr>
<td>AtomicInteger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105908835">https://blog.csdn.net/qq_43040688/article/details/105908835</a></td>
</tr>
<tr>
<td>AtomicBoolean</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105917939">https://blog.csdn.net/qq_43040688/article/details/105917939</a></td>
</tr>
<tr>
<td>AtomicReference</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105918329">https://blog.csdn.net/qq_43040688/article/details/105918329</a></td>
</tr>
<tr>
<td>UnSafe类</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105923421">https://blog.csdn.net/qq_43040688/article/details/105923421</a></td>
</tr>
</tbody>
</table>
<h4 id="juc工具包">JUC工具包</h4>
<p><strong>CountDownLatch</strong></p>
<ul>
<li>通过一个计数器实现，计数器初始值就是线程的数量</li>
<li>每当一个线程完成任务，就会使计数减一</li>
<li>可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成</li>
<li>详情见：<code>CountDownLatch</code></li>
</ul>
<p><strong>CyclicBarrier</strong></p>
<ul>
<li>跟<code>CountDownLatch</code>的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点</li>
<li>详情见：<code>CyclicBarrier</code></li>
</ul>
<p><strong>Phaser</strong></p>
<ul>
<li>JDK1.7之后引用的，具有<code>CyclicBarrier</code>和<code>CountDownLatch</code></li>
<li>同时它的注册数是支持动态增加或减少（可以用于线程出现异常）</li>
<li>当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复</li>
<li>详情见：<code>Phaser</code></li>
</ul>
<p><strong>Exchanger</strong></p>
<ul>
<li>用于线程间交换数据</li>
<li>需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题</li>
<li>详情见：<code>Exchanger</code></li>
</ul>
<p><strong>Semaphore</strong></p>
<ul>
<li>是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问</li>
<li>详情见：<code>Semaphore</code></li>
</ul>
<p><strong>ReentrantLock</strong></p>
<ul>
<li>支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的</li>
<li>支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞</li>
<li>需要手动的释放锁，try...finally...</li>
<li>相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高</li>
<li>是一个Java类，具有更多的功能，同时可以自由的扩展</li>
<li>详情请见：<code>ReentrantLock</code></li>
</ul>
<p><strong>读写锁</strong></p>
<ul>
<li>将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能</li>
<li>是悲观锁，可能读的线程太多，写的线程迟迟难以执行</li>
<li>详情请见：<code>读写锁</code></li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li>解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁</li>
<li>思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据</li>
<li>详情请见：<code>StampedLock</code></li>
</ul>
<p><strong>三种锁的比较</strong></p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>StampedLock</th>
<th>Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>是JVM的的内置锁，每个JDK版本都会优化</td>
<td>是一个Java类，可以更好的扩展</td>
<td>是一个Java类，可以更好的扩展</td>
</tr>
<tr>
<td>都是悲观锁</td>
<td>提供了写的乐观锁</td>
<td>都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁</td>
</tr>
<tr>
<td>性能一般，因为有一个从用户态到内核态的过程</td>
<td>性能最好，可以代替读写锁</td>
<td>性能十分不稳定，在复杂的读写环境下，性能十分差</td>
</tr>
</tbody>
</table>
<ul>
<li>详情请见：<code>三种锁的比较</code></li>
</ul>
<p><strong>ForkJoin</strong></p>
<ul>
<li>基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行</li>
<li>分为Fork和Join两个阶段，充分利用CPU资源</li>
<li>详情请见：<code>ForkJoin</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountDownLatch</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105935307">https://blog.csdn.net/qq_43040688/article/details/105935307</a></td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105937169">https://blog.csdn.net/qq_43040688/article/details/105937169</a></td>
</tr>
<tr>
<td>Phaser</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106033183">https://blog.csdn.net/qq_43040688/article/details/106033183</a></td>
</tr>
<tr>
<td>Exchanger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105955788">https://blog.csdn.net/qq_43040688/article/details/105955788</a></td>
</tr>
<tr>
<td>Semaphore</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105956731">https://blog.csdn.net/qq_43040688/article/details/105956731</a></td>
</tr>
<tr>
<td>ReentrantLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105958719">https://blog.csdn.net/qq_43040688/article/details/105958719</a></td>
</tr>
<tr>
<td>读写锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105975257">https://blog.csdn.net/qq_43040688/article/details/105975257</a></td>
</tr>
<tr>
<td>StampedLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106026847">https://blog.csdn.net/qq_43040688/article/details/106026847</a></td>
</tr>
<tr>
<td>三种锁的比较</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032189">https://blog.csdn.net/qq_43040688/article/details/106032189</a></td>
</tr>
<tr>
<td>ForkJoin</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032309">https://blog.csdn.net/qq_43040688/article/details/106032309</a></td>
</tr>
</tbody>
</table>
<h4 id="exectors框架">Exectors框架</h4>
<blockquote>
<p>首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。</p>
</blockquote>
<p><strong>ThreadPoolExecutor</strong></p>
<ul>
<li>创建线程池有七大参数，<code>特别重要</code></li>
<li>有四种拒绝策略</li>
<li>四种阻塞队列</li>
<li>一些调试的API</li>
<li>关闭线程池的注意事项</li>
<li>详情请见：<code>ThreadPoolExecutor</code></li>
</ul>
<p><strong>Executors</strong><br>
用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：</p>
<ul>
<li>newCachedThreadPool</li>
<li>newFixedThreadPool</li>
<li>newScheduledThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newWorkStealingPool</li>
<li>详情请见：<code>Executors</code></li>
</ul>
<p><strong>CompletionService</strong></p>
<ul>
<li>用来增强线程池，主要思想是：<code>执行一批任务，先执行的，先获取结果</code></li>
<li>实现的子类是：<code>ExecutorCompletionService</code></li>
<li>详情请见：<code>CompletionService</code></li>
</ul>
<p><strong>CompleableFuture</strong></p>
<ul>
<li>可以进行串联的操作，即利用上一个任务的结果，执行下一个任务</li>
<li>进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果</li>
<li>可以不需要调用者主动获取结果，而进行回调</li>
<li>执行一批任务时，获取的Future是按照任务完成的顺序</li>
<li>创建CompleableFuture有多种方式，最多的是<code>runAsync</code>和<code>supplyAsync</code></li>
<li>API分为组合方法、中转方法和终结方法</li>
<li>详情请见：<code>CompleableFuture</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolExecutor</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106041236">https://blog.csdn.net/qq_43040688/article/details/106041236</a></td>
</tr>
<tr>
<td>Executors</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106046629">https://blog.csdn.net/qq_43040688/article/details/106046629</a></td>
</tr>
<tr>
<td>CompletionService</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106058225">https://blog.csdn.net/qq_43040688/article/details/106058225</a></td>
</tr>
<tr>
<td>CompleableFuture</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106061776">https://blog.csdn.net/qq_43040688/article/details/106061776</a></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMQ监控平台（附网盘链接）]]></title>
        <id>https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/</id>
        <link href="https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/">
        </link>
        <updated>2020-06-16T12:01:12.000Z</updated>
        <content type="html"><![CDATA[<p><code>RocketMQ</code>有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，先将<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>拉到本地，因为我们需要自己对<code>rocketmq-console</code>进行编译打包运行。</p>
<p>在linux环境下，使用<code>nohub java -jar xxxx &amp;</code>  启动，为了防止端口冲突，已经修改其端口为<strong>9999</strong></p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA">https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA</a><br>
提取码：jpg0</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020053110115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQwNjg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="352-下载并编译打包">3.5.2 下载并编译打包</h3>
<pre><code class="language-sh">git clone https://github.com/apache/rocketmq-externals
cd rocketmq-console
mvn clean package -Dmaven.test.skip=true
</code></pre>
<p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：</p>
<pre><code class="language-sh">rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876
</code></pre>
<p>启动rocketmq-console：</p>
<pre><code class="language-sh">java -jar rocketmq-console-ng-1.0.0.jar
</code></pre>
<p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200531101225351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQwNjg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
</feed>