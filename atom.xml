<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-07-03T03:29:56.686Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[Java集合面试题总结]]></title>
        <id>https://xzzz2020.github.io/post/D60cWKdQu/</id>
        <link href="https://xzzz2020.github.io/post/D60cWKdQu/">
        </link>
        <updated>2020-07-03T03:27:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E4%B8%BB%E8%A6%81%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0">一、 主要容器概述</a></li>
<li><a href="#%E4%BA%8C-list">二、 List</a>
<ul>
<li><a href="#1-arraylist">1. ArrayList</a></li>
<li><a href="#2-linkedlist">2. LinkedList</a></li>
<li><a href="#3-vector">3. Vector</a></li>
<li><a href="#4-arraylist-%E4%B8%8E-linkedlist-%E5%BC%82%E5%90%8C">4. ArrayList 与 LinkedList 异同</a></li>
<li><a href="#5-arraylist%E5%92%8Cvector%E7%9A%84%E5%8C%BA%E5%88%AB">5. ArrayList和Vector的区别</a></li>
<li><a href="#6-systemarraycopy%E5%92%8C-arrayscopyof">6. System.arraycopy()和 Arrays.copyOf()</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-set">三、 Set</a>
<ul>
<li><a href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8">1. 哈希表</a></li>
<li><a href="#2-hashset">2. HashSet</a></li>
<li><a href="#3-hashcode">3. hashCode()</a></li>
<li><a href="#4-treeset">4. TreeSet</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-map">四、 Map</a>
<ul>
<li><a href="#1-hashmap">1. HashMap</a></li>
<li><a href="#2-hashtable">2. HashTable</a></li>
<li><a href="#3-linkedhashmap">3. LinkedHashMap</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-collections%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">五、 Collections常用方法</a>
<ul>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C">查找,替换操作</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6">同步控制</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88">设置不可变集合</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-主要容器概述">一、 主要容器概述</h2>
<blockquote>
<p>注意Collection是一个接口，是List和Set的公共接口，Collections是一个工具类</p>
</blockquote>
<p><strong>Java容器主要有三个</strong>：</p>
<ul>
<li><strong>List</strong>:是一个有序集合，可以放重复的数据</li>
<li><strong>Set</strong>:是一个无序集合，不允许放重复的数据</li>
<li><strong>Map</strong>:是一个无序集合，集合中包含一个键对象，-一个值对象，键对象不允许重复，值对象可以重复(身份证号-姓名)</li>
</ul>
<p><strong>size，length，length ()区别？</strong></p>
<ul>
<li>size()是集合中使用，统计集合中元素的个数</li>
<li>length是数组的一个成员属性</li>
<li>length ()是String的一个方法</li>
</ul>
<p><strong>Iterator</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean hasNext()</td>
<td>判断集合中是否还有下一个元素</td>
</tr>
<tr>
<td>Object next()</td>
<td>返回下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>从集合中删除一个由 next()方法返回的元素</td>
</tr>
</tbody>
</table>
<h2 id="二-list">二、 List</h2>
<ul>
<li><strong>ArrayList</strong>：查询数据比较快，添加和删除数据比较慢(基于可变数组)</li>
<li><strong>LinkedList</strong>：查询数据比较慢，添加和删除数据比较快（基于链表数据结构）</li>
</ul>
<h3 id="1-arraylist">1. ArrayList</h3>
<blockquote>
<p>查找比较快，增删比较慢</p>
</blockquote>
<ul>
<li>底层是基于数组。</li>
<li>默认容量是10</li>
<li>每次扩容1.5倍</li>
<li>如果增加 0.5 倍后的新容量超过限制的容量，则用所需的最小容量与限制的容量进行判断，超过则指定为 Integer 的最大值</li>
<li>通过数组的复制将原数据复制到一个更大(新的容量大小)的数组</li>
</ul>
<p><strong>如何保证线程安全？</strong></p>
<ul>
<li>继承ArrayList，重写其中的方法</li>
<li><code>List list = Collections.synchronizedList(new ArrayList());</code></li>
</ul>
<h3 id="2-linkedlist">2. LinkedList</h3>
<blockquote>
<p>增删比较快，查找比较慢</p>
</blockquote>
<ul>
<li>
<p>基于链表的，除了存放数据，还需要存放指针，所以<strong>占用的空间会大一些</strong></p>
</li>
<li>
<p>它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p>
</li>
<li>
<p>不是线程安全的</p>
</li>
</ul>
<h3 id="3-vector">3. Vector</h3>
<p>Vector与 ArrayList 一样，也是通过数组实现的，<strong>不同的是它支持线程的同步</strong>，即某一时刻只有一 个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p>
<h3 id="4-arraylist-与-linkedlist-异同">4. ArrayList 与 LinkedList 异同</h3>
<ul>
<li>
<p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p>
</li>
<li>
<p><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组； LinkedList 底层使用的是双向链表数据结构JDK1.6之前为循环链表， JDK1.7 取消了循环。注意双向链表和双向循环链表的区别：）；</p>
</li>
<li>
<p><strong>插入和删除是否受元素位置的影响</strong>：</p>
<ul>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 add(Ee) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</li>
</ul>
</li>
<li>
<p><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就</p>
</li>
</ul>
<h3 id="5-arraylist和vector的区别">5. ArrayList和Vector的区别</h3>
<ul>
<li><strong>Vector 类的所有方法都是同步的</strong>。可以由两个线程安全地访问一个 Vector 对象、但是一个线程访问 Vector的话代码要在同步操作上耗费大量的时间。</li>
<li><strong>Arraylist 不是同步的</strong>，所以在不需要保证线程安全时时建议使用 ArrayList。【CopyOnWriteArrayList 是同步的】。</li>
</ul>
<h3 id="6-systemarraycopy和-arrayscopyof">6. System.arraycopy()和 Arrays.copyOf()</h3>
<ol>
<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>
<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。</li>
</ol>
<h2 id="三-set">三、 Set</h2>
<p><strong>在Set家族中，常用的有三种</strong>：</p>
<ul>
<li><strong>HashSet</strong>: 采用 Hashmap 的 key 来储存元素，主要特点是无序的，基本操作都是 O(1) 的时间复杂度，很快。</li>
<li><strong>LinkedHashSet</strong>: 这个是一个 HashSet + LinkedList 的结构，特点就是既拥有了 O(1) 的时间复杂度，又能够保留插入的顺序。</li>
<li><strong>TreeSet</strong>: 采用红黑树结构，特点是可以有序，可以用自然排序或者自定义比较器来排序；缺点就是查询速度没有 HashSet 快。</li>
</ul>
<h3 id="1-哈希表">1. 哈希表</h3>
<p>哈希表是一种数据结构，哈希表能够提供快速存取操作。<strong>哈希表是基于数组的，所以也存在缺点，数</strong><br>
<strong>组一旦创建将不能扩展。</strong></p>
<p>正常的数组，如果需要查询某个值，需要对数组进行遍历，只是一种线性查找，查找的速度比较慢。<br>
如果数组中的元素值和下标能够存在明确的对应关系，那么<strong>通过数组元素的值就可以换算出数据元素的下</strong><br>
**标，通过下标就可以快数定位数组元素，这样的数组就是哈希表。**一张哈希表：</p>
<table>
<thead>
<tr>
<th>元素值</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><strong>以上我们的示例元素值和下标的关系为</strong>：</p>
<ul>
<li>
<p>元素下标=元素值-10，此时的示例 hashcode 就是和数组下标一致了,取得 hashcode 方法如下：</p>
<pre><code class="language-java">//取得 hashCode
pubic int hashCode(int value) {
	return value – 10;
}
</code></pre>
</li>
</ul>
<h3 id="2-hashset">2. HashSet</h3>
<ul>
<li>HashSet中的数据是无序的不可重复的。</li>
<li>采用 Hashmap 的 key 来储存元素</li>
</ul>
<h3 id="3-hashcode">3. hashCode()</h3>
<blockquote>
<p>覆盖了 equals 和 hashCode，当 hashCode 相同，它会调用 equals 进行比较，如果 equals 比较相等将不加把此元素加入到 Set 中</p>
<p>但 equals 比较不相等会重新根据 hashCode 换算位置仍然会将该元素加入进去的。</p>
</blockquote>
<p><strong>hashCode() 与 equals() 的相关规定</strong>：</p>
<ul>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li>因此， equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
<p><strong>再次强调：特别是向 HashSet 或 HashMap 中加入数据时必须同时覆盖 equals 和 hashCode 方法，应该</strong><br>
<strong>养成一种习惯覆盖 equals 的同时最好同时覆盖 hashCode</strong></p>
<p><strong>Java 要求</strong>：</p>
<ul>
<li>两个对象 equals 相等，那么它的 hashcode 相等</li>
<li>两个对象 equals 不相等，那么它的 hashcode 并不要求它不相等，但一般建议不相等hashcode 相等不代表两个对象相等（采用 equals 比较）</li>
</ul>
<p><strong>为什么重写 equals() 就必须要重写 hashCode()？</strong></p>
<ul>
<li>当key的hashCode()计算的数值相同时，就会出现hash冲突</li>
</ul>
<p><strong>处理 hash 冲突有哪些方法？Java 中用的哪一种？为什么？另一种方法你在工作中用过吗？在什么情况下用得多？</strong></p>
<p>见：<a href="https://xzzz2020.gitee.io/post/d0otbdSTy">https://xzzz2020.gitee.io/post/d0otbdSTy</a></p>
<h3 id="4-treeset">4. TreeSet</h3>
<ul>
<li>TreeSet 可以对 Set 集合进行排序， <strong>默认自然排序</strong>（即升序）</li>
<li>引用类型实现排序，需要实现Comparator或者Comparable</li>
</ul>
<p><strong>Comparable 和Comparator 的区别？</strong></p>
<ul>
<li>Comparable是自然排序，需要实体类实现，需要修改源代码</li>
<li>Comparator 是定制排序，不需要更改源代码，定义一个比较规则，传递给需要调用的方法中，将<strong>比较策略与数据分离，体现了策略模式</strong></li>
<li>Comparator 比Comparable 优先级更高</li>
</ul>
<h2 id="四-map">四、 Map</h2>
<blockquote>
<p>关于HashMap的全部面试题见：<a href="https://xzzz2020.gitee.io/post/hashmap">https://xzzz2020.gitee.io/post/hashmap</a></p>
</blockquote>
<p>Map 中可以放置键值对，也就是每一个元素都包含键对象和值对象， Map 实现较常用的为 HashMap，HashMap 对键对象的存取和 HashSet 一样，仍然采用的是哈希算法，所以如果使用自定类作为 Map 的键对象，必须复写 equals 和 hashCode 方法</p>
<p><strong>Map中常用的三个</strong>：</p>
<ul>
<li><strong>HashMap</strong>: 与 HashSet 对应，也是无序的，O(1)。</li>
<li><strong>LinkedHashMap</strong>: 这是一个「HashMap + 双向链表」的结构，落脚点是 HashMap，所以既拥有 HashMap 的所有特性还能有顺序。</li>
<li><strong>TreeMap</strong>: 是有序的，本质是用二叉搜索树来实现的。</li>
</ul>
<h3 id="1-hashmap">1. HashMap</h3>
<p><strong>实现原理</strong></p>
<ul>
<li>对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的</li>
<li>Hash函数跟HashMap的容量有关系</li>
</ul>
<p><strong>如果不同的元素的key算出了相同的哈希值，那么该怎么存放呢？</strong></p>
<ul>
<li>这就是哈希碰撞，即多个 key 对应了同一个桶。</li>
</ul>
<p><strong>HashMap 中是如何保证元素的唯一性的呢？即相同的元素会不会算出不同的哈希值呢？</strong></p>
<ul>
<li>通过 hashCode() 和 equals() 方法来保证元素的唯一性。</li>
</ul>
<h3 id="2-hashtable">2. HashTable</h3>
<blockquote>
<p>是一个线程安全的，但是锁住了全部数据效率低下</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzAzMTAxNTU0OTg0LnBuZw?x-oss-process=image/format,png" alt="image-20200703101554984" loading="lazy"></figure>
<p><strong>HashMap 和 Hashtable 的区别 ?</strong></p>
<ol>
<li>
<p><strong>线程是否安全</strong>： HashMap 是非线程安全的， HashTable 是线程安全的； HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
</li>
<li>
<p><strong>效率</strong>：因为线程安全的问题， HashMap 要比 HashTable 效率高一点。另外， HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li>
<p><strong>对 Null key 和 Null value 的支持</strong>： HashMap 中， null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</p>
</li>
<li>
<p><strong>初始容量大小和每次扩充容量大小的不同</strong>：<br>
①创建时如果不指定容量初始值， Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<br>
HashMap 默认的初始化大小为 16。 之后每次扩充，容量变为原来的 2 倍。<br>
②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2的幂次方大小（HashMap 中的 tableSizeFor() 方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
<li>
<p><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默<br>
认为 8）时，将链表转化为红黑树，以减少搜索时间。 Hashtable 没有这样的机制。</p>
</li>
</ol>
<h3 id="3-linkedhashmap">3. LinkedHashMap</h3>
<p>保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序 。</p>
<h2 id="五-collections常用方法">五、 Collections常用方法</h2>
<h3 id="排序">排序</h3>
<pre><code class="language-java">void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由 Comparator 控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当 distance 为正数时，将 list 后 distance 个元素整体移到前面。当 distance 为负数时，将 list 的前 distance 个元素整体移到后面。  
</code></pre>
<h3 id="查找替换操作">查找,替换操作</h3>
<pre><code class="language-java">int binarySearch(List list, Object key)//对 List 进行二分查找，返回索引，注意 List 必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。
int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由 Comparatator 类控制。
int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定 list 中
所有元素。 int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计 target 在 list 中第一次出现的索引，找不到则返回-1，
int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素  
</code></pre>
<h3 id="同步控制">同步控制</h3>
<p>Collections 提供了多个 synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决多<br>
线程并发访问集合时的线程安全问题。</p>
<p>我们知道 HashSet， TreeSet， ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。 Collections 提供了多个静态方法可以把他们包装成线程同步的集合</p>
<pre><code class="language-java">synchronizedCollection(Collection&lt;T&gt; c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List&lt;T&gt; list) //返回指定列表支持的同步（线程安全的） List。
synchronizedMap(Map&lt;K,V&gt; m) //返回由指定映射支持的同步（线程安全的） Map。
synchronizedSet(Set&lt;T&gt; s) //返回指定 set 支持的同步（线程安全的） set。
</code></pre>
<h3 id="设置不可变集合">设置不可变集合</h3>
<p><strong>emptyXxx()</strong>： 返回一个空的、不可变的集合对象，此处的集合既可以是 List，也可以是 Set，还可以是 Map。</p>
<p><strong>singletonXxx()</strong>： 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以<br>
是： List， Set， Map。</p>
<p><strong>unmodifiableXxx()</strong>： 返回指定集合对象的不可变视图，此处的集合可以是： List， Set， Map。 上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决Hash冲突的方法总结]]></title>
        <id>https://xzzz2020.github.io/post/d0otbdSTy/</id>
        <link href="https://xzzz2020.github.io/post/d0otbdSTy/">
        </link>
        <updated>2020-07-03T03:23:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-开放地址法">1. 开放地址法</h2>
<p>当出现冲突时，di是产生冲突的时候的增量序列，则将冲突的元素进行移动：</p>
<ul>
<li>-di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.</li>
<li>-di取值可能为1,-1,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2）称二次探测再散列。</li>
<li>-di取值可能为伪随机数列。称伪随机探测再散列。</li>
</ul>
<h2 id="2-多哈希法">2. 多哈希法</h2>
<p>设计多种哈希函数，可以避免冲突，但是冲突几率还是有的，函数设计的越好或越多都可以将几率降到最低。</p>
<h2 id="3-拉链法java中采用的">3. 拉链法（Java中采用的）</h2>
<p>利用一个额外的空间比如链表来保存冲突的元素，此法可以完全避免哈希函数的冲突。</p>
<h2 id="4-建立一个公共溢出区">4. 建立一个公共溢出区</h2>
<p>一旦发生冲突，都填入溢出表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap面试题总结]]></title>
        <id>https://xzzz2020.github.io/post/hashmap/</id>
        <link href="https://xzzz2020.github.io/post/hashmap/">
        </link>
        <updated>2020-07-03T03:17:21.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#hashmap%E7%AE%80%E4%BB%8B">HashMap简介</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88">问题集合</a>
<ul>
<li><a href="#%E9%97%AE%E7%82%B9%E4%B8%80%E4%BD%A0%E4%BA%86%E8%A7%A3hashmap%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97">问点一：你了解HashMap的底层数据结构吗？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E4%BA%8C%E4%B8%BA%E4%BB%80%E4%B9%88jdk-7%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8jdk8%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8Bhashmap%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84">问点二：为什么JDK 7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E4%B8%89hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84jdk7%E4%B8%8Ejdk8%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%90%97">问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E5%9B%9Bhashmap%E4%B8%AD%E7%9A%84%E9%94%AE%E5%80%BC%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E5%90%97%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86%E5%90%97">问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E4%BA%94hashmap%E4%B8%AD%E8%83%BDput%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84key%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%88%96%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD">问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E5%85%AD%E8%81%8A%E4%B8%80%E8%81%8Ajdk-7%E7%9A%84hashmap%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B">问点六：聊一聊JDK 7的HashMap中的“死锁”是怎么回事？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E4%B8%83hashmap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E6%88%96%E8%80%85%E4%B8%8D%E5%AE%89%E5%85%A8">问点七：HashMap是线程安全的吗？为什么安全或者不安全？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E5%85%AB%E4%BB%80%E4%B9%88-hashmap-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E6%98%AF075%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B6%85%E8%BF%878%E6%89%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91">问点八：什么 HashMap 的加载因子是0.75？为什么是超过“8”才用红黑树？</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E4%B9%9Dhashmap-hashtable-concurrenthashmap%E7%9A%84%E5%8C%BA%E5%88%AB">问点九：HashMap、HashTable、ConcurrentHashMap的区别</a></li>
<li><a href="#%E9%97%AE%E7%82%B9%E5%8D%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84-hashmap%E8%AE%B2%E8%AE%B2%E5%85%B6%E4%B8%AD%E7%9A%84-get%E5%92%8Cput-%E8%BF%87%E7%A8%8B">问点十：谈谈你理解的 HashMap，讲讲其中的 get和put 过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>由于HashMap在面试中是一个重点，内容十分多，需要单独写一篇文章总结</p>
<p>HashMap在Jdk1.7与1.8之中有很大区别！！</p>
</blockquote>
<h2 id="hashmap简介">HashMap简介</h2>
<p><code>HashMap</code> 是用来存储数据的，它底层在<code>JDK 1.7</code>是<strong>数组+链表</strong>实现的，而<code>JDK 1.8</code>是使用<strong>数组+链表+红黑树</strong>实现，通过对 <code>key</code> 进行哈希计算等操作后得到数组下标，把 <code>value</code> 等信息存放在<strong>链表</strong>或<strong>红黑树</strong>存在此位置。</p>
<p>如果两个不同的 <code>key</code> 运算后获取的数组下标一致，就出现了<strong>哈希冲突</strong>。数组默认长度是<strong>16</strong>，如果实际数组长度超过一定的值，就会进行<strong>扩容</strong>。</p>
<h2 id="问题集合">问题集合</h2>
<h3 id="问点一你了解hashmap的底层数据结构吗">问点一：你了解HashMap的底层数据结构吗？</h3>
<blockquote>
<p>在JDK1.7使用的是<strong>数组+链表</strong>的实现，在JDK1.8中使用的是<strong>数组+链表+红黑树</strong></p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/640" alt="img" style="zoom: 67%;" />
<img src="https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKlhF6p8tTEWMiaxZ0BKpVc0w0GALrnTniccx148yicUk62MKibzZIj54fDx9F6icXCXHpRQLevrGFTbPQZw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:67%;" />
<h3 id="问点二为什么jdk-7使用数组链表jdk8中为什么要使用红黑树哈希冲突是怎么回事hashmap又是怎么解决的">问点二：为什么JDK 7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？</h3>
<blockquote>
<ul>
<li>JDK 7使用数组+链表，是因为HashMap是根据Key计算Hash值，从而得到哈希表的索引下标，而哈希表本质是数组实现。当出现Hash冲突时，则一个桶可能需要存放多个数据。HashMap将会根据equals()方法，判断Hash冲突的Key是否是同一个值，此时如果仍然不相同，就会利用头插法，将出现Hash冲突的Key+Value存放在链表上。</li>
<li>但是如果一个链表比较长，那么查询的效率将会降低，所以JDK8中又使用了红黑树来解决链表过长导致查询效率变差的问题，会在一个桶上链表长度为8时，进行树化。但是树化的时候，会判断当前的长度是否小于64，如果小于，则不进行树化，而是选择进行一次扩容，因为扩容的时候会使哈希表长度增加，hash值会重新计算，将重新打乱当前的元素排列，分配到新的空间上，这样也避免了链表过长。</li>
</ul>
</blockquote>
<p>对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的。</p>
<pre><code class="language-java">//key 进行哈希计算
int hash = hash(key);
//获取数组下标
int i = indexFor(hash, table.length);
</code></pre>
<p>通过计算后的下标，从而得到数组的对应下标的位置，最后把k，v值存进去，同样的当再次第二次存值的时候，同样把<code>k，v</code>传进来，当k再次进行计算出数组下标<code>index</code>，有可能和第一次计算的<code>index</code>的值相同。</p>
<p>但是，两次的需要存进去的<code>value</code>值是不同的，这就出现了同一个数组后面有一条链表，会比较链表上的每一个<code>value</code>值与当前的<code>value</code>是否相同，若是不相同，通过<strong>头插法</strong>，将数值插入链表中。如下图所示：</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/640" alt="img" style="zoom: 67%;" />
<p>接下来通通过源码进行分析，在jdk 7插入的put 方法源码如下：</p>
<pre><code class="language-java">public V put(K key, V value) {
　　　　　//数组为空就进行初始化
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        if (key == null)
            return putForNullKey(value);
　　　　　//key 进行哈希计算
        int hash = hash(key);
　　　　　//获取数组下标
        int i = indexFor(hash, table.length);
　　　　　//如果此下标有值，遍历链表上的元素，key 一致的话就替换 value 的值
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
　　　　　//新增一个key
        addEntry(hash, key, value, i);
        return null;
    }
</code></pre>
<p><code>put</code>方法中主要做了以下几件事：</p>
<ol>
<li>判断<code>table</code>数组是否为空，若为空进行初始化<code>table</code>数组。</li>
<li>判断key值是否为<code>null</code>，将null是作为<code>key</code>存进去。</li>
<li>若<code>key</code>不为空，通过<code>key</code>计算出数组下标，判断<code>table[i]</code>是否为空。</li>
<li>若是不为空通过链表循环，判断在链表中是否存在与该<code>key</code>相等，若是存在，直接将<code>value</code>替换成新的<code>value</code>。若是<code>table[i]</code>为空或者链表中不存在与之相同的<code>key</code>，就<code>addEntry(hash, key, value, i)</code>新增一个节点。</li>
</ol>
<p>接下来看看<code>addEntry(hash, key, value, i)</code>新增节点的源码如下：</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
//数组长度大于阈值且存在哈希冲突（即当前数组下标有元素），就将数组扩容至2倍
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }
        createEntry(hash, key, value, bucketIndex);
    }
</code></pre>
<p>这个方法很简单，直接就是判断当前数组的大小是否&gt;=<code>threshold</code>并且<code>table[bucketIndex]</code>是否为<code>null</code>。若成立扩容，然后rehash，重新得到新数组的下标值，最后 <code>createEntry(hash, key, value, bucketIndex)</code>创建新节点。</p>
<p>最后来看一下<code>createEntry(hash, key, value, bucketIndex)</code>创建新节点的源码如下：</p>
<pre><code class="language-java">void createEntry(int hash, K key, V value, int bucketIndex) {
　　//此位置有元素，就在链表头部插入新元素（头插法）
        Entry&lt;K,V&gt; e = table[bucketIndex];
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
        size++;
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzgwYmEzZTNmLTY3ODgtNDA5OC04NTlkLTQ2NThmNDExMTZjYi53ZWJw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<p>在<code>JDK 7</code>中，链表存储有一个缺点，就是当数据很多的时候，链表就会很长，每次查询都会遍历很长的链表。</p>
<p>因此在<code>JDK 8</code>中为了优化<code>HashMap</code>的查询效率，将内部的结构改为<strong>数组+链表+和红黑树</strong>，当一个哈希桶后面的链表长度<code>&gt;8</code>的时候，就会将链表转化为<strong>红黑树</strong>，红黑树是二分查找，提高了查询的效率。接下来通过<code>JDK 8</code>的<code>put</code>源码分析如下：</p>
<pre><code class="language-java">public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
}


final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
　　　　　//数组为空就初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
　　　　　//当前下标为空，就直接插入
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
　　　　　　　//key 相同就覆盖原来的值
            if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
　　　　　　　//树节点插入数据
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
　　　　　　　　　　　　//链表，尾插法插入数据
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
　　　　　　　　　　　　　　//链表长度超过8，就把链表转为红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
　　　　　　　　　　　　//key相同就覆盖原来的值
                    if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
　　　　　//数组长度大于阈值，就扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>
<p><strong>通过分析源码，上面的方法主要做了以下几件事</strong>：</p>
<ol>
<li>判断当前桶是否为空，空的就需要初始化（<code>resize</code> 中会判断是否进行初始化）。</li>
<li>根据当前 <code>key</code> 的 <code>hashcode</code> 定位到具体的桶中并判断是否为空，为空表明没有 <code>Hash</code> 冲突就直接在当前位置创建一个新桶即可。</li>
<li>如果当前桶有值（ <strong>Hash 冲突</strong>），那么就要比较当前桶中的 <code>key</code>、<code>key</code> 的 <code>hashcode</code> 与写入的 <code>key</code>是否相等，相等就赋值给 e。</li>
<li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li>
<li>如果是个链表，就需要将当前的 <code>key、value</code> 封装成一个新节点写入到当前桶的后面（形成链表）。</li>
<li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li>
<li>如果在遍历过程中找到 <code>key</code> 相同时直接退出遍历。</li>
<li>如果 <code>e != null</code> 就相当于存在相同的 <code>key</code>,那就需要将值覆盖。</li>
<li>最后判断是否需要进行扩容。</li>
</ol>
<p>继续看下 treeifyBin 的源码：</p>
<pre><code class="language-java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
        int n, index; Node&lt;K,V&gt; e;
　　　　　//链表转为红黑树时，若此时数组长度小于64，扩容数组
        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
            TreeNode&lt;K,V&gt; hd = null, tl = null;
　　　　　　　//链表转为树结构
            do {
                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }
</code></pre>
<p>由此可以看到1.8中，数组有两种情况会发生扩容：</p>
<ol>
<li>一是超过阈值</li>
<li>二是链表转为红黑树且数组元素小于64时</li>
</ol>
<p>由此在<code>jdk1.8</code>中，默认长度为<code>16</code>情况下，要么元素一直放在同一下标，链表转为红黑树且数组元素小于64时就会扩容，要么超过阈值<code>12</code>时才会扩容。</p>
<p>依据上面的源码分析，在<code>JDK 1.8</code>中<code>put</code>方法的执行的原理图如下</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzAyMDk0NDQxNDU4LnBuZw?x-oss-process=image/format,png" alt="image-20200702094441458" loading="lazy"></figure>
<h3 id="问点三hashmap的扩容机制是怎么样的jdk7与jdk8有什么不同吗">问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？</h3>
<blockquote>
<p><code>JDK 1.7</code>的扩容条件是<strong>数组长度大于阈值且存在哈希冲突</strong>，而<code>JDK 1.8</code>扩容条件是<strong>数组长度大于阈值</strong>或<strong>链表转为红黑树且数组元素小于64</strong>时，源码中的体现如下所示：</p>
</blockquote>
<p><strong>JDK1.7扩容源码</strong>：</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
　　　　　//数组长度大于阈值且存在哈希冲突（即当前数组下标有元素），就将数组扩容至2倍
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }
        createEntry(hash, key, value, bucketIndex);
    }
</code></pre>
<p><strong>JDK1.8扩容源码</strong>：</p>
<pre><code class="language-java">//数组长度大于阈值，就扩容
if (++size &gt; threshold)
      resize();

//链表转为红黑树时，若此时数组长度小于64，扩容数组
if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
      resize();
</code></pre>
<h3 id="问点四hashmap中的键值可以为null吗能简单说一下原理吗">问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？</h3>
<blockquote>
<p>JDK两个版本都可以。JDK1.7和1.8本质都是去寻找Hash值为0的那个桶，然后如果key为null，则直接替换值</p>
</blockquote>
<h3 id="问点五hashmap中能put两个相同的key吗为什么能或为什么不能">问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？</h3>
<blockquote>
<p>在<code>JDK7</code>和<code>JDK8</code>中的做法是一样的，若是存入的<code>key</code>值一样，就会将原来的key所对应的value值直接替换掉</p>
</blockquote>
<h3 id="问点六聊一聊jdk-7的hashmap中的死锁是怎么回事">问点六：聊一聊JDK 7的HashMap中的“死锁”是怎么回事？</h3>
<blockquote>
<p>首先JDK7采用的头插法，会有链表成环的问题，JDK采用的尾插法，不会有循环链表的问题。</p>
<p><code>HashMap</code>是线程不安全的，在<code>HashMap</code>的源码中并未对其操作进行同步执行，所以在并发访问的时候就会出现线程安全的问题。</p>
<p>JDK 7死锁出现在高并发的时候，此时两个线程都将对数据进行扩容，每次扩容的时候，会让链表翻转。</p>
</blockquote>
<p><code>transfer</code>函数源码（<code>transfer</code>函数是resize扩容方法中调用的另一个方法）：</p>
<pre><code class="language-java">void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry&lt;K,V&gt; e : table) {
    while(null != e) {
        Entry&lt;K,V&gt; next = e.next; ---------------------(1)
        if (rehash) {
            e.hash = null == e.key ? 0 : hash(e.key);
        }
        int i = indexFor(e.hash, newCapacity);
        e.next = newTable[i];
        newTable[i] = e;
        e = next;
    } // while
    }
}
</code></pre>
<p><strong>假设一个链表，A.next = B  , B.next = null</strong>：</p>
<ul>
<li>正常情况下，新扩容的数组应该是位null，然后A.next = newTable[i]，则<code>A.next = null</code>，newTable[i] = A ，B.next = newTable[i]，则<code>B.next = A</code>，newTable[i] = B</li>
<li>如果两个线程同时转换，此时已然会执行 A.next = newTable[i] , 则将<code>A.next = null变成A.next = B</code>，剩下过程一致，<code>出现循环链表</code></li>
</ul>
<h3 id="问点七hashmap是线程安全的吗为什么安全或者不安全">问点七：HashMap是线程安全的吗？为什么安全或者不安全？</h3>
<blockquote>
<p>不是线程安全的，比如会在扩容的时候产生循环链表；在put的时候会覆盖别的线程的值</p>
</blockquote>
<h3 id="问点八什么-hashmap-的加载因子是075为什么是超过8才用红黑树">问点八：什么 HashMap 的加载因子是0.75？为什么是超过“8”才用红黑树？</h3>
<blockquote>
<p>因为HashMap底层的数据结构是哈希表，在插入数据的时候会出现hash冲突，而HashMap的解决方式是使用拉链法，即采用额外的空间来解决冲突。</p>
<p>而选择加载因子是0.75主要跟数学上泊松分布有关系，选择的参数平均为0.5的泊松分布，计算出来当前加载因子是0.75，这更是空间与时间的一种选择折中。</p>
<p>而超过8才使用红黑树，源于该泊松分布计算出来的，一个节点哈希冲突8次的概率极为的小，几乎为不可能时间，这也是一次空间与时间的折中。</p>
</blockquote>
<p>​</p>
<pre><code class="language-java">//1个节点哈希冲突n次的概率
0:    0.60653066
1:    0.30326533
2:    0.07581633
3:    0.01263606
4:    0.00157952
5:    0.00015795
6:    0.00001316
7:    0.00000094
8:    0.00000006
</code></pre>
<h3 id="问点九hashmap-hashtable-concurrenthashmap的区别">问点九：HashMap、HashTable、ConcurrentHashMap的区别</h3>
<blockquote>
<p>HashMap是线程不安全的，在jdk1.7高并发的时候，可能会在扩容的时候，产生循环链表，所以在高并发的时候，不去使用。</p>
<p>HashTable是一个线程安全的，采用的是synchronize的方式，关键字加在方法上，即对当前HashTable对象加锁，会导致所有的数据加上锁。</p>
<p>ConcurrentHashMap在JDK1.7的时候使用的是Segment分段锁的思想，将数据分成段，每个段都有个可重入锁，则多线程的时候不会影响到其他线程访问其他段的数据。</p>
<p>ConcurrentHashMap在JDK1.8的时候使用的是CAS+synchronized方式，抛弃了Segment分段锁的思想，CAS是一个乐观锁，则在不加锁情况下实现赋值，在当前节点为空的时候，会采用CAS的方式添加节点；而用synchronized而不用是可重入锁的原因是因为官方对synchronized做了很多优化。</p>
</blockquote>
<p><code>HashTable</code>其中使用synchronize来保证线程安全，即当有一个线程拥有锁的时候，其他的线程都会进入阻塞或者轮询状态,这样会使得效率越来越低。</p>
<p>而<code>ConcurrentHashMapMap</code>的锁分段技术可以有效的提高并发访问率，<code>HashTable</code>访问效率低下的原因，就是因为所有的线程在竞争同一把锁。</p>
<p>如果容器中有多把锁，不同的锁锁定不同的位置，这样线程间就不会存在锁的竞争，这样就可以有效的提高并发访问效率,这就是<code>ConcurrentHashMap</code>所使用的锁分段技术将数据一段一段的存储，为每一段都配一把锁，当一个线程只是占用其中的一个数据段时,其他段的数据也能被其他线程访问。</p>
<p>在JDK1.7中currentHashMap采用的是<strong>Segment分段锁的思想</strong>方式实现：</p>
<ul>
<li>Segment是将数据分成段，默认是16，每个段都有一把锁，则理论最高支持16个线程并发</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzAzMDkzMjI2ODMxLnBuZw?x-oss-process=image/format,png" alt="image-20200703093226831" loading="lazy"></figure>
<p>JDK1.8的currentHashMap采用的是**数组+链表+红黑树，抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized **方式实现：</p>
<ul>
<li>
<p>CAS，是一个乐观锁，他主要思想是<strong>比较然后再执行操作</strong>，比较的是内存的值和预期的原值是否一致，如果不一致，则需要自旋获取新值，但是CAS的最大问题就是可能出现ABA的问题。</p>
</li>
<li>
<p>在<code>no lock when adding to empty bin</code> ，也就是桶为空的时候采用CAS方式添加数据，而不为空的时候采用synchronized 的方式</p>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzAzMDkzODAzNDMwLnBuZw?x-oss-process=image/format,png" alt="image-20200703093803430" loading="lazy"></figure>
</li>
</ul>
<h3 id="问点十谈谈你理解的-hashmap讲讲其中的-get和put-过程">问点十：谈谈你理解的 HashMap，讲讲其中的 get和put 过程</h3>
<p><strong>put方法</strong>：</p>
<ul>
<li>考虑是否要初始化</li>
<li>根据key计算哈希值，找到hash表对应的索引</li>
<li>然后判断是否出现的hash冲突，如果没有则直接插入，查看是否需要扩容</li>
<li>JDK1.7出现hash冲突直接插入链表中即可</li>
<li>JDK1.8出现hash冲突，需要先判断当前是红黑树还是链表，对于链表可能会有一个树化的过程</li>
</ul>
<p><strong>get方法</strong>：</p>
<ul>
<li>思路与上面一致，只是少了一个扩容和树化的过程</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzAyMDk0NDQxNDU4LnBuZw?x-oss-process=image/format,png" alt="image-20200702094441458" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaSE基础知识面试考点总结]]></title>
        <id>https://xzzz2020.github.io/post/amjJC-n_8/</id>
        <link href="https://xzzz2020.github.io/post/amjJC-n_8/">
        </link>
        <updated>2020-06-28T04:01:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%A6%82%E8%BF%B0">一、 概述</a>
<ul>
<li><a href="#1-jdk%E7%89%88%E6%9C%AC">1. JDK版本</a></li>
<li><a href="#2-java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">2. Java语言特性</a></li>
<li><a href="#3-java%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">3. Java的加载与执行过程</a></li>
<li><a href="#4-jvm-jdk%E5%92%8Cjre%E7%9A%84%E5%8C%BA%E5%88%AB">4. JVM、JDK和JRE的区别</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">二、Java语言基础</a>
<ul>
<li><a href="#1-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">1. 八种基本类型</a></li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">2. 字符编码</a></li>
<li><a href="#3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">3. 类型转换</a></li>
<li><a href="#4-%E8%BF%90%E7%AE%97%E7%AC%A6">4. 运算符</a></li>
<li><a href="#5-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">5. 控制语句</a></li>
<li><a href="#6-%E6%96%B9%E6%B3%95">6. 方法</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">三、 面向对象</a>
<ul>
<li><a href="#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB">1. 面向过程与面向对象的区别</a></li>
<li><a href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81">2. 面向对象特征</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1">抽象</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">3. 参数传递</a></li>
<li><a href="#4-%E5%85%B3%E9%94%AE%E5%AD%97">4. 关键字</a>
<ul>
<li><a href="#this-%E5%85%B3%E9%94%AE%E5%AD%97">this 关键字：</a></li>
<li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li>
<li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a></li>
<li><a href="#final%E5%85%B3%E9%94%AE%E5%AD%97">final关键字</a></li>
</ul>
</li>
<li><a href="#5-%E4%BB%A3%E7%A0%81%E5%9D%97">5. 代码块</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97">静态代码块</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97">实例语句块</a></li>
</ul>
</li>
<li><a href="#6-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">6. 类的继承</a></li>
<li><a href="#7-static-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%88%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">7. static、构造方法和父子类的调用顺序</a></li>
<li><a href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3">8. 抽象类和接口（***）</a>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
</ul>
</li>
<li><a href="#9-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">9. 类之间的关系</a></li>
<li><a href="#10-object%E7%B1%BB">10. Object类</a>
<ul>
<li><a href="#equals">equals</a></li>
<li><a href="#finalize">finalize</a></li>
</ul>
</li>
<li><a href="#11-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90">11. 访问控制权限</a></li>
<li><a href="#12-%E5%86%85%E9%83%A8%E7%B1%BB">12 内部类</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB">实例内部类</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><strong>静态内部类</strong></a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%BC%82%E5%B8%B8">四、异常</a>
<ul>
<li><a href="#1-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB">1. 异常的体系</a></li>
<li><a href="#2-%E8%AF%B4%E5%87%BA%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8">2. 说出几个常见的异常</a></li>
<li><a href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">3. 异常处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>该文章是博主采集于各大博文，用于复习和总结相关知识点，将会持续的收集和更新。</p>
</blockquote>
<h2 id="一-概述">一、 概述</h2>
<h3 id="1-jdk版本">1. JDK版本</h3>
<blockquote>
<p>目前只维护两个JDK版本，一个是8，一个是11（2018年）</p>
</blockquote>
<h3 id="2-java语言特性">2. Java语言特性</h3>
<ul>
<li><strong>可移植性，跨平台</strong>，因为Java有一个JVM虚拟机，虚拟机负责执行字节码文件</li>
<li><strong>健壮性</strong>，具有GC，有自动垃圾回收机制</li>
</ul>
<h3 id="3-java的加载与执行过程">3. Java的加载与执行过程</h3>
<ul>
<li>T.java（源文件）通过javac命令变成字节码文件</li>
<li>字节码文件通过类加载器加载到JVM中</li>
<li>JVM屏蔽了和操作系统打交道的操作</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL0phdmElMjAlRTclQTglOEIlRTUlQkElOEYlRTglQkYlOTAlRTglQTElOEMlRTglQkYlODclRTclQTglOEItMS5wbmc?x-oss-process=image/format,png" alt="Java程序运行过程" loading="lazy"></figure>
<h3 id="4-jvm-jdk和jre的区别">4. JVM、JDK和JRE的区别</h3>
<p><strong>Java虚拟机（JVM）</strong></p>
<ul>
<li>是运行 Java  字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM  实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li>
</ul>
<p><strong>JDK</strong></p>
<ul>
<li>是Java Development Kit，它是功能齐全的Java SDK。<code>它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</code></li>
</ul>
<p><strong>JRE</strong></p>
<ul>
<li><code>是 Java运行时环境。 它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。</code></li>
<li>但是，它不能用于创建新程序。</li>
</ul>
<h2 id="二-java语言基础">二、Java语言基础</h2>
<h3 id="1-八种基本类型">1. 八种基本类型</h3>
<blockquote>
<p>八种基本数据类型：byte、short、int、long、float、double、boolean、char。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNjI4MTEzMzQ4NTE1LnBuZw?x-oss-process=image/format,png" alt="image-20200628113348515" loading="lazy"></figure>
<p><strong>一个字节等于8位</strong></p>
<p><strong>IEE754标准（32位）</strong>：1位是符号位，8位是阶码用移码表示，23位尾数</p>
<h3 id="2-字符编码">2. 字符编码</h3>
<blockquote>
<p>类型可以存放一个汉字， java 中的 char 使用 utf-16 编码</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">编码名称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII 字符编码</td>
<td style="text-align:center">只支持英文字母、标点符号、数字字符等， ASCII 码占用 1 个字节，所以 ASCII 码最多可以表示 256 个字符. 小 a 97 大 A 65,’0’是 48</td>
</tr>
<tr>
<td style="text-align:center">ISO-8859-1</td>
<td style="text-align:center">有称 latin-1,是国际化标准或组织 ISO 制定的，主要为了西欧语言中的字符 编码，和 ASCII 兼容，仍不支持中文</td>
</tr>
<tr>
<td style="text-align:center">GB2312/GBK/GB18030</td>
<td style="text-align:center">主要是汉字编码，三种编码从容量上看是包含关系 简体中文： GBK &lt; GB2312 &lt; GB18030 繁体中文： Big5【大五码】</td>
</tr>
<tr>
<td style="text-align:center">unicode</td>
<td style="text-align:center">Unicode 统 一 了 全 世 界 上 的 所 有 文 字 编 码 ， unicode 有 几 种 实 现 ： UTF-8,UTF-16,UTF-32 java 语言采用的是 Unicode 编码，所以在 java 中标识符也可以使用中文</td>
</tr>
</tbody>
</table>
<h3 id="3-类型转换">3. 类型转换</h3>
<ul>
<li>
<p>在 java 中基本类型可以相互转换， boolean 类型比较特殊不可以转换成其他类型</p>
</li>
<li>
<p>转换分为默认转换和强制转换:</p>
<ul>
<li>
<p>默认转换：容量小的类型会默认转换为容量大的类型</p>
<ul>
<li>
<p>byte--&gt;short--&gt; int--&gt;long--&gt;float--&gt;double</p>
</li>
<li>
<p><strong>byte、 short、 char 之间计算不会互相转换，首先先转换成 int</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>强制转换：</p>
<ul>
<li><strong>将容量大的类型转换成容量小的类型，需要进行强制转换</strong></li>
<li>注意：只要不超出范围可以将整型值直接赋值给 byte， short， char</li>
<li>在多种类型混合运算过程中，首先先将所有数据转换成容量最大的那种，再运算</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class DataTypeTest08
{
    public static void main(String[] args){
        long x = 100L;
        int y = x;//编译不通过
        
        long a = 2147483648L;
        int b = (int)a;
        System.out.println(b);//出现精度丢失问题，大类型--&gt;&gt;小类型会出现问题，输出-2147483648
        
        byte a = 1000;//出现错误， 1000 超出了 byte 的范围
        
        long g = 10;
        int h = g/3;//出现错误，多个数值在运算过程中，会转换成容量最大的类型

        byte h3 = (byte)(int)g/3;//考察优先级，将g先转换成int，再强转成byte，再除以3得到int，赋值错误
        byte h4 = (byte)(int)(g/3);//正确的
        byte h5 = (byte)g/3;//考察优先级，先转换成byte，再运算
        byte h6 = (byte)(g/3);//正确
        short h7 = (short)(g/3);//正确
        
        short i = 10;
        byte j = 5;
        short k = i + j;//错误的，short和byte运算，首先会转换成int再运算
    }
}
</code></pre>
<h3 id="4-运算符">4. 运算符</h3>
<p><strong>短路与和逻辑与的区别？</strong></p>
<p>短路与比逻辑与智能，短路与效率高。</p>
<p><strong>短路或和逻辑或的区别？</strong></p>
<p>短路或：左边的算子结果是 true，右边的表达式不执行，发生短路</p>
<p><strong>a += 3和 a = a + 3; 是一样的吗？</strong></p>
<ul>
<li><strong>结论(重点)</strong>：<code>扩展赋值运算符不改变运算结果的类型。初始类型和最终运算结果类型完全相同。</code></li>
</ul>
<pre><code class="language-java">public class OperatorTest09
{
    public static void main(String[] args){
        byte b = 10;
        //编译错误
        //b = b + 3;
        //修改
        b = (byte)(b + 3);
        System.out.println(b); //13
        b += 3;
        System.out.println(b); //16
        b += 10000; //等同于 b = (byte)(b + 10000);
        System.out.println(b); //32
    }
}
</code></pre>
<h3 id="5-控制语句">5. 控制语句</h3>
<p><strong>switch 语句</strong></p>
<ul>
<li>
<p>switch 也称为多重分支，具体格式如下<br>
switch (表达式) {<br>
case 值 1：<br>
语句<br>
break;<br>
case 值 2：<br>
语句<br>
break;<br>
default：<br>
语句<br>
Break;<br>
}</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>表达式的值只能为： char、 byte、 short、 int 类型（<strong>JDK7 以后支持 String</strong>）， boolean、 long、 float、</li>
<li><strong>double 都是非法的</strong></li>
<li><strong>break 语句可以省略,但会出现 switch 穿透</strong></li>
<li>default 语句也可以省略，一般不建议省略，并且放置在最后</li>
</ul>
<blockquote>
<p><strong>需求：</strong></p>
<p>假定系统给定学生的考试成绩，考试成绩可以带有小数。<br>
假定成绩是合法的[0-100]，请根据学生考试成绩判断该<br>
学生成绩等级：<br>
[90-100] A<br>
[80-90) B<br>
[70-80) C<br>
[60-70) D<br>
[0-60) E</p>
</blockquote>
<p><mark>以上业务只能使用 switch 语句完成，不允许使用 if 语句。</mark></p>
<pre><code class="language-java">public class SwitchTest04 {
    public static void main(String[] args) {
        //考试成绩合法
        double score = 100;
        //开始判断
        int grade = (int) (score / 10);//case条件不能为浮点数

        switch (grade) {
            case 10:
                System.out.println(&quot;A&quot;);
                break;
            case 9:
                System.out.println(&quot;A&quot;);
                break;
            case 8:
                System.out.println(&quot;B&quot;);
                break;
            case 7:
                System.out.println(&quot;C&quot;);
                break;
            case 6:
                System.out.println(&quot;D&quot;);
                break;
            default:
                System.out.println(&quot;E&quot;);
        }

        //重点： case 是可以合并的
        switch (grade) {
            case 10:
            case 9:
                System.out.println(&quot;A&quot;);
                break;
            case 8:
                System.out.println(&quot;B&quot;);
                break;
            case 7:
                System.out.println(&quot;C&quot;);
                break;
            case 6:
                System.out.println(&quot;D&quot;);
                break;
            default:
                System.out.println(&quot;E&quot;);
        }
    }
}
</code></pre>
</li>
</ul>
<p><strong>for语句</strong></p>
<pre><code class="language-java">for(;false;){//会出现编译错误，因为无法访问
    System.out.println(&quot;呵呵&quot;);
}
for(;true;){//死循环
	System.out.println(&quot;哈哈&quot;);
}
</code></pre>
<h3 id="6-方法">6. 方法</h3>
<p><strong>方法的返回值问题</strong>：</p>
<pre><code class="language-java">public class MethodTest07
{
    //缺少返回语句，程序编译时无法判断是否能走到else，无法编译通过
    public static int m1(){
        boolean flag = true;
        if(flag){
            return 1;
        }
    }

    //正确
    public static int m2(){
        boolean flag = true;
        if(flag){
            return 1;
        }else{
            return 0;
        }
    }

    //编译错误
    public static int m3(){
        boolean flag = false;
        if(flag){//
            return 1;//return后不能接任何语句
            System.out.println(&quot;??????????&quot;);
        }
        System.out.println(&quot;??????????&quot;);
        return 0;
        System.out.println(&quot;??????????&quot;);
    }
}
</code></pre>
<h2 id="三-面向对象">三、 面向对象</h2>
<h3 id="1-面向过程与面向对象的区别">1. 面向过程与面向对象的区别</h3>
<ul>
<li>
<p><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></p>
</li>
<li>
<p><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong></p>
</li>
</ul>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>
</blockquote>
<h3 id="2-面向对象特征">2. 面向对象特征</h3>
<h4 id="封装">封装</h4>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="继承">继承</h4>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态">多态</h4>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h4 id="抽象">抽象</h4>
<ul>
<li>
<p>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。</p>
</li>
<li>
<p>抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。</p>
</li>
</ul>
<h3 id="3-参数传递">3. 参数传递</h3>
<blockquote>
<p><mark>所有基本数据类型的都是值传递，其他类型的为址传递</mark></p>
</blockquote>
<h3 id="4-关键字">4. 关键字</h3>
<h4 id="this-关键字">this 关键字：</h4>
<ul>
<li>
<p>this 关键字指的是当前调用的对象， 只能用在构造函数和实例方法内部，还可以应用在成员变量的声明上， static 标识的方法里是不能使用 this 的。</p>
</li>
<li>
<p><strong>作用：代码复用。</strong></p>
</li>
</ul>
<h4 id="super-关键字">super 关键字</h4>
<ul>
<li>
<p><strong>调用父类的构造方法</strong></p>
<ul>
<li>
<p>没有显示地调用 super(); 父类的无参构造方法也执行</p>
</li>
<li>
<p>必须将 super 放到子类的构造函数的第一语句来调用父类的构造方法</p>
</li>
</ul>
</li>
<li>
<p><strong>调用父类的成员方法</strong></p>
<ul>
<li>需要注意： super 只能应用在成员方法和构造方法中，<strong>不能应用在静态方法中</strong>（和 this 是一样的），如果<strong>在构造方法中使用必须放在第一行</strong></li>
</ul>
</li>
</ul>
<p><strong>为什么会有 super 关键字？</strong></p>
<ul>
<li><code>因为子类必须要调用父类的构造方法，先把父类构造完成，因为子类依赖于父类，没有父，也就 没有子</code></li>
<li><code>有时需要在子类中显示的调用父类的成员方法</code></li>
</ul>
<p><strong>那么我们以前为什么没有看到 super，而且我们也有继承，如： Student 继承了 Person？</strong></p>
<ul>
<li>因为子类中我们没有显示的调用父类构造方法，那么他会默认调用父类的无参构造方法，此种情况下<br>
如果父类中没有无参构造方法，那么编译时将会失败</li>
</ul>
<blockquote>
<p><code>注意构造方法不存在覆盖的概念，构造方法可以重载</code></p>
</blockquote>
<h4 id="static-关键字">static 关键字</h4>
<p>可以用来修饰它可以用来修饰的<strong>成员变量</strong>和<strong>成员方法</strong>，<code>被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</code></p>
<h4 id="final关键字">final关键字</h4>
<p><strong>final 表示不可改变的含义</strong></p>
<ul>
<li>采用 final 修饰的类不能被继承</li>
<li>采用 final 修饰的方法不能被覆盖</li>
<li>采用 final 修饰的变量不能被修改</li>
<li>final 修饰的变量必须显示初始化<br>
局部变量： 一旦赋值不能重新赋值<br>
成员变量： 不能采用系统默认值，必须手动赋值<br>
如果修饰的引用，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的</li>
<li>构造方法不能被 final 修饰 会影响 JAVA 类的初始化:</li>
<li>final 定义的静态常量调用时不会执行 static 代码块等相关语句，这是由 java 虚拟机规定的。我们不<br>
需要了解的很深，有个概念就可以了</li>
</ul>
<p><strong>修饰引用变量：</strong></p>
<ul>
<li>final 修饰引用变量，<code>主要修饰的是变量的地址</code>，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的</li>
</ul>
<pre><code class="language-java">public class FinalTest05 {
    public static void main(String[] args) {
        Person p1 = new Person();
        //可以赋值
        p1.name = &quot;张三&quot;;
        System.out.println(p1.name);
        final Person p2 = new Person();
        p2.name = &quot;李四&quot;;
        System.out.println(p2.name);
        //不能编译通过
        //p2 采用 final 修饰，主要限制了 p2 指向堆区中的地址不能修改(也就是 p2 只能指向一个对象)
        //p2 指向的对象的属性是可以修改的
        p2 = new Person();
    }
}
class Person {
    String name;
}
</code></pre>
<p><strong>final 和 static 联合修饰实例变量==常量</strong> （尽量使用一个静态工具类抽取出常量）</p>
<ul>
<li>常量名要求全部大写[规范]</li>
<li>常量都是 public static final 的</li>
<li>常量在类加载的时候完成初始化，存储在 JVM 的方法区中</li>
<li>常量是值不可改变的变量</li>
</ul>
<h3 id="5-代码块">5. 代码块</h3>
<blockquote>
<p>静态属性和静态代码块按照代码顺序执行，实例代码块和成员属性同理</p>
</blockquote>
<h4 id="静态代码块">静态代码块</h4>
<p><strong>使用 static 关键字可以定义静态语句块，静态语句块具有以下特点</strong>：</p>
<ul>
<li>静态语句块在类加载时执行，在 main 方法执行之前就已经执行了。</li>
<li>类只加载一次，所以静态语句块也是只执行一次</li>
<li>一个类中可以编写多个静态语句块，执行顺序是： 自上而下依次执行。</li>
<li>静态语句块的使用时机：当程序需要<code>在类加载的时候就做一些事情，可以在静态语句块中来实现</code></li>
</ul>
<h4 id="实例语句块">实例语句块</h4>
<p><strong>实例语句块和静态代码块没有关系，实例语句块有以下特点</strong>：</p>
<ul>
<li>实例语句块在构造方法执行之前执行，构造函数执行一次，实例语句块对应执行一次。</li>
<li>每调用一次构造函数之前就会执行一次实例语句块</li>
<li>实例语句块可以编写多个，也是按照自上而下的顺序依次执行。</li>
<li>实例语句块使用时机： 当程序需要<code>在对象初始化时刻就做一些事情，可以在实例语句块中实现</code></li>
</ul>
<pre><code class="language-java">//静态语句块
static{
	System.out.println(1);
}

//实例语句块
{
	System.out.println(1);
}
</code></pre>
<h3 id="6-类的继承">6. 类的继承</h3>
<p><strong>如何实现Java多继承？</strong></p>
<p><strong>继承特征</strong>：</p>
<ul>
<li>
<p>继承是面向对象的重要概念，软件中的继承和现实中的继承概念是一样的</p>
</li>
<li>
<p>继承是<strong>实现软件可重用性的重要手段</strong>，如： A 继承 B， A 就拥有了 B 的所有特性，如现实世界中的儿子继承父亲的财产，儿子不用努力就有了财产，这就是重用性</p>
</li>
<li>
<p>Java 中<strong>只支持类的单继承</strong>，也就是说 A 只能继承 B， A 不能同时继承 C</p>
</li>
<li>
<p>Java 中的继承使用 extends 关键字，语法格式：</p>
<pre><code class="language-java">[修饰符] class 子类 extends 父类 {
    
}  
</code></pre>
</li>
</ul>
<p><strong>方法的重载的条件</strong></p>
<ul>
<li>方法名相同</li>
<li><strong>方法的参数类型，个数，顺序至少有一个不同</strong></li>
<li>方法的返回类型可以不同（不依靠返回类型来区分重载）</li>
<li>方法的修饰符可以不同，因为方法重载和修饰符没有任何关系</li>
<li><strong>方法重载只出现在同一个类中</strong></li>
</ul>
<p><strong>方法的覆盖(Override)的条件：</strong></p>
<ul>
<li><code>必须要有继承关系</code></li>
<li>覆盖只能出现在子类中，如果没有继承关系，不存在覆盖，只存在重载</li>
<li>在子类中被覆盖的方法，必须和父类中的方法完全一样，也就是方法名， 返回类型、参数列表，<br>
完全一样</li>
<li><strong>子类方法的访问权限不能小于父类方法的访问权限</strong></li>
<li><strong>子类方法不能抛出比父类方法更多的异常，但可以抛出父类方法异常的子异常</strong></li>
<li><strong>父类的静态方法不能被子类覆盖</strong></li>
<li><strong>父类的私有方法不能覆盖</strong></li>
<li><strong>覆盖是针对成员方法，而非属性</strong></li>
</ul>
<p><strong>为什么需要覆盖？</strong></p>
<ul>
<li>就是要改变父类的行为。</li>
<li>方法重写之后，“子类对象”执行的一定是重写之后的方法，也体现了就近原则</li>
</ul>
<h3 id="7-static-构造方法和父子类的调用顺序">7. static、构造方法和父子类的调用顺序</h3>
<p><strong>要点</strong>：</p>
<ul>
<li>静态的代码块一定比构造方法先执行</li>
<li>如果都是静态代码，一个类里面，按照先后顺序执行，<strong>父子之间，父类静态代码块先执行</strong></li>
<li><strong>静态代码只会执行一次</strong>，多次 new 新的对象，构造方法，非静态代码块会多次执行</li>
</ul>
<pre><code class="language-java">class Parent {
    static {
        System.out.println(&quot;父类的静态块&quot;);
    }
    private static String staticStr = getStaticStr();
    private String str = getStr();
    {
        System.out.println(&quot;父类的实例块&quot;);
    }
    public Parent() {
        System.out.println(&quot;父类的构造方法&quot;);
    }
    private static String getStaticStr() {
        System.out.println(&quot;父类的静态属性初始化&quot;);
        return null;
    }
    private String getStr() {
        System.out.println(&quot;父类的实例属性初始化&quot;);
        return null;
    }
}

class Child extends Parent {
    private static String staticStr = getStaticStr();

    static {
        System.out.println(&quot;子类的静态块&quot;);
    }

    {
        System.out.println(&quot;子类的实例块&quot;);
    }

    public Child() {
        System.out.println(&quot;子类的构造方法&quot;);
    }

    private String str = getStr();

    private static String getStaticStr() {
        System.out.println(&quot;子类的静态属性初始化&quot;);
        return null;
    }

    private String getStr() {
        System.out.println(&quot;子类的实例属性初始化&quot;);
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        new Child();
    }
}
</code></pre>
<p><strong>分析</strong>：</p>
<ul>
<li>
<p>首先先加载类到JVM的方法区中，则先加载静态的内容，比如静态代码块和静态属性，并且先加载父类，且按照代码顺序加载</p>
</li>
<li>
<p>接着加载对象到堆内存中，先加载父类的实例语句块和实例属性，按照父类优先，根据代码顺序加载，最后加载构造方法</p>
</li>
</ul>
<p><strong>执行结果</strong>：</p>
<pre><code class="language-xml">父类的静态块
父类的静态属性初始化
子类的静态属性初始化
子类的静态块
父类的实例属性初始化
父类的实例块
父类的构造方法
子类的实例块
子类的实例属性初始化
子类的构造方法
</code></pre>
<h3 id="8-抽象类和接口">8. 抽象类和接口（***）</h3>
<h4 id="抽象类">抽象类</h4>
<p>看我们以前示例中的 Person、 Student 和 Employee，从我们使用的角度来看主要对 Student 和 Employee 进行实例化， Person 中主要包含了一些公共的属性和方法，而 Person 我们通常不会实例化，所以我们可以把它<br>
定义成抽象的：</p>
<ul>
<li>
<p>在 java 中采用 abstract 关键字定义的类就是抽象类，采用 abstract 关键字定义的方法就是抽象方法</p>
</li>
<li>
<p>抽象的方法只需在抽象类中，提供声明，不需要实现</p>
</li>
<li>
<p><strong>如果一个类中含有抽象方法，那么这个类必须定义成抽象类，一个抽象类不一定含有抽象方法</strong></p>
</li>
<li>
<p>如果这个类是抽象的，那么这个类被子类继承，抽象方法必须被重写。如果在子类中不复写该抽象方法，那么必须将此类再次声明为抽象类</p>
</li>
<li>
<p>抽象的类是不能实例化的，就像现实世界中人其实是抽象的，张三、李四才是具体的</p>
</li>
<li>
<p><strong>抽象类不能被 final 修饰</strong></p>
</li>
<li>
<p><strong>抽象方法不能被 final 修饰，因为抽象方法就是被子类实现的</strong></p>
</li>
</ul>
<p>抽象类中可以包含方法实现，可以将一些公共的代码放到抽象类中，另外在抽象类中可以定义一些抽象的方法，这样就会存在一个约束，而子类必须实现我们定义的方法，如： teacher 必须实现 printInfo 方法， Student也必须实现 printInfo 方法，方法名称不能修改，必须为 printInfo，这样就能实现多态的机制，有了多态的机制，我们在运行期就可以动态的调用子类的方法。所以在运行期可以灵活的互换实现。</p>
<p><strong>抽象类和普通类的区别？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">抽象类</th>
<th style="text-align:center">普通类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不能被实例化，也就是使用new关键字</td>
<td style="text-align:center">可以被实例化</td>
</tr>
<tr>
<td style="text-align:center">权限限定于Public和Protected，因为需要子类去继承抽象类<br/>JDK 1.8以前，抽象类的方法默认访问权限为protected<br/>JDK 1.8时，抽象类的方法默认访问权限变为default</td>
<td style="text-align:center">没有权限限制</td>
</tr>
<tr>
<td style="text-align:center">如果一个类继承抽象类，则必须实现抽象类的抽象方法<br/>如果没有实现抽象方法，则该类必须定义成抽象类</td>
<td style="text-align:center">不强制实现父类的方法</td>
</tr>
</tbody>
</table>
<h4 id="接口">接口</h4>
<blockquote>
<p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
</blockquote>
<p>接口我们可以看作是抽象类的一种特殊情况，在接口中<strong>只能定义抽象的方法和常量(完全抽象)</strong></p>
<ul>
<li>接口中的方法默认都是 public abstract 的(可以省略写)，不能更改</li>
<li>接口中的变量默认都是 public static final 的(省略不写)，不能更改，所以必须显示的初始化<br>
<code>注意：接口里的所有数据都是 public 修饰的！</code></li>
<li>如果一个非抽象的类实现了接口，那么接口中所有的方法必须实现</li>
<li>一类可以实现多个接口，接口和接口之间支持也是多继承的 ,但接口之间不能实现</li>
</ul>
<p>在 java 中接口其实描述了<strong>类需要做的事情，类要遵循接口的定义来做事</strong>，使用接口到底有什么本质的好<br>
处？可以归纳为两点：</p>
<ul>
<li>采用接口明确的声明了它所能提供的服务</li>
<li>解决了 Java 单继承的问题</li>
</ul>
<p><strong>接口和抽象类的区别？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">接口</th>
<th style="text-align:center">抽象类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不能被实例化</td>
<td style="text-align:center">不能被实例化</td>
</tr>
<tr>
<td style="text-align:center">需要被子类实现，并实现接口的方法</td>
<td style="text-align:center">需要被子类继承，并实现抽象方法</td>
</tr>
<tr>
<td style="text-align:center">只能做方法的声明（JDK1.8之后允许方法体）</td>
<td style="text-align:center">可以做方法的声明，也可以做方法的实现</td>
</tr>
<tr>
<td style="text-align:center">如果子类不能实现接口中的所有方法，则该类只能是抽象类</td>
<td style="text-align:center">如果子类不能实现抽象类的所有抽象，则该类只能是抽象类</td>
</tr>
<tr>
<td style="text-align:center">属性只能是静态的常量</td>
<td style="text-align:center">没有限制</td>
</tr>
<tr>
<td style="text-align:center">接口与接口之间可以多继承</td>
<td style="text-align:center">只能单继承</td>
</tr>
</tbody>
</table>
<h3 id="9-类之间的关系">9. 类之间的关系</h3>
<p><strong>泛化关系</strong></p>
<ul>
<li>类与类之间的继承以及接口与接口之间的继承</li>
</ul>
<p><strong>实现关系</strong></p>
<ul>
<li>类对接口的实现</li>
</ul>
<p><strong>关联关系</strong></p>
<ul>
<li>
<p>一个类中属性是另个类</p>
<pre><code class="language-java">public class 学生 {
    private 班级 班级;
    // getter/setter
}
public class 班级 {
}
</code></pre>
</li>
</ul>
<p><strong>聚合关系</strong></p>
<ul>
<li>
<p>是关联关系的一种，有着较强的关联关系</p>
</li>
<li>
<p>在java中一个类是整体，使用对象数组包含另个类；另个类属于某个整体</p>
<pre><code class="language-java">public class 汽车 {
    private 轮胎集合 轮胎；
    //getter/setter
}
public class 轮胎 {
    private 汽车 汽车;
    //getter/setter
}
</code></pre>
</li>
</ul>
<p><strong>依赖关系</strong></p>
<ul>
<li>
<p>依赖关系是比关联关系弱的关系，在 java 语言中体现为<strong>返回值，参数，局部变量和静态方法调用</strong></p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Person person = new Person();
    }
}
class Person {
}
</code></pre>
</li>
</ul>
<h3 id="10-object类">10. Object类</h3>
<ul>
<li>Object 类是所有 Java 类的根基类</li>
<li>如果在类的声明中未使用 extends 关键字指明其基类，则默认基类为 Object 类</li>
</ul>
<h4 id="equals">equals</h4>
<p><strong>equals的源码是这样写的</strong>：</p>
<pre><code class="language-java">public boolean equals(Object obj) {
    //this - s1
    //obj - s2
    return (this == obj);
}
</code></pre>
<p>所以，默认情况下比较的是地址值，但是可以让我们覆写该方法，实现对象的比较。</p>
<p><strong>如何覆写equals方法？</strong></p>
<ul>
<li>首先为了提高效率，需要用==判断是否是同一个对象，如果是直接返回true</li>
<li>接着为了提高健壮性，判断是否对象是否是该类的一个对象，如果是，需要对其向下转型</li>
<li>最后是比较的逻辑</li>
</ul>
<pre><code class="language-java">public class ObjectDemo {
    public static void main(String args[]){
        Student student1 = new Student(&quot;生命壹号&quot;,22,&quot;成都&quot;);
        Student student2 = new Student(&quot;生命壹号&quot;,22,&quot;成都&quot;); 
        System.out.println(student1==student2);
        System.out.println(student1.equals(student2));
    }
 }
 class Student {
     private String name;
     private int age;
     private String address;
     public Student(String name,int age,String address){
         this.name = name;
         this.age = age;
         this.address = address;
     }
     //重写Object类中的equals方法（比较两个对象的值是否相等）
     public boolean equals(Object obj){
         //为了提高效率：如果两个内存地址相等，那么一定是指向同一个对内存中的对象，就无需比较两个对象的属性值（自己跟自己比，没啥意义嘛）
         if(this==obj){
             return true;
         }
         
         //为了提供程序的健壮性
         //我先判断一下，obj是不是学生的一个对象，如果是，再做向下转型，如果不是，直接返回false。
         //这个时候，我们要判断的是对象是否是某个类的对象?
         //记住一个格式：对象名 instanceof 类名。表示：判断该对象是否是该类的一个对象       
         if(!(obj instanceof Student)){        
             return false;                
         }
         
         //如果是就继续
         Student s = (Student)obj;//强制转换，即向下转型（毕竟Object类型没有具体的对象属性）        
         return this.name.equals(s.name) &amp;&amp; this.age == s.age &amp;&amp; this.address.equals(s.address);//判断两个对象的属性值是否相等
     }
 }
</code></pre>
<p><strong>==与 equals()区别？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">==</th>
<th style="text-align:center">equals()</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">等号比较的是值， 特别是比较引用类型，比较的是引用的内存地址的那个值</td>
<td style="text-align:center">默认源码使用的是==，但是可以通过覆写该方法，实现对象的比较</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于基本数据的包装类型（Byte, Short, Character，Integer， Float, Double， Long, Boolean）除了 Float和 Double 之外，其他的六种都是<strong>实现了常量池的</strong>，因此对于这些数据类型而言，一般我们<strong>也可以直接通过==来判断是否相等</strong></p>
</blockquote>
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        Integer a = 127;
        Integer b = 127;
        System.out.println(a==b);//true

        Integer c = 128;
        Integer d = 128;
        System.out.println(c==d);//false
    }
}
</code></pre>
<blockquote>
<p>因为 Integer 在常量池中的存储范围为[-128,127]， 127 在这范围内，因此是直接存储于常量池的，而<br>
128 不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以 m， n 分别指向了两个不同的<br>
对象地址，故而导致了不相等。</p>
</blockquote>
<h4 id="finalize">finalize</h4>
<p>当垃圾收集器将要收集某个垃圾对象时将会调用 finalize，<strong>建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行</strong></p>
<p>JVM当看到对象类含有finalize函数，会将该对象交给FinalizerThread处理，但是处理的时间不确定。</p>
<h3 id="11-访问控制权限">11. 访问控制权限</h3>
<p><strong>范围由大到小的排序</strong>：<code>public &gt; protected &gt; 缺省 &gt; private</code></p>
<blockquote>
<p>对类的修饰只有public和缺省，内部类除外</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">类的内部</th>
<th style="text-align:center">同一个包中</th>
<th style="text-align:center">子类</th>
<th style="text-align:center">任何地方</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"><code>Y</code></td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p><strong>总结为一句话</strong>：<code>private修饰的只能类的内部调用；缺省的可以在一个包中调用；protected扩展到了子类中，比如继承某个类，则可以使用那个类的属性和方法；public可以在任何地方访问。</code></p>
<h3 id="12-内部类">12 内部类</h3>
<p><strong>分为四种内部类</strong>：</p>
<ul>
<li><strong>实例内部类</strong>：在类的内部定义的普通类</li>
<li><strong>静态内部类</strong>：在类的内部定义的静态类</li>
<li><strong>局部内部类</strong>：在方法中定义的普通类</li>
<li><strong>匿名内部类</strong>：方法使用中定义的普通类，主要用来实现接口</li>
</ul>
<h4 id="实例内部类">实例内部类</h4>
<p><strong>特点</strong>：</p>
<ul>
<li>创建实例内部类，外部类的实例必须已经创建</li>
<li>实例内部类会持有外部类的引用，可以直接访问外部类的属性</li>
<li>不允许有静态声明</li>
</ul>
<pre><code class="language-java">public class OuterClass
{
    //静态变量
    private static String s1 = &quot;静态变量&quot;;
    //实例变量
    private String s2 = &quot;实例变量&quot;;
    //实例内部类
    public class InnerClass
    {
        //编译错误，实例内部类中不允许有静态的声明
        public static void m1(){}
        //实例方法
        public void m2(){
            System.out.println(s1);
            System.out.println(s2);
        }
    }
    //入口
    public static void main(String[] args){
        OuterClass oc = new OuterClass();
        InnerClass innerClass = oc.new InnerClass();//??
        innerClass.m2();
    }
}
</code></pre>
<h4 id="静态内部类"><strong>静态内部类</strong></h4>
<p><strong>特点</strong>：</p>
<ul>
<li>静态内部类不会持有外部的类的引用</li>
<li>创建时可以不用创建外部类，在静态内部类中只能直接访问外部类中所有的静态数据。</li>
<li>静态内部类等同于静态变量</li>
</ul>
<pre><code class="language-java">public class OuterClass
{
    //静态变量
    private static String s1 = &quot;静态变量&quot;;
    //实例变量
    private String s2 = &quot;实例变量&quot;;
    //静态内部类
    //静态内部类可以使用任何一个访问控制权限修饰符修饰。
    protected static class InnerClass{
        //静态方法
        public static void m1(){
            System.out.println(s1);
        //System.out.println(s2);
        }
        //实例方法
        public void m2(){
            System.out.println(s1);
        //System.out.println(s2);
        }
    } //入口
    public static void main(String[] args){
        OuterClass.InnerClass.m1();//外部类.可以省略
        InnerClass innerClass = new OuterClass.InnerClass();
        innerClass.m2();
    }
}
</code></pre>
<h4 id="局部内部类">局部内部类</h4>
<ul>
<li>局部内部类等同于局部变量</li>
<li>局部内部类是在方法体中声明的类，该类只能在方法体中使用</li>
<li>局部内部类不能使用 public 、 protected 、 private 修饰</li>
<li><code>局部内部类访问本地变量的时候，方法中的参数需要使用 final 修饰</code></li>
</ul>
<pre><code class="language-java">public class OuterClass {
    private int a = 100;
    //局部变量在内部类中使用必须采用 final 修饰
    public void method1(final int temp) {
        class Inner3 {
            int i1 = 10;
            //可以访问外部类的成员变量
            int i2 = a;
            int i3 = temp;
        }
        //使用内部类
        Inner3 inner3 = new Inner3();
        System.out.println(inner3.i1);
        System.out.println(inner3.i3);
    }
    public static void main(String[] args) {
        OuterClass out = new OuterClass ();
        out.method1(300);
    }
}
</code></pre>
<h4 id="匿名内部类">匿名内部类</h4>
<ul>
<li>是一种特殊的内部类，该类没有名字</li>
<li>通过new 关键字创建，并加上方法体</li>
<li>主要用于实现接口</li>
</ul>
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        //在方法中实现接口
        new Thread(new Runnable() {
            @Override
            public void run() {
                
            }
        }).run();
    }
}
</code></pre>
<h2 id="四-异常">四、异常</h2>
<blockquote>
<p>任意的异常都是在运行时发生的！！！</p>
</blockquote>
<h3 id="1-异常的体系">1. 异常的体系</h3>
<p><code>所有的异常都是Throwable的子类</code></p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNjI4MTA1MTE2MjM4LnBuZw?x-oss-process=image/format,png" alt="image-20200628105116238" loading="lazy"></figure>
<p><strong>Thorwable有两个直接子类Error和Exception</strong></p>
<p><strong>Error</strong>:</p>
<ul>
<li>在 Java 中只要 Error 发生了就一种结果——退出 JVM，例如 StackOverError</li>
</ul>
<p><strong>Exception的直接子类</strong>：</p>
<ul>
<li>
<p>Exception 的直接子类叫做<strong>编译时异常、受控异常、检查异常</strong>。它虽然叫做编译时异常，但是它不是发<br>
生在编译阶段的异常， 之所以叫做编译时异常是因为编译时异常要求必须在程序编译的阶段就手动的处理，如果不处理这些异常的话，程序无法编译通过。</p>
</li>
<li>
<p>对于编译时异常有两种手段处理，<strong>一是 try catch 捕获，一是 throws 抛出</strong></p>
</li>
</ul>
<p><strong>RuntimeException 的直接子类</strong>：</p>
<ul>
<li>RuntimeException 的直接子类叫做<strong>运行时异常、非受控异常、非检查异常</strong>。这种异常不要求在程序编译<br>
阶段处理，编译也可以通过</li>
<li>比如说除0异常</li>
</ul>
<p><strong>自定义异常</strong>：</p>
<ul>
<li>JDK 提供的异常不能够满足要求的情况下用户可以自己自定义异常，可以根据实际情况选择继承Exception 或者 RuntimeException 两种形式。</li>
</ul>
<h3 id="2-说出几个常见的异常">2. 说出几个常见的异常</h3>
<p><strong>Error</strong></p>
<ul>
<li>StackOverError（堆溢出）</li>
<li>OutOfMemoryError（内存溢出）</li>
</ul>
<p><strong>受控异常</strong></p>
<ul>
<li>IOException（IO异常）</li>
<li>SQLException（SQL异常）</li>
<li>ClassNotFoundException（找不到指定的类异常）</li>
</ul>
<p><strong>不受控异常</strong></p>
<ul>
<li>
<p>NullPointerException（空指针异常）</p>
</li>
<li>
<p>ArithmeticException（算术异常）</p>
</li>
<li>
<p>ArrayIndexOutOfBoundsException（数组下表越界异常）</p>
</li>
</ul>
<h3 id="3-异常处理">3. 异常处理</h3>
<blockquote>
<p><code>异常的捕获应该从小到大</code></p>
</blockquote>
<p><strong>一般有两种方式</strong></p>
<ul>
<li>try...catch...finally....</li>
<li>thorws抛给调用者</li>
</ul>
<p><strong>finally 在任何情况下都会执行，除非JVM挂掉，通常在 finally 里关闭资源</strong></p>
<pre><code class="language-java">public class ExceptionTest12 {
    public static void main(String[] args) {
        int r = method1();
        //输出为： 100？ 50？
        System.out.println(r);//输出是50
    }
    private static int method1() {
        int a = 10;
        try {
            a = 50;
            return a;//直接返回值
        }finally {
            a = 100;//该语句也会执行，只是a已经返回
        }
    }
}
</code></pre>
<p><strong>throws 和 throw 的区别 ？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">throws</th>
<th style="text-align:center">throw</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">thorws 是声明异常</td>
<td style="text-align:center">thorws 是声明异常</td>
</tr>
<tr>
<td style="text-align:center">用在函数上</td>
<td style="text-align:center">用在函数内部</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秒杀策略（缓存+消息队列）]]></title>
        <id>https://xzzz2020.github.io/post/k_uLsJY6w/</id>
        <link href="https://xzzz2020.github.io/post/k_uLsJY6w/">
        </link>
        <updated>2020-06-27T04:07:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该项目为仅供个人学习使用！！！<br>
个人博客地址：<a href="https://blog.csdn.net/qq_43040688">https://blog.csdn.net/qq_43040688</a><br>
个人网站地址：<a href="http://www.xzzz2020.cn/">http://www.xzzz2020.cn/</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B">一、项目简介</a></li>
<li><a href="#%E4%BA%8C-%E6%8A%80%E6%9C%AF%E6%A0%88">二、技术栈</a></li>
<li><a href="#%E4%B8%89-%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0">三、详细实现</a>
<ul>
<li><a href="#31-%E5%88%86%E5%B8%83%E5%BC%8Fsession">3.1 分布式Session</a></li>
<li><a href="#32-%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98-url%E7%BC%93%E5%AD%98">3.2  页面缓存 + URL缓存</a></li>
<li><a href="#33-%E5%AF%B9%E8%B1%A1%E7%BA%A7%E7%BC%93%E5%AD%98">3.3 对象级缓存</a></li>
<li><a href="#34-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96">3.4 核心接口优化</a></li>
<li><a href="#35-%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96">3.5 接口安全优化</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">四、 项目实践中遇到的问题</a>
<ul>
<li><a href="#41-%E7%A7%92%E6%9D%80%E6%88%90%E5%8A%9F%E5%95%86%E5%93%81%E8%AE%A2%E5%8D%95%E6%95%B0%E8%B6%85%E8%BF%87%E9%A2%84%E8%AE%A2%E6%95%B0%E5%80%BC">4.1  秒杀成功商品订单数超过预订数值</a></li>
<li><a href="#42-%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%87%B4%E7%A7%92%E6%9D%80%E6%88%90%E5%8A%9F%E7%A7%92%E6%9D%80%E5%A4%9A%E6%AC%A1">4.2  一个用户的多个请求导致秒杀成功秒杀多次</a></li>
<li><a href="#43-%E4%BD%BF%E7%94%A8%E4%BA%86%E7%BC%93%E5%AD%98%E4%BE%9D%E7%84%B6%E4%BC%9A%E5%A4%A7%E9%87%8F%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93">4.3 使用了缓存依然会大量访问数据库</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">五、 接下来的优化思路</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-项目简介">一、项目简介</h2>
<p>该项目主要学习常用的高并发优化技术，并发的瓶颈往往在数据库，采用缓存和消息队列对接口进行优化减少对数据优化，掌握面对高并发场景下的设计思路：</p>
<ul>
<li>以 <strong>Spring Boot</strong> 为主线的技术栈，使用了 <strong>Mybatis+Druid</strong> ，采用<strong>前后端分离</strong>架构</li>
<li>整个项目基于商品的 <strong>秒杀接口</strong>，设计登录、商品展示以及订单展示等一系列的功能</li>
<li>接口高并发的优化主要利用 <strong>Redis实现页面缓存 + URL缓存 + 对象缓存</strong> ，利用 <strong>前后端分离实现页面静态化</strong> 以及整合 <strong>RabbitMQ实现异步下单</strong> 的优化。<code>QPS优化至少两倍</code></li>
<li>用户登录信息使用 <strong>Cookie+Redis实现分布式Session</strong> ，使用 <strong>拦截器+自定义参数解析器</strong> ，获取用户信息。<code>解决了不同服务器之间出现的缓存不一致或者服务器宕机Session消失的问题</code></li>
<li>接口安全实现了 <strong>秒杀接口地址隐藏 + 数学公式验证码 + 利用Redis实现接口防刷</strong>。<code>防止机器人对于核心业务的攻击</code></li>
<li>利用<strong>Jmeter模拟5000个用户，使用1万个线程</strong>，对商品展示接口和秒杀接口进行压测。<code>商品展示接口优化前QPS：584.8，优化后QPS：2085.9；秒杀接口优化前QPS：351.8，优化后QPS：2242.7</code></li>
</ul>
<h2 id="二-技术栈">二、技术栈</h2>
<p><strong>前端</strong></p>
<ul>
<li><code>Bootstrap</code></li>
<li><code>Ajax</code></li>
<li><code>thymeleaf</code></li>
</ul>
<p><strong>后端</strong></p>
<ul>
<li><code>SpringBoot</code></li>
<li><code>Mybatis</code></li>
<li><code>Druid</code></li>
<li><code>Jedis</code></li>
<li><code>fastjson</code></li>
</ul>
<p><strong>数据库</strong></p>
<ul>
<li><code>MySQL</code></li>
<li><code>Redis</code></li>
</ul>
<p><strong>中间件</strong></p>
<ul>
<li><code>RabbitMQ</code></li>
</ul>
<p><strong>测试</strong></p>
<ul>
<li><code>Jmeter</code></li>
</ul>
<h2 id="三-详细实现">三、详细实现</h2>
<h3 id="31-分布式session">3.1 分布式Session</h3>
<p>常用的有三种分布式Session解决方案：<code>服务器之间Session共享</code>、<code>Session绑定</code>、<code>Cookie+缓存</code>。<strong>本项目使用的就是Cookie+缓存的方式</strong>。下面将介绍这几种方式：</p>
<blockquote>
<p><strong>服务器之间Session共享</strong>：</p>
<ul>
<li>使用一台作为用户的登录服务器，当用户登录成功之后，会将session写到当前服务器上，我们通过脚本或者守护进程将session同步到其他服务器上，这时当用户跳转到其他服务器，session一致，也就不用再次登录。</li>
<li><strong>缺陷</strong>：速度慢，同步session有延迟性，可能导致跳转服务器之后，session未同步。而且单向同步时，登录服务器宕机，整个系统都不能正常运行。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Session绑定</strong>：</p>
<ul>
<li>基于nginx的ip-hash策略，可以对客户端和服务器进行绑定，同一个客户端就只能访问该服务器，无论客户端发送多少次请求都被同一个服务器处理</li>
<li><strong>缺陷</strong>：容易造成单点故障，如果有一台服务器宕机，那么该台服务器上的session信息将会丢失前端不能有负载均衡，如果有，session绑定将会出问题</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Cookie+缓存</strong></p>
<ul>
<li>将用户信息保存在<code>Redis</code>上，将键值放在<code>Cookie</code>中传递给浏览器，浏览器再下一次的访问中就会携带该Cookie。此时利用<code>拦截器+自定义参数解析器</code> 解析用户的Cookie，从缓存中获取数据传递给方法。</li>
</ul>
</blockquote>
<p><strong>部分代码如下：</strong></p>
<blockquote>
<p>利用Cookie + 加缓存保存用户信息</p>
</blockquote>
<pre><code class="language-java">/**
 * 分布式Session的思路是将数据存放在Redis中
 * 将数据的key放在cookie中发送给用户
 * 用户会携带cookie访问
 * 获取期中的token，从redis中获取
 * 每次访问都会生成一个新的，延长有效期
 */
private void addCookie(HttpServletResponse response, String token, MiaoshaUser user) {
    //生成Cookie
    //生成一个随机字符串token，去掉&quot;-&quot;
    //将token + 加上Redis通用缓存Key，保存在redis中
    redisService.set(MiaoshaUserKey.getByToken(), token, user);
    //生成Cookie，只将token存放在cookie,防止用户获取其他用户信息
    Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);
    //将Cookie的时间和Redis缓存时间一直
    cookie.setMaxAge(MiaoshaUserKey.getByToken().expireSeconds());
    //将Cookie存放在根目录
    cookie.setPath(&quot;/&quot;);
    ////将Cookie返回给浏览器
    response.addCookie(cookie);
}
</code></pre>
<h3 id="32-页面缓存-url缓存">3.2  页面缓存 + URL缓存</h3>
<p>页面缓存和URL缓存主要差异在于URL缓存<strong>会根据URL的变化，数据会有所不同</strong>，如某个商品的详细信息、视频的详细信息等。</p>
<p>故只介绍商品列表页面缓存技术：</p>
<blockquote>
<p><strong>页面缓存</strong></p>
<ul>
<li>当客户的请求到达后端时，<code>先去redis中查询缓存，如果缓存中找不到，则进行数据库逻辑操作，然后渲染，存入缓存并返回给前端</code></li>
<li>如果在缓存中找到了则直接返回给前端。</li>
<li>存储在Redis缓存中的页面需要设置超时时间，缓存的时间长度根据页面数据变化频繁程度适当调整。目前大多数页面<code>缓存都是在60~120秒</code>，少数几乎不变化的可以调整到5分钟!</li>
</ul>
</blockquote>
<p><strong>部分代码实现</strong>：</p>
<blockquote>
<p>商品列表的Controller层</p>
</blockquote>
<pre><code class="language-java">    @RequestMapping(value = &quot;/to_list&quot;, produces = &quot;text/html&quot;)
    @ResponseBody
    public String toGoods(Model model, MiaoshaUser user,
                          final HttpServletRequest request,
                          final HttpServletResponse response) {

        //取缓存
        String html;
        html = redisService.get(GoodsKey.getGoodsList(), &quot;&quot;, String.class);
        if (html != null) {//如果缓存有这个页面
            return html;
        } else {//如果没有这个页面
            //访问数据库获取商品数据
            List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();
            if (user != null) {
                //如果有用户信息，则保存在Model中
                model.addAttribute(&quot;user&quot;, user);
            }
            //将商品数据保存在Model中
            model.addAttribute(&quot;goodsList&quot;, goodsList);

            //手动渲染
            SpringWebContext springWebContext = new SpringWebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap(), context);
            html = viewResolver.getTemplateEngine().process(&quot;goods_list&quot;, springWebContext);
            if (!StringUtils.isEmpty(html)) {
                //保存到缓存，缓存时间只有60秒，不宜过长
                redisService.set(GoodsKey.getGoodsList(), &quot;&quot;, html);
            }
            //返回到浏览器
            return html;
        }

    }
</code></pre>
<p><strong>接下来使用Jmeter启动1万个线程进行压测：</strong></p>
<blockquote>
<p>优化前，可以看的<code>吞吐量达到584.8</code><br>
<img src="en-resource://database/948:1" alt="55bc54085c699c92fc6a66b4986169c9.png" loading="lazy"></p>
</blockquote>
<blockquote>
<p>优化后，可以看的<code>吞吐量达到2085.9</code><br>
<img src="en-resource://database/946:1" alt="87002fe601459eaaff41c543660a6592.png" loading="lazy"></p>
</blockquote>
<h3 id="33-对象级缓存">3.3 对象级缓存</h3>
<p>相比页面缓存是更细粒度缓存。在实际项目中， 不会大规模使用页面缓存，因为涉及到分页，一般只缓存前面1-2页。对象缓存就是 当用到用户数据的时候，可以从缓存中取出。</p>
<p><strong>需要注意两个问题</strong>：</p>
<ul>
<li>一旦数据发生更改，一定要将缓存失效</li>
<li>Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存</li>
</ul>
<p><strong>部分代码实现</strong>：</p>
<blockquote>
<p>保存用户信息</p>
</blockquote>
<pre><code class="language-java">/**
 * 这个是对象级的缓存
 * 从缓存中取出用户信息
 * &lt;p&gt;
 * 和页面缓存最大的区别是：1.时间是永久的 2.当对象发生更新时，需删除或者更新缓存
 * &lt;p&gt;
 * 从这里可以看出，Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存
 */
public MiaoshaUser getById(long id) {
    //取缓存
    MiaoshaUser user;
    user = redisService.get(MiaoshaUserKey.getById(), &quot;:&quot; + id, MiaoshaUser.class);
    if (user != null) {
        return user;
    } else {
        //取数据库，加入到缓存中
        user = miaoshaUserDao.getById(id);
        redisService.set(MiaoshaUserKey.getById(), &quot;:&quot; + id, user);
        return user;
    }
}
</code></pre>
<h3 id="34-核心接口优化">3.4 核心接口优化</h3>
<blockquote>
<p><strong>核心的业务接口优化主要思路是</strong>：</p>
<ul>
<li>使用利用Redis保存<code>商品库存的数量</code>、<code>用户的秒杀成功的订单信息</code>和<code>商品是否秒杀完的标记</code>，这样请求更多的访问缓存，减少对数据库的压力</li>
<li>若用户秒杀成功，利用<code>RabbitMQ实现异步下单，服务器控制访问数据库的压力，让用户暂时等待</code>，这样可以优化用户的体验，防止出现服务器宕机等问题</li>
</ul>
</blockquote>
<p><strong>部分代码如下所示</strong>：</p>
<blockquote>
<p>秒杀接口Controller</p>
</blockquote>
<pre><code class="language-java">@RequestMapping(value = &quot;/{path}/do_miaosha&quot;, method = RequestMethod.POST)
@ResponseBody
public Result&lt;Integer&gt; do_miaosha(MiaoshaUser user,
                                  @RequestParam(&quot;goodsId&quot;) long goodsId,
                                  @PathVariable(&quot;path&quot;) String path) {

    //判断用户是否登录，如果没用登录，则传递提示信息
    if (user == null) {
        return Result.error(CodeMsg.SESSION_ERROR);
    }

    //隐藏了访问接口，需要验证path
    if (StringUtils.isEmpty(path)) {
        return Result.error(CodeMsg.REQUEST_ILLEGAL);
    }
    boolean check = miaoshaService.checkPath(path, user.getId(), goodsId);
    if (!check) {
        return Result.error(CodeMsg.REQUEST_ILLEGAL);
    }
    
    //判断是否秒杀到了
    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);
    //如果能够获取订单，说明该用户已经秒杀到商品
    if (order != null) {
        return Result.error(CodeMsg.REPEATE_MIAO_SHA);
    }
    //判断是否秒杀已经结束
    Boolean over = localOverMap.get(goodsId);
    if (over) {
        return Result.error(CodeMsg.MIAO_SHA_OVER);
    }

    //预减库存
    long stock = redisService.decr(GoodsKey.getMiaoGoodsStock(), &quot;:&quot; + goodsId);
    if (stock &lt; 0) {//如果发现库存不足，则将秒杀结束的标记置成true
        localOverMap.put(goodsId, true);
        return Result.error(CodeMsg.MIAO_SHA_OVER);
    }

    //保存信息
    MiaoshaMessage miaoshaMessage = new MiaoshaMessage();
    miaoshaMessage.setGoodsId(goodsId);
    miaoshaMessage.setUser(user);
    //入队，实现异步下单
    mqSender.sendMiaoshaMessage(miaoshaMessage);
    //返回客户端订单处理中
    return Result.success(0);//排队中
}
</code></pre>
<blockquote>
<p>消息的发送者</p>
</blockquote>
<pre><code class="language-java">public void sendMiaoshaMessage(MiaoshaMessage miaoshaMessage) {
    //将数据序列化字符串
    String str = SerializableUtil.beanToString(miaoshaMessage);
    //发送消息
    amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE,str);
}
</code></pre>
<blockquote>
<p>消息的接收者</p>
</blockquote>
<pre><code class="language-java">@RabbitListener(queues = MQConfig.MIAOSHA_QUEUE)
public void miaoshaReceive(String message) {
    //将消息反序列化
    MiaoshaMessage miaoshaMessage = SerializableUtil.stringToBean(message, MiaoshaMessage.class);
    //获取用户
    MiaoshaUser user = miaoshaMessage.getUser();
    //获取用户id
    long goodsId = miaoshaMessage.getGoodsId();
    //再次判断库存是否足够
    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
    Integer stockCount = goods.getStockCount();
    //如果库存不足，则直接返回
    if (stockCount &lt;= 0) {
        return;
    }
    //减库存 下订单 写入订单 一个事务中
    miaoshaService.miaosha(user, goods);
}
</code></pre>
<blockquote>
<p>订单的处理</p>
</blockquote>
<pre><code class="language-java">@Transactional
public OrderInfo miaosha(MiaoshaUser user, GoodsVo goods) {
    //减库存
    boolean success = goodsService.reduceStock(goods);
    if (success){
        //下订单
        return orderService.creatOrder(user,goods);
    }else {
        //如果库存不足，设置商品已经卖完
        setGoodsOver(goods.getId());
    }
    return null;
}

/**
 * 设置商品已经卖完
 */
private void setGoodsOver(Long id) {
    redisService.set(MiaoshaKey.getMiaoshaOver(),&quot;:&quot;+id,true);
}
</code></pre>
<p><strong>接下来使用Jmeter启动1万个线程，模拟5000个用户进行压测</strong>：</p>
<blockquote>
<p>优化前，可以看的<code>吞吐量达到351.8</code><br>
<img src="en-resource://database/950:1" alt="d1c3599b1b848a55b7270ab5e2491162.png" loading="lazy"></p>
</blockquote>
<blockquote>
<p>优化后，可以看的<code>吞吐量达到2242.7</code><br>
<img src="en-resource://database/952:1" alt="cfd03964c83a1181d88a19802e1d1f84.png" loading="lazy"></p>
</blockquote>
<h3 id="35-接口安全优化">3.5 接口安全优化</h3>
<p>接口的安全优化主要的防止恶意用户的访问，以及减少瞬时用户的并发量</p>
<blockquote>
<p><strong>接口隐藏</strong></p>
</blockquote>
<ul>
<li>由于前端的代码在浏览器，所以可以轻易的获取到核心业务的接口</li>
<li><strong>解决</strong>：地址是在客户端动态生成的，前端需要先获取地址信息，然后在发送给服务器，服务器会对浏览器的地址进行处理并和真实的地址进行比较</li>
</ul>
<blockquote>
<p><strong>数学问题验证码</strong></p>
<ul>
<li>验证码主要防止机器人的大量访问，以及将用户的请求分散开，避免集中的下单<br>
<strong>解决</strong>：服务器生成验证码，通过前端输入进行验证</li>
</ul>
</blockquote>
<blockquote>
<p><strong>接口防刷</strong></p>
<ul>
<li>恶意用户可能会大量的访问服务器，给服务器造成压力<br>
<strong>解决</strong>：利用缓存，保存一定时间的访问数，如果超过一定限制，则直接拒绝访问</li>
</ul>
</blockquote>
<h2 id="四-项目实践中遇到的问题">四、 项目实践中遇到的问题</h2>
<h3 id="41-秒杀成功商品订单数超过预订数值">4.1  秒杀成功商品订单数超过预订数值</h3>
<p><strong>问题分析</strong>：</p>
<ul>
<li>该问题主要因为在高并发下，线程不安全导致的</li>
<li>在判断是否秒杀成功时，多个用户通过了判断，然后才减少了库存</li>
</ul>
<p><strong>问题解决</strong>：</p>
<ul>
<li>MySQL数据库在更新数据时，会自动加锁</li>
<li>在SQL语句中减少库存时，判断库存是否大于0，如果不是则执行失败，订单回滚</li>
</ul>
<h3 id="42-一个用户的多个请求导致秒杀成功秒杀多次">4.2  一个用户的多个请求导致秒杀成功秒杀多次</h3>
<p><strong>问题分析</strong>：</p>
<ul>
<li>由于采用的异步下单，在该用户订单没有完成时，则可能会出现一个用户同时下多个订单</li>
</ul>
<p><strong>问题解决</strong>：</p>
<ul>
<li>设计数据库表时，多设计一个秒杀的订单，和普通的订单分离</li>
<li>在秒杀订单上，user_id采用唯一索引</li>
</ul>
<h3 id="43-使用了缓存依然会大量访问数据库">4.3 使用了缓存依然会大量访问数据库</h3>
<p><strong>问题分析</strong>：</p>
<ul>
<li>由于为了简便，在Service上面统统加了@Transactional注解，会导致所有的方法启用事务</li>
<li>此时即使使用了缓存，也依然会访问数据库，最终造成数据库压力过大</li>
</ul>
<p><strong>问题解决</strong>：</p>
<ul>
<li>只在需要事务的方法上使用@Transactiona注解，提高性能</li>
</ul>
<h2 id="五-接下来的优化思路">五、 接下来的优化思路</h2>
<ul>
<li><code>静态资源优化</code></li>
<li><code>CDN加速</code></li>
<li><code>Nginx水平扩展</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[贪心策略]]></title>
        <id>https://xzzz2020.github.io/post/-Soxdr6Ou/</id>
        <link href="https://xzzz2020.github.io/post/-Soxdr6Ou/">
        </link>
        <updated>2020-06-25T13:55:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E8%B4%AA%E5%BF%83%E7%9A%84%E7%89%B9%E7%82%B9">贪心的特点</a></li>
<li><a href="#%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90">实际例子</a>
<ul>
<li><a href="#1-%E7%A1%AC%E5%B8%81%E6%94%AF%E4%BB%98%E9%97%AE%E9%A2%98">1. 硬币支付问题</a></li>
<li><a href="#2-%E5%B0%8F%E8%88%B9%E6%B8%A1%E6%B2%B3%E9%97%AE%E9%A2%98">2. 小船渡河问题</a></li>
<li><a href="#3-%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">3. 区间调度问题（二维数组排序）</a></li>
<li><a href="#4-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9">4. 区间选点</a></li>
<li><a href="#5-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98">5. 区间覆盖问题</a></li>
<li><a href="#6-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98">6. 字典序最小问题</a></li>
<li><a href="#7-%E4%B9%98%E8%88%B9%E9%97%AE%E9%A2%98">7. 乘船问题</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="简介">简介</h2>
<ul>
<li>无论是DFS还是BFS都是遍历解空间</li>
<li>动态规划和贪心算法都是一种递推算法，运用<strong>局部最优解</strong>来推到全局最优解</li>
<li>是对<strong>遍历解空间</strong>的一种优化</li>
<li>当问题具有<strong>最优子结构</strong>的时候，可以用动归，而贪心是动归的特例。</li>
</ul>
<h2 id="贪心的特点">贪心的特点</h2>
<ul>
<li><strong>只看眼前</strong>。根据某种规则，不断的选取当前策略，最终找到最优解</li>
<li><strong>主要需要不断的举例，去猜测出一个贪心策略。</strong></li>
</ul>
<p><strong>注意</strong>：当前最优的未必是整体最优</p>
<h2 id="实际例子">实际例子</h2>
<h3 id="1-硬币支付问题">1. 硬币支付问题</h3>
<blockquote>
<p>硬币问题<br>
有1元,5元,10元,50元,100元,500元的硬币各c1,c5,c10,c50,c100,c500枚.<br>
现在要用这些硬币来支付A元,最少需要多少枚硬币?<br>
假定本题至少存在一种支付方案.<br>
0≤ci≤10^9<br>
0≤A≤10^9<br>
输入:<br>
第一行有六个数字,分别代表从小到大6种面值的硬币的个数<br>
第二行为A,代表需支付的A元<br>
样例:<br>
输入<br>
3 2 1 3 0 2<br>
620<br>
输出<br>
6</p>
</blockquote>
<pre><code class="language-java"> /**
  * 尽量先用大面值,因为不用大面值,将使用更多的小面值硬币,一定得不到最优解
  */
public class Main {
    static int [] cin = new int[6];

    public static void main(String[] args) throws InterruptedException {
        Scanner scanner = new Scanner(System.in);

        int money ;
        int ans = 0;
        for (int i = 0; i &lt; 6; i++) {
            cin[i] = scanner.nextInt();
        }
        int [] coins = new int[]{1,5,10,50,100,500};
        money = scanner.nextInt();
        for (int i = 5; i &gt;=0; i--) {
            int x = money/coins[i];//金额有多少个coins[i]
            int t = Math.min(cin[i],x);//当前面值的硬币有cin[i]个
            ans += t;
            money -= t*coins[i];
        }
        System.out.println(ans);
    }

}
</code></pre>
<h3 id="2-小船渡河问题">2. 小船渡河问题</h3>
<blockquote>
<p>N个人过河，船每次最多只能坐两个人，船载每个人过河的所需时间不同，问最快的过河时间。</p>
<p>有N个人要渡河，但是只有一艘船，船上每次最多只能载两个人，渡河的速度由两个人中较慢的那个决定，小船来回载人直到所有人都渡河，求最短的渡河时间。</p>
<p>输入的每种情况的第一行包含N，第二行包含N个整数，表示每个人过河的时间。每个案例前面都有一个空行。不会有超过1000人，没有人会花超过100秒的时间穿越。</p>
<p>对于每个测试用例，打印一行，其中包含所有N个人过河所需的总秒数。</p>
<p>Sample Input<br>
1<br>
4<br>
1 2 5 10<br>
Sample Output<br>
17</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/20200201205225396.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>可以发现，4个人以上时，前四轮都是将最慢的两个渡过河。</strong></p>
<pre><code class="language-java">public class Case02_POJ_1700 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int i = 0; i &lt; T; i++) {
            int n = sc.nextInt();
            int[] speed = new int[n];
            for (int j = 0; j &lt; n; j++) {
                speed[j] = sc.nextInt();
            }
            //排序
            Arrays.sort(speed);
            f(n, speed);
        }
    }

    /**
     * speed已经排序
     *
     * @param n
     * @param speed
     */
    private static void f(int n, int[] speed) {
        int left = n;
        int ans = 0;
        while (left &gt; 0) {
            if (left == 1) {//只有1人
                ans += speed[0];
                break;
            } else if (left == 2) {//只有两人
                ans += speed[1];
                break;
            } else if (left == 3) {//有三人
                ans += speed[2] + speed[0] + speed[1];
                break;
            } else {//通过两种策略来回两趟，渡过最慢的两个人
                //1，2出发，1返回，最后两名出发，2返回
                int s1 = speed[1] + speed[0] + speed[left - 1] + speed[1];
                //1，3出发，1返回，1，4出发，1返回，1，2过河
                int s2 = speed[left - 1] + speed[left - 2] + 2 * speed[0];
                ans += Math.min(s1, s2);
                left -= 2;//左侧是渡河的起点，left代表左侧的剩余人数
            }
        }
        System.out.println(ans);
    }
</code></pre>
<h3 id="3-区间调度问题二维数组排序">3. 区间调度问题（二维数组排序）</h3>
<blockquote>
<p>有n项工作,每项工作分别在si时间开始,在ti时间结束.<br>
对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.<br>
此外,参与工作的时间段不能重复(即使是开始的瞬间和结束的瞬间的重叠也是不允许的).<br>
你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?<br>
1≤n≤100000<br>
1≤si≤ti≤10^9<br>
输入:<br>
第一行:n<br>
第二行:n个整数空格隔开,代表n个工作的开始时间<br>
第三行:n个整数空格隔开,代表n个工作的结束时间<br>
样例输入:<br>
5<br>
1 3 1 6 8<br>
3 5 2 9 10<br>
样例输出:<br>
3<br>
说明:选取工作1,3,5</p>
</blockquote>
<p><strong>面向对象的排序思想</strong>：</p>
<ul>
<li>将不同的维度，比如说身高、体重、年龄，进行打包。</li>
<li>将对象的一些操作打包到一起，操作可以直接影响数据。</li>
</ul>
<pre><code class="language-java">//贪心策略：选择结束时间最早的
public class Case03_区间调度问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] s = new int[n];
        int[] t = new int[n];
        //建立开始时间和终止时间的打包对象
        Job[] jobs = new Job[n];
        for (int i = 0; i &lt; n; i++) {
            s[i] = sc.nextInt();
        }
        for (int i = 0; i &lt; n; i++) {
            t[i] = sc.nextInt();
        }
        for (int i = 0; i &lt; n; i++) {
            jobs[i] = new Job(s[i], t[i]);
        }

        Arrays.sort(jobs);
        //此时数据按照终止时间和开始时间由小到大排序
        int res = f(n, jobs);
        System.out.println(res);
    }

    private static int f(int n, Job[] jobs) {
        int cnt = 1;
        int y = jobs[0].t;//先选择最小的终止时间
        for (int i = 0; i &lt; n; i++) {//选择下一个终止时间最早的
            if (jobs[i].s &gt; y) {
                cnt++;
                y = jobs[i].t;
            }
        }
        return cnt;
    }

    /**
     * 必须实现排序规则
     */
    private static class Job implements Comparable&lt;Job&gt; {
        int s;
        int t;

        public Job(int s, int t) {
            this.s = s;
            this.t = t;
        }
		
        //排序规则
        @Override
        public int compareTo(Job other) {
            int x = this.t - other.t;
            if (x == 0)//如果终止的时间相同，则比较开始时间
                return this.s - other.s;
            else
                return x;
        }
    }
}
</code></pre>
<h3 id="4-区间选点">4. 区间选点</h3>
<blockquote>
<p>题意:有n个如下形式的条件:<br>
ai bi ci,表示在区间[ai, bi]内至少要选择ci个整数点.（不同区间内含的点可以是同一个）<br>
问你满足n个条件的情况下,最少需要选多少个点?<br>
Sample Input<br>
5<br>
3 7 3<br>
8 10 3<br>
6 8 1<br>
1 3 1<br>
10 11 1<br>
Sample Output<br>
6</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625174049315.png" alt="image-20200625174049315" style="zoom: 80%;" />
<pre><code class="language-java">public class Case04_区间选点问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Interval[] intervals = new Interval[n];
        for (int i = 0; i &lt; n; i++) {
            intervals[i] = new Interval(sc.nextInt(), sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(intervals);//按区间右端点排序

        int max = intervals[n - 1].t;//右端最大值
        int[] axis = new int[max + 1];//标记数轴上的点是否已经被选中
        for (int i = 0; i &lt; n; i++) {
            //1.查阅区间中有多少个点
            int s = intervals[i].s;//起点
            int t = intervals[i].t;//终点
            int cnt = sum(axis, s, t);//找到这个区间已经选点的数量，sums[t] - sums[s - 1];//效率低
            //  2.如果不够，从区间右端开始标记，遇标记过的就跳过
            intervals[i].c -= cnt;//需要新增的点的数量
            while (intervals[i].c &gt; 0) {
                if (axis[t] == 0) {//从区间终点开始选点
                    axis[t] = 1;
                    // updateSums(t,sums);//更新前缀和
                    intervals[i].c--;//进一步减少需要新增的点的数量
                    t--;
                } else {//这个点已经被选过了，不选择重复的点
                    t--;
                }
            }
        }
        System.out.println(sum(axis, 0, max));
    }

    /**
     * 统计数轴axis上s-t区间已经有多少个点被选中
     * @param axis
     * @param s
     * @param t
     * @return
     */
    private static int sum(int[] axis, int s, int t) {
        int sum = 0;
        for (int i = s; i &lt;= t; i++) {
            sum += axis[i];
        }
        return sum;
    }
    
    private static class Interval implements Comparable&lt;Interval&gt; {
        int s;//起点
        int t;//终点
        int c;//区间需求

        public Interval(int s, int t, int c) {
            this.s = s;
            this.t = t;
            this.c = c;
        }
		
        //按照终点由小到大排序
        @Override
        public int compareTo(Interval other) {
            int x = this.t - other.t;
            if (x == 0)
                return this.s - other.s;
            else
                return x;
        }
    }

}
</code></pre>
<h3 id="5-区间覆盖问题">5. 区间覆盖问题</h3>
<p><code>如果给定一堆线段，给定一个区间，看最少需要几个线段才能完全覆盖这个区间。</code></p>
<p><strong>解决思路</strong>：</p>
<ul>
<li>
<p>设区间起点为start，终点为end，所需线段数目为ans</p>
</li>
<li>
<p>首先线段中的终点，小于区间的起点，则该线段肯定无法覆盖</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625213133071.png" alt="image-20200625213133071" style="zoom:67%;" />
</li>
<li>
<p>同理如果区间的终点，大于线段的起点，则也一定无法覆盖</p>
</li>
<li>
<p>接着就需要<strong>保存线段终点大于等于区间起点且线段起点小于等于区间终点的线段</strong></p>
</li>
<li>
<p>对上面的线段<strong>根据起点的大小排序</strong></p>
</li>
<li>
<p>接着此时的寻找线段起点小于start同时终点最远的线段，并该终点设置为新的start，将ans+1<br>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625213909588.png" alt="image-20200625213909588" style="zoom: 67%;" /></p>
</li>
<li>
<p>重复上述步骤直到找到终点大于end的</p>
</li>
</ul>
<blockquote>
<p>题目：给出n条线段，以及最大长度m，问最少需要多少条才能覆盖1-m这个区间，当无法全部覆盖的时候输出-1</p>
<p>Sample Input<br>
3 10<br>
1 7<br>
3 6<br>
6 10<br>
Sample Output<br>
2</p>
</blockquote>
<pre><code class="language-java">public class Case05_区间覆盖问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int T = sc.nextInt();
        Job[] jobs = new Job[N];
        for (int i = 0; i &lt; N; i++) {
            jobs[i] = new Job(sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(jobs);
        int start = 1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右
        int end = 1;
        int ans = 1;
        for (int i = 0; i &lt; N; i++) {
            int s = jobs[i].s;
            int t = jobs[i].t;
            if (i == 0 &amp;&amp; s &gt; 1) break;//第一个起点比区间起点小，则一定无法覆盖

            if (s &lt;= start) {//当前区间有可能覆盖start
                end = Math.max(t, end);//寻找起点小于start同时终点最远的线段
            } else {//说明已经没有线段再比start小，开始下一个区间
                ans++;//上一个目标覆盖已经达成，计数加1
                start = end + 1;//更新起点，设置一个新的覆盖目标
                if (s &lt;= start) {
                    end = Math.max(t, end);
                } else {//当前的起点如果比end大，则后面的都一定大，无法继续覆盖
                    break;
                }
            }
            if (end &gt;= T) {//当前的end超越了线段的右侧，则不需要继续判断了
                break;
            }
        }
        if (end &lt; T)//如果没有覆盖
            System.out.println(-1);
        else
            System.out.println(ans);
    }

    private static class Job implements Comparable&lt;Job&gt; {
        int s;
        int t;

        public Job(int s, int t) {
            this.s = s;
            this.t = t;
        }

        /**按照区间起点排序*/
        @Override
        public int compareTo(Job other) {
            int x = this.s - other.s;
            if (x == 0)
                return this.t - other.t;
            else
                return x;
        }
    }
}
</code></pre>
<h3 id="6-字典序最小问题">6. 字典序最小问题</h3>
<blockquote>
<p>字典序最小问题<br>
给一个定长为N的字符串S,构造一个字符串T,长度也为N。<br>
起初，T是一个空串，随后反复进行下列任意操作</p>
<ol>
<li>从S的头部删除一个字符，加到T的尾部</li>
<li>从S的尾部删除一个字符，加到T的尾部<br>
目标是最后生成的字符串T的字典序尽可能小<br>
1≤N≤2000<br>
字符串S只包含大写英文字母<br>
输入：字符串S<br>
输出：字符串T</li>
</ol>
</blockquote>
<pre><code class="language-java">public class Case06_字典序最小问题 {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    StringBuilder ss = new StringBuilder();//字符输入小技巧
    for (int i = 0; i &lt; N; i++) {
      ss.append(sc.next());
    }
    // String s = sc.nextLine();
    f(ss.toString());
  }

  private static void f(String s) {
    String s1 = new StringBuilder(s).reverse().toString();//字符串翻转，
    int N = s.length();
    StringBuilder rs = new StringBuilder();
    while (rs.length() &lt; N) {//这样就可以直接比较两个字符串的头，相当于一个取头一个取尾
      if (s.compareTo(s1) &lt;= 0) {//这是个字符串字典比较的小技巧
        rs.append(s.charAt(0));
        s = s.substring(1);
      } else {
        rs.append(s1.charAt(0));
        s1 = s1.substring(1);
      }
  }
}

</code></pre>
<h3 id="7-乘船问题">7. 乘船问题</h3>
<blockquote>
<p>有n个人，第i个人重量为wi。每艘船的最大载重量均为C，且最多只能乘两个人。用最少的船装载所有人。<br>
贪心策略：考虑最轻的人i，如果每个人都无法和他一起坐船（重量和超过C），则唯一的方案是每个人坐一艘<br>
否则，他应该选择能和他一起坐船的人中最重的一个j<br>
求需要船的数量</p>
</blockquote>
<pre><code class="language-java">public class Case07_乘船问题 {
  public static void main(String[] args) {
    int[] w = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = w.length;
    int c = 10;

    Arrays.sort(w);
    int cntOfPerson = n;
    int cntOfBoat = 0;
    int p1 = 0;
    int p2 = n - 1;
    while (cntOfPerson &gt; 0) {
      if (p1 + p2 &gt; c) {//如果最大的和当前最小的不能在一艘船，则一定需要自己一艘船
        p2--;
        cntOfPerson--;
        cntOfBoat++;
      } else {
        p1++;
        p2--;
        cntOfPerson -= 2;
        cntOfBoat++;
      }
    }
    System.out.println(cntOfBoat);
  }
}
</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>本质是一种DFS的剪枝法</li>
<li>选择的是当下最优的策略</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第七章操作系统接口]]></title>
        <id>https://xzzz2020.github.io/post/KpZgrFFRY/</id>
        <link href="https://xzzz2020.github.io/post/KpZgrFFRY/">
        </link>
        <updated>2020-06-23T13:03:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">命令接口实现</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="命令接口实现">命令接口实现</h2>
<p><strong>分为下图所示的两个模块实现</strong>：</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205644062.png" alt="image-20200623205644062" style="zoom: 50%;" />
<p><strong>终端处理程序，接收键盘的输入，并将命令执行的结果回显在显示器上，功能包括</strong>：</p>
<ul>
<li>字符接收</li>
<li>字符缓冲</li>
<li>回送显示</li>
<li>屏幕编辑</li>
<li>特殊字符的处理</li>
</ul>
<p><strong>命令解释程序，从.输入缓冲区中取出数据，然后识别命令、执行命令,最后把结果放到输出缓冲区中。</strong></p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205922735.png" alt="image-20200623205922735" style="zoom: 80%;" />
<h2 id="系统调用">系统调用</h2>
<p><strong>什么是系统调用？</strong></p>
<ul>
<li>系统调用是操作系统提供给应用程序的一-种过程调用，保护操作系统程序不被用户，<br>
程序破坏。</li>
<li>系统调用是操作系统的程序接口。</li>
</ul>
<p><strong>系统调用与一般的过程调用不同</strong>：</p>
<ul>
<li>系统调用处理程序运行在内核态，而一般的过程调用运行在用户态;</li>
<li>系统调用需要借助软中断实现，而- -般过程调用不需要;</li>
<li>系统调用从内核返回时，要进行决策是否运行调度算法，而一般过程调用不需要;</li>
<li>系统调用可以嵌套调用，但调用深度有一定的限制，而一般过程调用没有深度限制;</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第六章文件管理]]></title>
        <id>https://xzzz2020.github.io/post/7ZUXXwU1m/</id>
        <link href="https://xzzz2020.github.io/post/7ZUXXwU1m/">
        </link>
        <updated>2020-06-23T12:52:11.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">文件及其逻辑结构</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6">顺序文件</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6">索引文件</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6">索引顺序文件</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6%E5%92%8C%E5%93%88%E5%B8%8C%E6%96%87%E4%BB%B6">直接文件和哈希文件</a></li>
</ul>
</li>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E8%A6%81%E6%B1%82">目录的要求</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">文件的物理结构（***）</a>
<ul>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">连续分配</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D">链接分配</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D">索引分配</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86">空闲空间管理</a>
<ul>
<li><a href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95">空闲表法</a></li>
<li><a href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95">空闲链表法</a></li>
<li><a href="#%E4%BD%8D%E8%A7%86%E5%9B%BE%E6%B3%95">位视图法（***）</a></li>
<li><a href="#%E6%88%90%E7%BB%84%E9%93%BE%E8%A1%A8%E6%B3%95">成组链表法</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B">文件系统软件模型</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7">对象及其属性</a></li>
<li><a href="#%E5%AF%B9%E5%AF%B9%E8%B1%A1%E6%93%8D%E7%BA%B5%E5%92%8C%E7%AE%A1%E7%90%86%E7%9A%84%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88">对对象操纵和管理的软件集合</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">文件系统接口</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB">文件共享</a></li>
<li><a href="#%E8%AF%BE%E6%9C%AC%E4%B9%A0%E9%A2%98">课本习题</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="文件及其逻辑结构">文件及其逻辑结构</h2>
<p><strong>文件概念</strong>：由创建者所定义、具有文件名的一组相关元素的集合，可分为结构文件和无结构文件两种。</p>
<p><strong>文件逻辑结构概念</strong>：文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性，又称为文件组织。</p>
<h3 id="顺序文件">顺序文件</h3>
<ul>
<li>顺序文件由数据依次排列组成。</li>
<li>顺序文件可分为串结构文件和有序结构文件。、
<ul>
<li>串结构文件按记录存入文件的时间先后排列。</li>
<li>有序结构按关键字值大小排列。</li>
</ul>
</li>
<li>顺序文件又分为定长记录文件和变长记录文件。</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623182042483.png" alt="image-20200623182042483" style="zoom:80%;" />
<h3 id="索引文件">索引文件</h3>
<p>若顺序文件是<strong>变长记录文件</strong>，可按记录号或关键字为每条记录建立一个索引文件，存储记录在顺序文件中的位置信息。</p>
<p>索引文件是定长的文件。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623182705177.png" alt="image-20200623182705177" style="zoom: 80%;" />
<h3 id="索引顺序文件">索引顺序文件</h3>
<ul>
<li><strong>索引文件太长会要求更多的I/O次数，直接影响了文件的读/写效率。</strong></li>
<li>索引顺序文件先<strong>对顺序文件按记录号或关键字排序分组</strong>，然后对组的第一个记录索引。</li>
</ul>
<h3 id="直接文件和哈希文件">直接文件和哈希文件</h3>
<ul>
<li>
<p><strong>直接文件</strong>是一种特殊的哈希文件,记录关键字值决定了记录在顺序文件中的位置。</p>
</li>
<li>
<p><strong>哈希文件</strong>则由关键字值通过哈希函数计算获得记录在顺序文件中的位置。</p>
</li>
</ul>
<h2 id="目录的要求">目录的要求</h2>
<ol>
<li>实现“按名存取”。</li>
<li>提高对目录的检索速度。</li>
<li>文件共享。</li>
<li>允许文件重名。</li>
</ol>
<h2 id="文件的物理结构">文件的物理结构（***）</h2>
<p><strong>概念</strong>：文件的物理结构指文件的外存分配组织管理方式</p>
<blockquote>
<p>文件占用的外存空间以块或簇等逻辑单位计量</p>
</blockquote>
<h3 id="连续分配">连续分配</h3>
<blockquote>
<p>文件数据连续存储可以提高存取速度，但限制了文件动态增长。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623195227779.png" alt="image-20200623195227779" style="zoom: 80%;" />
<h3 id="链接分配">链接分配</h3>
<blockquote>
<p>隐式链接，链接指针包含在给文件分配的块中，目录中仅包含文件的起始块和结束块(或长度)。</p>
<ul>
<li>链接指针分散在多个块中，不利于安全措施的实现</li>
</ul>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623200229916.png" alt="image-20200623200229916" style="zoom:67%;" />
<blockquote>
<p>显示链接：将所有的链接信息提取放到文件分配表中</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623200341171.png" alt="image-20200623200341171" style="zoom: 67%;" />
<h3 id="索引分配">索引分配</h3>
<ul>
<li>
<p>在链接分配中，文件块链接指针离散存储,造成文件占用块号解析效率不高。</p>
</li>
<li>
<p>索引分配方式就是将块号集中存放。</p>
</li>
</ul>
<p><strong>单级索引（一级索引）</strong></p>
<p>用一个块来记录文件占用的所有块号,我们称之为索引块</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201033041.png" alt="image-20200623201033041" style="zoom:67%;" />
<p><strong>二级索引</strong></p>
<blockquote>
<p>因为一个索引块的大小有限，但是多级索引需要检索多次，会影响性能</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201015773.png" alt="image-20200623201015773" style="zoom:67%;" />
<p><strong>混合索引(直接地址、-级索引、两级索引、三级索引方式)</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201148989.png" alt="image-20200623201148989" style="zoom:80%;" />
<h2 id="空闲空间管理">空闲空间管理</h2>
<h3 id="空闲表法">空闲表法</h3>
<ul>
<li>若干连续的空闲块组合成一个空闲区。</li>
<li>空闲表法将所有的空闲区记录在一张表里， 包括项号、起始空闲块号、空闲块数等。</li>
</ul>
<h3 id="空闲链表法">空闲链表法</h3>
<p>空闲链表法是以空闲块或空闲区为结点构成一个链表结构。</p>
<h3 id="位视图法">位视图法（***）</h3>
<blockquote>
<p>用一位二进制表示，1代表已分配，0代表空闲。</p>
</blockquote>
<ul>
<li>块号从0开始，BitsOfLine 是一行有多少位，如char类型为8位</li>
<li>block = line X BitsOfLine + column</li>
<li>line = block/BitsOfLine</li>
<li>column = block%BitsOfLine</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201428546.png" alt="image-20200623201428546" style="zoom: 80%;" />
<h3 id="成组链表法">成组链表法</h3>
<blockquote>
<p>用树的结构表示</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201544463.png" alt="image-20200623201544463" loading="lazy"></figure>
<h2 id="文件系统软件模型">文件系统软件模型</h2>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623202429515.png" alt="image-20200623202429515" style="zoom:67%;" />
<h3 id="对象及其属性">对象及其属性</h3>
<ul>
<li>文件系统对象</li>
<li>超级块对象</li>
<li>文件</li>
<li>目录</li>
<li>索引结点</li>
<li>数据块</li>
</ul>
<h3 id="对对象操纵和管理的软件集合">对对象操纵和管理的软件集合</h3>
<ul>
<li>对文件的读/写</li>
<li>对目录文件的读/写</li>
<li>对磁盘空闲空间的管理</li>
<li>将文件的逻辑地址转换为物理地址</li>
<li>对文件的保护与共享;</li>
</ul>
<h3 id="文件系统接口">文件系统接口</h3>
<ul>
<li>基于文件名(路径)、文件逻辑地址(相对于文件起始地址的偏移)给用户提供各种操作。</li>
<li>常用的文件操作有，创建文件、删除文件、读文件、写文件、设置文件读1写位置、打开文件、关闭文件等。</li>
</ul>
<h2 id="文件共享">文件共享</h2>
<ul>
<li>基于索引结点的共享方式</li>
<li>基于符号链的共享方式</li>
</ul>
<h2 id="课本习题">课本习题</h2>
<ol>
<li>
<p><strong>11 在 UNIX 中，如果一个盘块的大小为   1KB ，每个盘块号占                4 个字节，即每块可放                256个地址。请转换下列文件的字节偏移量为物理地址。</strong></p>
<p><strong>⑴ 9999 ； ⑵ 18000 ；⑶ 420000</strong></p>
<p>答：首先将逻辑文件的字节偏移量转换为逻辑块号和块内偏移量   ,就是将 [字节偏移量 ]/[ 盘块大小 ]，商为逻辑块号，<code>余数是块内偏移量</code>。在  FCB 中，第 0-9 个地址为直接地址，第  10 个为一次间接地址，第 11 个地址为二次间接地址，第 12 个地址为三次间接地址。</p>
<p>再将文件的逻辑块号转换为物理块号。使用多重索引结构，在索引节点中根据逻辑块号通过直接索引或间接索引找到对应的物理块号。</p>
<ul>
<li>
<p>9999/1024=9余 783 ，则逻辑块号为9 ，直接索引第9个地址得到物理块号，块内偏移地址为 783 。</p>
</li>
<li>
<p>18000/1024=17  余 592 ，则逻辑块号为10&lt;17&lt;10+256，通过一次间接索引在第10个地址可得到物理块号，块内偏移地址为592 。</p>
</li>
<li>
<p>420000/1024=410 余160 ，则逻辑块号为 10+256&lt;410 ，通过二次间接索引在第 11 个地址可得到一次间址，再由此得到二次间址，再找到物理块号，其块内偏移地址160 。</p>
</li>
</ul>
</li>
<li>
<p><strong>某操作系统磁盘文件空间共   500 块，若用字长为 32 位的位示图管理磁盘空间，试问：</strong></p>
<p><strong>（1）位示图需要多少字？</strong></p>
<p><strong>（2）第 i 字第 j 位对应的块号是多少？</strong></p>
<p><strong>（3）给出申请 /归还一块的工作流程。</strong></p>
<p>答：</p>
<p>（1）位示图需要的字数计算：  INT （ 500/32 ） =16个字。</p>
<p>（2）块号 b=(i-1)*32+j</p>
<p>（3 ）申请的过程：顺序扫描位示图、找到空闲块并分配、修改位示图map[i,j]=1 。归还的过程：找到回收盘块在位示图中的行和列，修改位示图map[i,j]=0 。</p>
</li>
</ol>
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194032746.png" alt="image-20200623194032746" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194102600.png" alt="image-20200623194102600" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194242927.png" alt="image-20200623194242927" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205009523.png" alt="image-20200623205009523" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205103341.png" alt="image-20200623205103341" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第五章设备管理]]></title>
        <id>https://xzzz2020.github.io/post/mxhiqNcFj/</id>
        <link href="https://xzzz2020.github.io/post/mxhiqNcFj/">
        </link>
        <updated>2020-06-23T09:01:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB">设备分类</a></li>
<li><a href="#io%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">I/O设备控制方式</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">程序查询方式</a></li>
<li><a href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">通道控制方式</a></li>
<li><a href="#dma%E6%96%B9%E5%BC%8F%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">DMA方式（直接存储器访问方式）</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F">中断方式</a></li>
</ul>
</li>
<li><a href="#io%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%8A%9F%E8%83%BD">I/O系统的软件模型及功能</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6">设备独立性软件</a></li>
<li><a href="#spooling">Spooling</a></li>
<li><a href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86">缓冲管理</a>
<ul>
<li><a href="#%E5%9B%9B%E7%A7%8D%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5">四种缓冲策略</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D">设备分配</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BC%9A%E8%AE%A1%E7%AE%97">磁盘调度算法（会计算***）</a>
<ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1">先来先服务</a></li>
<li><a href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4">最短寻道时间</a></li>
<li><a href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">扫描算法（电梯调度算法）</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95">循环扫描算法</a></li>
</ul>
</li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="设备分类">设备分类</h2>
<p><strong>按信息交换单位分类</strong>：</p>
<ul>
<li><strong>块设备</strong>：数据传送以块为单位，传输速率较高，可寻址; I/O访问常采用DMA方式。</li>
<li><strong>字符设备</strong>：数据传送以字符为单位，传输速率较低，不可寻址; I/0访问常采用中断方式。</li>
</ul>
<p><strong>按设备的的共享属性分类</strong>：</p>
<ul>
<li><strong>独占设备</strong>：一段时间内只允许一个进程使用，属于临界资源。</li>
<li><strong>共享设备</strong>：在一-段时间，允许多个进程同时访问，共享设备必须是<code>可寻址</code>和<code>可随机访问</code>的设备。</li>
<li><strong>虚拟设备</strong>：将一台独占设备变换为若干个逻辑设备,如虚拟存储器、虚拟终端。</li>
</ul>
<h2 id="io设备控制方式">I/O设备控制方式</h2>
<h3 id="程序查询方式">程序查询方式</h3>
<blockquote>
<p>不停的检查设备的状态，造成CPU资源的浪费，优点是比较简单</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623154822643.png" alt="image-20200623154822643" style="zoom: 80%;" />
<h3 id="通道控制方式">通道控制方式</h3>
<p><strong>通道程序由一系列通道指令构成，包含以下信息</strong>：</p>
<ul>
<li><strong>操作码</strong>：读、写、控制等;</li>
<li><strong>内存地址</strong>：读写内存的始址;</li>
<li><strong>计数</strong>：指令的读写字节数;</li>
</ul>
<p><strong>通道程序示例</strong>：</p>
<ul>
<li>
<p>通道程序结束位P，1表示通道指令是通道程序的最后一条指令。</p>
</li>
<li>
<p>记录结束位Record, 0表示通道指令与下一条通道指令所处理的数据块属于同- -个记录，1表示通道指令所处理的数据块是记录的最后一块数据。</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160021122.png" alt="image-20200623160021122" style="zoom:80%;" />
<h3 id="dma方式直接存储器访问方式">DMA方式（直接存储器访问方式）</h3>
<blockquote>
<p>DMA方式以<strong>块</strong>为单位传送数据，仅在数据块传送前和传送结束时,才需要处理机干预。</p>
</blockquote>
<p><strong>包含四类寄存器</strong>：</p>
<ul>
<li><strong>数据寄存器</strong>：缓存从设备到内存，或从内存到设备的数据;</li>
<li><strong>数据计数寄存器</strong>：存储要读/写的字节数;</li>
<li><strong>内存地址寄存器</strong>：存放内存起始地址; .</li>
<li><strong>控制/状态寄存器</strong>：接收处理机发来的1/O命令或有关控制信息，以及设备发送的状态信息;</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623155319789.png" alt="image-20200623155319789" style="zoom:80%;" />
<h3 id="中断方式">中断方式</h3>
<blockquote>
<p>驱动程序向处理机发出启动I/O设备指令后阻塞，处理机转向处理其它工作。</p>
<p>设备完成数据传送后，I/O控制器向处理机发送中断请求。处理机收到中断请求信号转向中断处理程序，中断处理程序将数据寄存器中的数据送到指定内存单元，并唤醒阻塞进程。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623155132894.png" alt="image-20200623155132894" style="zoom:80%;" />
<h2 id="io系统的软件模型及功能">I/O系统的软件模型及功能</h2>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160245567.png" alt="image-20200623160245567" style="zoom:67%;" />
<h2 id="设备独立性软件">设备独立性软件</h2>
<ul>
<li>
<p>设备独立性指应用程序独立于具体使用的物理设备。</p>
</li>
<li>
<p>为了实现设备独立性而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>概念，在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。</p>
</li>
</ul>
<p><strong>设备独立性软件的功能</strong>：</p>
<ol>
<li>
<p>向用户层(或文件层)软件提供统一接口。</p>
</li>
<li>
<p>执行设备的公有操作，如<code>逻辑设备名映射为物理设备名</code>、独立设备的分配与回收、对设备进行保护、缓冲管理、差错控制、提供独立于物理设备的逻辑块。</p>
</li>
</ol>
<p><strong>设备独立性实现</strong>：构建一个逻辑设备表，实现逻辑设备名到物理设备名的映射</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623161100037.png" alt="image-20200623161100037" style="zoom:67%;" />
<h2 id="spooling">Spooling</h2>
<blockquote>
<p>在联机情况下<strong>实现的同时输入/输出操作</strong>称为Spooling，或称为假脱机操作,即数据的输入、输出不再由外围控制机管理,而<strong>改为进程执行</strong>。</p>
</blockquote>
<p><strong>Spooling系统的组成</strong>：</p>
<ul>
<li>输入进程SPi和输出进程SPo</li>
<li>输入和输出缓冲区</li>
<li>输入和输出井</li>
</ul>
<p><strong>Spooling系统应用--共享打印机</strong>：</p>
<ul>
<li>将所有打印请求挂在打印机请求队列上。</li>
<li>把打印数据放入到输出井上。</li>
<li>打印机驱动进程依次完成打印机请求队列上的任务。</li>
</ul>
<p><strong>Spooling系统的特点</strong>：</p>
<ul>
<li>
<p>提高了I/O速度。</p>
</li>
<li>
<p>将独占设备改造成共享设备。</p>
</li>
<li>
<p>实现了设备的虚拟化。</p>
</li>
</ul>
<h2 id="缓冲管理">缓冲管理</h2>
<p><strong>目的</strong>：减少低速设备对高速的干扰。</p>
<h3 id="四种缓冲策略">四种缓冲策略</h3>
<p><strong>1. 单缓冲</strong></p>
<ul>
<li>
<p>由于处理机与I/O设备的并行性，用户进程对一块缓冲区数据的<strong>处理时间等价于Max(C，T)+M</strong>。</p>
</li>
<li>
<p>需要注意的是<strong>传送和计算或输入无法同时计算</strong></p>
</li>
<li>
<p>此时<strong>生产者是设备</strong>，<strong>消费者是用户进程</strong>，生产者和消费者都只有一个，不存在互斥</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623162724656.png" alt="image-20200623162724656" style="zoom:67%;" />
<p><strong>2. 双缓冲</strong></p>
<ul>
<li>数据被采集到缓冲区和数据从缓冲区传送到用户进程空间再被计算可以并行执行;</li>
<li>用户进程对一块缓冲区数据的处理时间等价于Max (C、T) ;如果C&gt;T,则CPU可以连续地工作;如果C&lt;T,则I/0设备可以连续地工作;</li>
<li>双缓冲适用于<strong>I/O设备与用户进程速度基本匹配的场合</strong>;</li>
<li>此时<strong>设备输入数据和用户进程取数据可以同时进行</strong></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623163234512.png" alt="image-20200623163234512" loading="lazy"></figure>
<p><strong>3. 循环缓冲</strong></p>
<ul>
<li>适用于<strong>I/O设备与用户进程速度差异较大的场合</strong></li>
<li>循环缓冲的使用：
<ul>
<li>GetBuf过程，从循环缓冲中获取一个满缓冲区或一个空缓冲区;</li>
<li>ReleaseBuf过程，向循环缓冲中释放一个空缓冲区或一个满缓冲区;</li>
</ul>
</li>
</ul>
<p><strong>4. 缓冲池（***）</strong></p>
<p><strong>三种缓冲队列</strong></p>
<ul>
<li>
<p>空缓冲队列emq</p>
</li>
<li>
<p>输入缓冲队列inq,装满输入数据</p>
</li>
<li>
<p>输出缓冲队列outq,装满输出数据</p>
</li>
</ul>
<p><strong>四种缓冲区</strong></p>
<ul>
<li>
<p>收容输入数据缓冲区hin</p>
</li>
<li>
<p>提取输入数据缓冲区sin</p>
</li>
<li>
<p>收容输出数据缓冲区hout</p>
</li>
<li>
<p>提取输出数据缓冲区sout</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623163922409.png" alt="image-20200623163922409" style="zoom:67%;" />
<h2 id="设备分配">设备分配</h2>
<ul>
<li><strong>安全分配</strong>：进程发出I/0请求后，便进入阻塞状态,直到I/O操作完成时才被唤醒。摒弃&quot;请求和保持”死锁必要条件之一， 缺点是进程进展缓慢。</li>
<li><strong>不安全分配</strong>：进程发出I/O请求后仍继续运行，需要时又发出第二C 个、第三个I/O请求等，效率高，缺点是可能造成死锁。</li>
</ul>
<h2 id="磁盘调度算法会计算">磁盘调度算法（会计算***）</h2>
<p><strong>注意</strong>：每次寻道都会改变当前所在磁道</p>
<h3 id="先来先服务">先来先服务</h3>
<blockquote>
<p>按照请求顺序进行寻道</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623164405289.png" alt="image-20200623164405289" style="zoom:67%;" />
<h3 id="最短寻道时间">最短寻道时间</h3>
<blockquote>
<p>每次寻找离当前磁道最近的请求，会导致饥饿现象，默写请求可能很久都难以调度</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623164703834.png" alt="image-20200623164703834" style="zoom:67%;" />
<h3 id="扫描算法电梯调度算法">扫描算法（电梯调度算法）</h3>
<blockquote>
<p>磁头可以朝着增加的方向移动也会朝着减少的方向移动，可以避免饥饿现象的发生</p>
</blockquote>
<ul>
<li>先寻找离当前磁头最近的磁道且需要比当前磁道大</li>
<li>当不存在比当前磁道更大的时候，磁头需要调转方向，朝着减少的方向移动.</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165335882.png" alt="image-20200623165335882" style="zoom:67%;" />
<h3 id="循环扫描算法">循环扫描算法</h3>
<p><strong>改进</strong>：当移动到不存在比当前磁道更大的时候，不再调转方向，从0开始继续寻找</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165646915.png" alt="image-20200623165646915" style="zoom:67%;" />
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160324835.png" alt="image-20200623160324835" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160342737.png" alt="image-20200623160342737" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623161956615.png" alt="image-20200623161956615" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623162055577.png" alt="image-20200623162055577" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165845231.png" alt="image-20200623165845231" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165920362.png" alt="image-20200623165920362" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165946217.png" alt="image-20200623165946217" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四章存储器管理]]></title>
        <id>https://xzzz2020.github.io/post/HB2L7VswF/</id>
        <link href="https://xzzz2020.github.io/post/HB2L7VswF/">
        </link>
        <updated>2020-06-23T02:20:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5">程序的链接与装入</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5">程序的装入</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5">程序的链接</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">连续存储分配方式</a>
<ul>
<li><a href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">单一连续分配</a></li>
<li><a href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">固定分区分配方式</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">动态分区分配（***）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">基本分页存储管理方式</a>
<ul>
<li><a href="#%E9%A1%B5%E8%A1%A8">页表</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84">地址变换机构（***）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">基本分段存储管理方式</a>
<ul>
<li><a href="#%E6%AE%B5%E8%A1%A8">段表</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-2">地址变换机构（***）</a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">分页和分段的主要区别</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">虚拟存储器（***）</a>
<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81">虚拟存储器实现方法的硬件支持</a>
<ul>
<li><a href="#%E5%88%86%E9%A1%B5%E8%AF%B7%E6%B1%82%E7%B3%BB%E7%BB%9F">分页请求系统</a></li>
<li><a href="#%E5%88%86%E6%AE%B5%E8%AF%B7%E6%B1%82%E7%B3%BB%E7%BB%9F">分段请求系统</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法（***）</a>
<ul>
<li><a href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%90%86%E6%83%B3%E5%8C%96">最佳置换算法（理想化）</a></li>
<li><a href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">先进先出页面置换算法</a></li>
<li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lru">最近最久未使用置换算法（LRU）</a></li>
<li><a href="#clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">clock置换算法</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%80%E8%BF%91%E6%9C%AA%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">简单clock置换算法（最近未访问页面置换算法）</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E5%9E%8Bclock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">改进型clock置换算法</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E6%9C%AA%E4%BD%BF%E7%94%A8lfu">最近最少未使用（LFU）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="程序的链接与装入">程序的链接与装入</h2>
<h3 id="程序的装入">程序的装入</h3>
<p><strong>目的</strong>：是将代码装入内存准备执行</p>
<ol>
<li><strong>绝对装入方式</strong></li>
<li><strong>可重定位装入方式</strong>：</li>
<li><strong>动态运行时的装入方式</strong>：增加一个重定位寄存器，通过硬件完成地址的修正。真实地址等于<strong>逻辑地址+重定位寄存器上的地址</strong><br>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622175520753.png" alt="image-20200622175520753" style="zoom:67%;" /></li>
</ol>
<h3 id="程序的链接">程序的链接</h3>
<p><strong>目的</strong>：将目标模块相对独立的地址空间合并成一个地址空间。</p>
<p>​</p>
<ol>
<li><strong>静态链接方式</strong>
<ul>
<li>对相对地址进行修改</li>
<li>变换外部调用符号</li>
</ul>
</li>
<li><strong>装入时动态链接</strong></li>
<li><strong>运行时动态链接</strong></li>
</ol>
<h2 id="连续存储分配方式">连续存储分配方式</h2>
<p><strong>目的</strong>：给每一个程序分配一片连续的存储空间，容量为程序运行时所需的最大空间。</p>
<p><strong>指标</strong>：碎片率，越小越好。</p>
<h3 id="单一连续分配">单一连续分配</h3>
<p><strong>内存分为系统区和用户区</strong></p>
<ul>
<li>用户区一次只能装入一个程序运行</li>
<li>系统区装入操作系统</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622181950847.png" alt="image-20200622181950847" style="zoom:50%;" />
<h3 id="固定分区分配方式">固定分区分配方式</h3>
<p><strong>将内存划分成固定数目的区域，如图所示</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182210610.png" alt="image-20200622182210610" style="zoom: 67%;" />
<p>为了实现内存的管理，<strong>需要建立固定分区表（数组实现）</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182308481.png" alt="image-20200622182308481" style="zoom:67%;" />
<p><strong>程序的大小和分区大小不能完全匹配</strong>，所以需要分配大于等于程序大小的内存，分区中浪费的空间称为<strong>内碎片</strong></p>
<h3 id="动态分区分配">动态分区分配（***）</h3>
<p><strong>操作系统不预设固定数目分区，按照程序内存需求为其划分，内存中分区数目动态变化。</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182722198.png" alt="image-20200622182722198" style="zoom:50%;" />
<p><strong>数据结构</strong>：</p>
<ul>
<li>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182822266.png" alt="image-20200622182822266" style="zoom:50%;" />
</li>
<li>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182958683.png" alt="image-20200622182958683" style="zoom: 67%;" />
</li>
</ul>
<p><strong>分配算法：</strong></p>
<ul>
<li><strong>首次适应算法</strong>：空闲分区以地址递增的顺序排列，<code>每次从链首开始顺序查找</code>，直到找到一个大小能满足要求的空闲分区为止。然后再按照程序的要求大小，从该空闲分区中划分出一块内存空间给请求者，余下的空闲部分仍留在空闲链表中。<code>特点是低端或高端地址空间被频繁使用。</code></li>
<li><strong>循环首次适应算法</strong>：在首次适应算法的基础上，<code>每次查找时从上次找到空闲分区的下一个空闲分区开始查找。特点是空闲分区使用均匀，但是会缺乏大的空闲分区。</code></li>
<li><strong>最佳适应算法</strong>：能满足要求、又是最小的空闲分区分配给作业，避免&quot;大材小用”。特点:分区按照大小顺序排列。</li>
<li><strong>最差适应算法</strong>：每次从空闲分区中选择最大的空闲分区分配给程序，以便切割剩余的空闲分区空间更大。</li>
</ul>
<p>切割操作会产生一些空间过小，总是不会分配给程序，这些空间被称作<strong>外碎片</strong>。</p>
<pre><code>### 可重定位分区分配
</code></pre>
<p><strong>紧凑</strong>：通过移动程序，将外碎片合并一个大的空闲分区</p>
<h2 id="基本分页存储管理方式">基本分页存储管理方式</h2>
<p><strong>离散分配的基本单位是页</strong></p>
<h3 id="页表">页表</h3>
<p><strong>解决了逻辑地址到物理地址的转换的问题：</strong></p>
<ul>
<li>将程序逻辑地址空间划分成固定大小的页面;</li>
<li>内存划分成等大小的页框;</li>
<li><code>页表实现页面到页框的索引;</code></li>
<li>页表项个数由程序的逻辑地址空间决定，页表项位数由页框起始物理地址位数决定。</li>
</ul>
<p><strong>记录了页面和页框号（每个页框的起始地址）的对应关系，如下图所示</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622191317403.png" alt="image-20200622191317403" style="zoom:67%;" />
<p>页表<strong>存储了页框的起始物理地址</strong>，需要一个连续的存储空间实现随机访问，对于<strong>逻辑地址相当于页号+页内偏移</strong>。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622200719784.png" alt="image-20200622200719784" style="zoom:80%;" />
<h3 id="地址变换机构">地址变换机构（***）</h3>
<ul>
<li>先让页号与页表基址相加得到<strong>页框号</strong></li>
<li>再让页框号与页内偏移相加得到<strong>物理地址</strong></li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622200925736.png" alt="image-20200622200925736" style="zoom:80%;" />
<h2 id="基本分段存储管理方式">基本分段存储管理方式</h2>
<ul>
<li><strong>离散分配的基本单位是端</strong></li>
<li><strong>采用二维逻辑地址结构，由段号加段内偏移构成</strong></li>
</ul>
<h3 id="段表">段表</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622201627033.png" alt="image-20200622201627033" style="zoom: 67%;" />
<h3 id="地址变换机构-2">地址变换机构（***）</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622201656943.png" alt="image-20200622201656943" style="zoom:80%;" />
<h3 id="分页和分段的主要区别">分页和分段的主要区别</h3>
<ul>
<li>页是信息的物理单位；段是信息的逻辑单位。</li>
<li>页大小固定；段大小不固定。</li>
<li>分页采用一维线性逻辑地址，分段采用二维逻辑地址。</li>
</ul>
<h2 id="虚拟存储器">虚拟存储器（***）</h2>
<p><strong>概念</strong>：虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器，其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度,每位成本接近外存。</p>
<h3 id="虚拟存储器实现方法的硬件支持">虚拟存储器实现方法的硬件支持</h3>
<h4 id="分页请求系统">分页请求系统</h4>
<ol>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ol>
<h4 id="分段请求系统">分段请求系统</h4>
<ol>
<li>请求分段的端表机制</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ol>
<h3 id="页面置换算法">页面置换算法（***）</h3>
<p><strong>页面中断</strong>：发生页面的置换</p>
<h4 id="最佳置换算法理想化">最佳置换算法（理想化）</h4>
<blockquote>
<p>置换以后永不使用或者最长时间不使用的页面</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622203218539.png" alt="image-20200622203218539" style="zoom: 80%;" />
<ul>
<li>发生3次缺页中断和页面中断</li>
</ul>
<h4 id="先进先出页面置换算法">先进先出页面置换算法</h4>
<blockquote>
<p>淘汰最先进入的页面，即选择在内存中驻留时间最久的页面予以淘汰。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622203901808.png" alt="image-20200622203901808" style="zoom:80%;" />
<h4 id="最近最久未使用置换算法lru">最近最久未使用置换算法（LRU）</h4>
<blockquote>
<p>选择最近最久未使用的页面予以淘汰，即当前使用次数最少的页面。</p>
</blockquote>
<p><strong>实现方式</strong>：</p>
<ul>
<li>利用栈保存当前使用的各个页面的页面号,每当进程访问某页面时，便将该页面的页面号从栈中弹出，并将它压入栈顶。<code>因此，栈底是最近最久未使用的页面。</code></li>
<li>使用寄存器，每一次访问都会在寄存器加一，每次置换选择寄存器中次数最少的页面</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622204543566.png" alt="image-20200622204543566" style="zoom:80%;" />
<h4 id="clock置换算法">clock置换算法</h4>
<h5 id="简单clock置换算法最近未访问页面置换算法">简单clock置换算法（最近未访问页面置换算法）</h5>
<ul>
<li>将所有的页面组成一个循环链表,并为每个页面添加一个访问位A。</li>
<li>当一个页面被访问时，将其A位设置为1。</li>
<li>置换过程是从pointer开始，<strong>若该页面的A位为1,将其设置为0,并使pointer指向下一个页面</strong>，直到找到A位为0的页面;<strong>若该页面的A位为0，则将其置换出内存</strong>，并用换入的页面占用换出页面的页框，使pointer指向下一个页面。</li>
<li>如果第一轮没有找到，则执行第二轮，由于第一轮将所有页面的A都设置为0，则一定能在第二轮找到</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101130548.png" alt="image-20200623101130548" style="zoom: 67%;" />
<h5 id="改进型clock置换算法">改进型clock置换算法</h5>
<p><strong>增加一个修改为M，页面状态可以分为四类</strong>：</p>
<ul>
<li>1类(A=0，M=0) ，未访问未修改;</li>
<li>2类(A=0，M= 1)，未访问.已修改;</li>
<li>3类(A=1，M=0)，已访问未修改;</li>
<li>4类(A=1, M= 1) ，已访问已修改;</li>
</ul>
<p><strong>置换过程</strong>：</p>
<ol>
<li>从pointer开始寻找<strong>1类</strong>页面，直到找到1类页面结束，或者扫描完一遍进入第II步。</li>
<li>从pointer开始寻找<strong>2类</strong>页面， 直到找到2类页面结束，或者扫描完一遍进入第I步。在本步每扫描完一个页面，<strong>须将页面的访问位修改为0</strong>。</li>
<li>重复l和II。(一 定可以找到置换的页。)</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101334666.png" alt="image-20200623101334666" style="zoom:80%;" />
<h4 id="最近最少未使用lfu">最近最少未使用（LFU）</h4>
<blockquote>
<p>在最近时期内选择使用次数最少的页面作为淘汰页</p>
</blockquote>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622181520299.png" alt="image-20200622181520299" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190511957.png" alt="image-20200622190511957" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190706448.png" alt="image-20200622190706448" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190752961.png" alt="image-20200622190752961" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622202031148.png" alt="image-20200622202031148" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101755205.png" alt="image-20200623101755205" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
</feed>