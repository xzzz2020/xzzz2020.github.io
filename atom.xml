<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-09-10T12:47:23.534Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[【总结】SpringMVC源码分析]]></title>
        <id>https://xzzz2020.github.io/post/hfCflPZX4/</id>
        <link href="https://xzzz2020.github.io/post/hfCflPZX4/">
        </link>
        <updated>2020-09-10T12:17:52.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90">一、配置文件分析</a>
<ul>
<li><a href="#1-xml%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90">1. XML配置分析</a></li>
<li><a href="#2-mvc%E9%85%8D%E7%BD%AE">2. MVC配置</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%85%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">二、入口方法分析</a>
<ul>
<li><a href="#1-%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96">1. 容器初始化</a></li>
<li><a href="#2-%E8%A7%A3%E6%9E%90controller">2. 解析Controller</a></li>
<li><a href="#3-spring%E5%AF%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81">3. Spring对注解的配置支持</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-springmvc%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B">三、SpringMVC的核心流程</a>
<ul>
<li><a href="#1-%E5%85%B3%E9%94%AE%E6%B5%81%E7%A8%8B">1. 关键流程</a></li>
<li><a href="#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">2. 核心组件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-配置文件分析">一、配置文件分析</h2>
<h3 id="1-xml配置分析">1. XML配置分析</h3>
<p><strong>在一个SSM项目中，需要在xml文件配置SpingMVC的相关组件</strong></p>
<ol>
<li><strong>DispatcherServlet</strong>：做请求分发以及结果渲染</li>
<li><strong>ContextLoaderListener</strong>：配置监听器，在创建Servlet前，加载SpringMVC的配置</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;!-- 配置加载类路径的配置文件 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- 配置监听器 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="2-mvc配置">2. MVC配置</h3>
<ol>
<li>配置了视图解析器<strong>viewResolver</strong>，提供了视图解析的目录以及后缀</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/mvc
           http://www.springframework.org/schema/mvc/spring-mvc.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/aop
      http://www.springframework.org/schema/aop/spring-aop.xsd
           &quot;&gt;

    &lt;!-- 扫描controller的注解，别的不扫描 --&gt;
    &lt;context:component-scan base-package=&quot;cn.xzzz2020.ssm.controller&quot;&gt;
    &lt;/context:component-scan&gt;

    &lt;!-- 配置视图解析器 --&gt;
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;!-- JSP文件所在的目录 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
        &lt;!-- 文件的后缀名 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 开启对SpringMVC注解的支持 --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!--
        支持AOP的注解支持，AOP底层使用代理技术
        JDK动态代理，要求必须有接口
        cglib代理，生成子类对象，proxy-target-class=&quot;true&quot; 默认使用cglib的方式
    --&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="二-入口方法分析">二、入口方法分析</h2>
<h3 id="1-容器初始化">1. 容器初始化</h3>
<blockquote>
<p>第一个需要关注的是ContextLoaderListener</p>
</blockquote>
<ol>
<li>
<p>这个类实现了ServletContextListener接口，本质上是Servlet的监听器</p>
</li>
<li>
<p>Tomcat会优先加载Servlet的监听器，以保证在Servlet初始化时，调用初始化方法contextInitialized</p>
</li>
<li>
<p>接着读取并解析容器的配置，创建并刷新出容器的实例来</p>
</li>
</ol>
<pre><code class="language-java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener {

   /**
    * Initialize the root web application context.
    */
   @Override
   public void contextInitialized(ServletContextEvent event) {
      initWebApplicationContext(event.getServletContext());
   }
}
</code></pre>
<h3 id="2-解析controller">2. 解析Controller</h3>
<ol>
<li>配置前端控制器，这样在容器初始化后，就会解析Controller的@RequestMapping注解</li>
<li>根据注解，建立请求方法和Controller的映射</li>
</ol>
<pre><code class="language-xml">&lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<h3 id="3-spring对注解的配置支持">3. Spring对注解的配置支持</h3>
<p><strong>配置SpringMVC</strong></p>
<pre><code class="language-java">public class StartWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
	/**
	 * SpringContext中相关的bean
	 *
	 * @return
	 */
	@Override
	protected Class&lt;?&gt;[] getRootConfigClasses() {
		return new Class&lt;?&gt;[]{SpringRootConfig.class};
	}
	/**
	 * DispatcherServlet中上下文相关的Bean
	 *
	 * @return
	 */
	@Override
	protected Class&lt;?&gt;[] getServletConfigClasses() {
		return new Class&lt;?&gt;[]{MVCConfig.class};
	}
	/**
	 * Servlet请求映射路径
	 *
	 * @return
	 */
	@Override
	protected String[] getServletMappings(){
		return new String[]{&quot;/&quot;};
	}
	/**
	 * 拦截并处理请求的编码
	 *
	 * @return
	 */
	@Override
	protected Filter[] getServletFilters() {
		CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
		encodingFilter.setEncoding(&quot;UTF-8&quot;);
		encodingFilter.setForceEncoding(true);
		return new Filter[]{encodingFilter};
	}
}
</code></pre>
<p><strong>设置需要扫描的核心包路径</strong></p>
<pre><code class="language-java">/**
 * SpringContext中相关的bean
 *
 * @return
 */
@Configuration
@ComponentScan(&quot;com.imooc.service&quot;)
public class SpringRootConfig {
}
</code></pre>
<p><strong>配置需要扫描的Controller路径</strong></p>
<pre><code class="language-java">/**
 * DispatcherServlet中上下文相关的Bean
 *
 * @return
 */
@Configuration
@ComponentScan(&quot;com.imooc.controller&quot;)
@EnableWebMvc
public class MVCConfig {
    //内部资源视图解析器
	@Bean
	public InternalResourceViewResolver viewResolver(){
		InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver();
		internalResourceViewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
		internalResourceViewResolver.setSuffix(&quot;.jsp&quot;);
		return internalResourceViewResolver;
	}
}
</code></pre>
<h2 id="三-springmvc的核心流程">三、SpringMVC的核心流程</h2>
<blockquote>
<p>主要流程与自定义SpringMVC思路一样，可以参考文章：</p>
</blockquote>
<h3 id="1-关键流程">1. 关键流程</h3>
<ol>
<li>建立请求和Controller方法的映射集合的流程</li>
<li>根据请求查找对应的Controller方法的流程</li>
<li>请求参数绑定到方法的形参</li>
<li>执行方法处理请求</li>
<li>渲染视图</li>
</ol>
<h3 id="2-核心组件">2. 核心组件</h3>
<figure data-type="image" tabindex="1"><img src="https://img-service.csdnimg.cn/img_convert/b550b1f740d71acd5fb649e2af8ad1aa.png" alt="img" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】SpringIOC源码分析]]></title>
        <id>https://xzzz2020.github.io/post/3wLQd4LMj/</id>
        <link href="https://xzzz2020.github.io/post/3wLQd4LMj/">
        </link>
        <updated>2020-09-10T12:16:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li>
<li><a href="#%E4%BA%8C-ioc%E5%AE%B9%E5%99%A8">二、IOC容器</a>
<ul>
<li><a href="#1-%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3beanfactory">1. 简单容器接口BeanFactory</a></li>
<li><a href="#2-listablebeanfactory%E6%8E%A5%E5%8F%A3">2. ListableBeanFactory接口</a></li>
<li><a href="#3-autowirecapablebeanfactory%E6%8E%A5%E5%8F%A3">3. AutowireCapableBeanFactory接口</a></li>
<li><a href="#4-defaultlistablebeanfactory%E7%B1%BB">4. DefaultListableBeanFactory类</a></li>
<li><a href="#5-%E9%AB%98%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3applicationcontext">5. 高级容器接口ApplicationContext</a></li>
<li><a href="#6-configurableapplicationcontext%E6%8E%A5%E5%8F%A3">6. ConfigurableApplicationContext接口</a></li>
<li><a href="#7-abstractapplicationcontext">7. AbstractApplicationContext</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96">三、容器初始化</a>
<ul>
<li><a href="#1-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8post-processor">1. 后置处理器post processor</a></li>
<li><a href="#2-aware%E6%8E%A5%E5%8F%A3">2. Aware接口</a></li>
<li><a href="#3-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%80%85%E6%A8%A1%E5%BC%8F">3. 事件监听者模式</a></li>
<li><a href="#4-%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E9%80%BB%E8%BE%91">4. 容器刷新逻辑</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%AE%B9%E5%99%A8%E8%8E%B7%E5%8F%96bean">四、容器获取Bean</a>
<ul>
<li><a href="#1-getbean">1. getBean</a></li>
<li><a href="#2-%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98">2. 单例的三级缓存</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">3. 如何判断是否是循环依赖？</a></li>
<li><a href="#4-dogetbean%E6%BA%90%E4%BB%A3%E7%A0%81">4. doGetBean源代码</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean">六、容器创建Bean</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">1. 创建前的准备</a></li>
<li><a href="#2-docreatbean">2. doCreatBean</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">3. 如何解决循环依赖</a></li>
<li><a href="#4-spring%E9%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">4. Spring都会出现哪些情况的循环依赖？</a></li>
<li><a href="#%E6%BA%90%E7%A0%81">源码</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%AE%B9%E5%99%A8%E7%9A%84bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">七、容器的Bean依赖注入</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<p><strong>SpringIOC解决的问题</strong>：将对象之间的关系使用配置或者注解管理</p>
<p><strong>Bean是Spring的一等公民</strong>：</p>
<ul>
<li>
<p>Bean的本质就是Java对象，只是这个对象的生命周期由容器管理，只需要告诉Spring它需要管理哪些对象</p>
</li>
<li>
<p>不需要为了创建Bean而在原来的Java类上添加任意的限制，体现了代码的低侵入</p>
</li>
<li>
<p>对Java对象的配置体现在配置文件或者注解上</p>
</li>
</ul>
<p><strong>BeanDefinition</strong></p>
<ul>
<li>
<p>在Java中曾经使用的Class对象来描述，在Spring中描述Bean的定义</p>
</li>
<li>
<p><strong>主要配置额外属性：</strong></p>
<ul>
<li>
<p><strong>作用范围scope（@Scope）</strong>，有五个，最重要的是singleton和prototype</p>
</li>
<li>
<p><strong>懒加载lazi-init（@Lazy）</strong>：决定Bean是否延迟加载，如果为true，则只有在使用的时候才会创建</p>
</li>
<li>
<p><strong>首选primary（@Primary）</strong>：如果存在一个接口对应多个实现，设置为true的Bean会被优先装配</p>
</li>
<li>
<p><strong>工厂类Beanfactory-bean（@Configuration）和工厂方法Beanfactory-method（@Bean）</strong>：指示出Bean在哪个类的什么方法创建</p>
</li>
</ul>
</li>
</ul>
<p><strong>Spring中Bean的继承关系是通过parent属性定义</strong></p>
<h2 id="二-ioc容器">二、IOC容器</h2>
<h3 id="1-简单容器接口beanfactory">1. 简单容器接口BeanFactory</h3>
<p><strong>BeanFactory接口的核心方法：</strong></p>
<ul>
<li><strong>getBean</strong>：可以通过Bean的名字或者Class对象获取Bean的实例</li>
<li><strong>isSingleton和isPrototype</strong>：判断是否是单例</li>
<li><strong>getType</strong>：根据名字获取Class对象</li>
<li><strong>getAliases</strong>：根据Bean的名字获取它的别名数组</li>
</ul>
<p><strong>BeanFactory和FactoryBean的区别？</strong></p>
<ul>
<li>
<p>BeanFactory是Spring IoC容器的实际代表者，IoC容器负责容纳此前所描述的bean，并对bean进行管理。</p>
</li>
<li>
<p>在Spring中，BeanFactory是IoC容器的核心接口。它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
</li>
<li>
<p>Spring为我们提供了许多易用的BeanFactory实现，XmlBeanFactory就是最常用的一个。该实现将以XML方式描述组成应用的对象以及对象间的依赖关系。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。</p>
</li>
<li>
<p>当一个受Spring容器管理的bean 如果实现了FactoryBean接口 在bean实例化(getBean)阶段 Spring会调用该bean的getObejct方法返回的不一定是自身的实例，对bean的生产修饰做了很好的封装。</p>
</li>
<li>
<p>如果想要获取FactoryBean的实现类，在名字前面加“&amp;”</p>
</li>
</ul>
<p><strong>FactoryBean举例</strong></p>
<pre><code class="language-java">@Component
public class UserFactoryBean implements FactoryBean&lt;User&gt; {
   @Override
   public User getObject() throws Exception {
      return new User();
   }

   @Override
   public Class&lt;?&gt; getObjectType() {
      return User.class;
   }
} 

 public static void main(String[] args) {
     ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Entrance.class);
     Object bean = applicationContext.getBean(&quot;&amp;factory&quot;);
     System.out.println(bean);
     Object bean2 = applicationContext.getBean(&quot;factory&quot;);
     System.out.println(bean2);
 }
</code></pre>
<p><strong>output：</strong></p>
<pre><code>com.imooc.entity.factory.factory@3bbc39f8
com.imooc.entity.User@4ae3c1cd
</code></pre>
<h3 id="2-listablebeanfactory接口">2. ListableBeanFactory接口</h3>
<ul>
<li>
<p>负责批量列举容器Bean的信息</p>
<p><strong>核心方法</strong>：</p>
</li>
<li>
<p>getBeanDefinitionNames()：可以列出IOC容器的加载的Bean的名字</p>
</li>
<li>
<p>getBeanDefinitionCount()：获取容器中Bean的数目</p>
</li>
</ul>
<h3 id="3-autowirecapablebeanfactory接口">3. AutowireCapableBeanFactory接口</h3>
<ul>
<li>负责自动依赖注入</li>
</ul>
<p><strong>自动装配策略有</strong>：</p>
<ul>
<li>根据名称</li>
<li>根据类型</li>
<li>根据构造函数</li>
<li>不自动装配</li>
</ul>
<blockquote>
<p>比如@Autowire方法调用的就是resolveDependency()实现的自动注入，使用的是根据类型进行依赖注入，@Resource和@Qualifier按名称匹配注入Bean</p>
</blockquote>
<h3 id="4-defaultlistablebeanfactory类">4. DefaultListableBeanFactory类</h3>
<ul>
<li>第一个具备IOC容器的实现类</li>
<li>提供了beanDefinitionMap负责记录Bean的定义</li>
</ul>
<pre><code class="language-java">	/** Map of bean definition objects, keyed by bean name. */
	//记录Bean的注册信息
	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);
</code></pre>
<h3 id="5-高级容器接口applicationcontext">5. 高级容器接口ApplicationContext</h3>
<p><strong>继承了多个接口，提供了丰富的功能</strong>：</p>
<ul>
<li>EnvironmentCapable：提供加载多个配置文件的能力</li>
<li>ListableBeanFactory：通过列表的方式管理Bean</li>
<li>HierarchicalBeanFactory：支持多层级的容器，提供对每一个层级Bean的管理</li>
<li>ResourcePatternResolver：可以用于加载资源文件</li>
<li>ApplicationEventPublisher：具备事件发布的能力</li>
</ul>
<p><strong>基于传统XML配置的实现类：</strong></p>
<ul>
<li>**FileSystemXmlApplicationContext：**从文件系统加载并定义相关资源</li>
<li>**ClassPathXmlApplicationContext：**从classpath加载配置</li>
<li>**XmlWebApplicationContext：**用于Web应用程序</li>
</ul>
<p><strong>流行的根据注解的实现类</strong></p>
<ul>
<li>
<p>**AnnotationConfigApplicationContext：**负责非Web应用</p>
</li>
<li>
<p>**AnnotationConfigServletWebServerApplicationContext：**负责Web的应用</p>
</li>
<li>
<p>**AnnotationConfigReactiveWebServerApplicationContext：**额外满足响应式的需求</p>
</li>
</ul>
<h3 id="6-configurableapplicationcontext接口">6. ConfigurableApplicationContext接口</h3>
<ul>
<li>是ApplicationContext的子接口</li>
<li>继承了Lifecycle接口，提供控制IOC容器生命周期的方法</li>
<li>提供了refresh方法，初始化容器，也可以重新启动容器</li>
</ul>
<h3 id="7-abstractapplicationcontext">7. AbstractApplicationContext</h3>
<p><strong>是一个模板方法的一个体现</strong></p>
<ul>
<li><strong>refresh</strong>，属于模板方法，定义了容器初始化的算法骨架</li>
<li><strong>prepareRefresh</strong>，是一个具体的方法，由这个抽象类本身实现</li>
<li><strong>postProcessBeanFactory</strong>是一个钩子方法，子类可以根据情况选择是否实现</li>
<li><strong>refreshBeanFactory</strong>是一个抽象方法，强制子类实现</li>
</ul>
<h2 id="三-容器初始化">三、容器初始化</h2>
<blockquote>
<p>主要处理逻辑是AbstractApplicationContext的Refresh()方法，这是个模板方法，定义了容器初始化的算法，应用了模板设计模式，所以这个类也是个抽象类。</p>
</blockquote>
<h3 id="1-后置处理器post-processor">1. 后置处理器post processor</h3>
<p><strong>有三种后置处理器</strong>：</p>
<ul>
<li>
<p>BeanDefinition后置处理器，继承了BeanFactory后置处理器，用于处理BeanDefinition，也可以处理容器</p>
</li>
<li>
<p>BeanFactory后置处理器，用于处理容器</p>
</li>
<li>
<p>Bean的后置处理器，用于处理Bean</p>
</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>本身也是需要注册到容器中的Bean</li>
<li>定义一些方法，这些方法会在特定的时机被容器所调用</li>
<li>实现不改变容器或者Bean核心逻辑的情况下对容器或者Bean进行扩展</li>
<li>比如对一些方法进行包装，修改内容等</li>
</ul>
<p><strong>BeanDefinitionPostProcessor举例</strong></p>
<ul>
<li>Mybatis就会搜索第三方Jar包中的Class，将其注入到IOC容器中</li>
</ul>
<p><strong>BeanPostProcessor举例</strong></p>
<ul>
<li>有两个方法分别负责Bean初始化前做什么事情，初始化后做什么事情，但是需要定义一个过滤规则，对不同的bean进行过滤</li>
</ul>
<h3 id="2-aware接口">2. Aware接口</h3>
<ul>
<li>bean实现xxxAware接口可以感知到容器</li>
<li>可以获取容器BeanFactory（低级容器）、ApplicationContext（高级容器）、BeanName（bean的名字）、ResourceLoader（资源加载器）</li>
</ul>
<h3 id="3-事件监听者模式">3. 事件监听者模式</h3>
<p><strong>Spring中的事件驱动模型</strong></p>
<ul>
<li><strong>事件</strong>：ApplicationEvent抽象类是Spring中所有事件的父类，比如对于容器事件定义了一个ApplicationContextEvent子类，该子类有几个子类，比如容器关闭后的事件、容器启动时的事件、容器初始化完成后的事件</li>
<li><strong>事件监听器</strong>：ApplicationListener接口，该接口的两个子接口都有两个方法，判断当前事件源以及事件是否是该监听器感兴趣的，开发者可以继承父接口或者在某个Bean方法上使用注解@EventListener</li>
<li><strong>事件发布器</strong>：ApplicationEventPublisher以及ApplicationEventMulticaster接口。ApplicationEventPublisher提供事件发布的能力，ApplicationContext实现了该接口，也就是说高级的IOC容器具备发布事件的能力，可以在bean实现对应的Aware接口，获取容器的发布器。ApplicationEventMulticaster提供了注册和删除监听器的能力，利用Set集合保存监听器，默认的子实现类在定义了Executor，也就是可以通过多线程使用异步的方式调用注册好的监听器</li>
</ul>
<p><strong>详情见：</strong></p>
<h3 id="4-容器刷新逻辑">4. 容器刷新逻辑</h3>
<ol>
<li>
<p><strong>调用prepareRefresh()：负责做刷新前的准备工作</strong></p>
<ul>
<li>设置刷新时间</li>
<li>设置容器的状态为激活</li>
<li>创建事件集合</li>
</ul>
</li>
<li>
<p><strong>obtainFreshBeanFactory()：获取容器刷新后的BeanFactory实例，会进行BeanDefinition的注册</strong></p>
</li>
<li>
<p><strong>prepareBeanFactory(beanFactory)：为容器注册一些系统级别的Bean</strong></p>
</li>
</ol>
<ul>
<li>
<p>设置表达式语言处理器、资源加载器、事件发布器</p>
</li>
<li>
<p>设置动态装配规则</p>
</li>
<li>
<p>判断是否需要织入器，使用Bean级别的后置处理器进行AOP操作</p>
</li>
<li>
<p>添加后置处理器将容器传递给实现ApplicationContextAware接口的Bean、如果某个 bean实现了Aware接口，将在自动装配的时候忽略它们</p>
</li>
</ul>
<ol start="4">
<li>
<p><strong>postProcessBeanFactory(beanFactory)：注册容器级别的后置处理器</strong></p>
</li>
<li>
<p><strong>invokeBeanFactoryPostProcessors(beanFactory)：调用容器级别的后置处理器</strong></p>
</li>
<li>
<p><strong>registerBeanPostProcessors(beanFactory)：注册Bean级别的后置处理器，在类初始化前和初始化后进行一些处理</strong></p>
</li>
<li>
<p><strong>initMessageSource()：初始化国际化的配置</strong></p>
</li>
<li>
<p><strong>initApplicationEventMulticaster()：初始化事件发布者组件，支持事件的发布和注册</strong></p>
</li>
<li>
<p><strong>onRefresh()：提供提前初始化一些特殊的Bean</strong></p>
</li>
<li>
<p><strong>registerListeners()：注册事件监听器</strong></p>
</li>
<li>
<p><strong>finishBeanFactoryInitialization(beanFactory)：主要实例化所有不是懒加载的实例</strong></p>
<ul>
<li>
<p>解析相关配置文件的值，如@Value注解</p>
</li>
<li>
<p>进行类编译器的AOP织入操作</p>
</li>
<li>
<p>先实例化所有不是懒加载的实例，通过BeanDefinition判断Bean是否是抽象的、单例的和懒加载的</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>AOP分为三种方式：编译期织入、类加载期织入和运行期织入</p>
</blockquote>
<ol start="12">
<li>
<p><strong>finishRefresh()：触发初始化完成的回调方法，发布容器刷新完成的事件给监听者</strong></p>
</li>
<li>
<p><strong>resetCommonCaches()：重启共用缓存</strong></p>
</li>
</ol>
<p><strong>refresh源码</strong></p>
<pre><code class="language-java">	/**
	 * 加载或刷新一个持久化的配置，可能是XML文件、属性文件或关系数据库模式。
	 * 由于这是一种启动方法，如果失败，应该销毁已经创建的单例，以避免悬空资源。
	 * 换句话说，在调用该方法之后，要么全部实例化，要么完全不实例化。
	 * @throws 如果bean工厂无法初始化，则抛出 BeansException 异常
	 * @throws 如果已经初始化且不支持多次刷新，则会抛出 IllegalStateException 异常
	 */
	@Override
	public void refresh() throws BeansException, IllegalStateException {
		// 给容器refresh加锁，避免容器处在refresh阶段时，容器进行了初始化或者销毁的操作
		synchronized (this.startupShutdownMonitor) {
			// 调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识，具体方法
			prepareRefresh();

			//告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从
			//子类的refreshBeanFactory()方法启动，里面有抽象方法
			//针对xml配置，最终创建内部容器，该容器负责 Bean 的创建与管理，此步会进行BeanDefinition的注册
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// 注册一些容器中需要的系统Bean.例如classloader，beanfactoryPostProcessor等
			prepareBeanFactory(beanFactory);

			try {
				//允许容器的子类去注册postProcessor  ，钩子方法
				postProcessBeanFactory(beanFactory);

				// 激活在容器中注册为bean的BeanFactoryPostProcessors
				//对于注解容器，org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
				//方法扫描应用中所有BeanDefinition并注册到容器之中
				invokeBeanFactoryPostProcessors(beanFactory);

				// 注册拦截bean创建过程的BeanPostProcessor
				registerBeanPostProcessors(beanFactory);

				// 找到“messageSource”的Bean提供给ApplicationContext使用，
				// 使得ApplicationContext具有国际化能力。
				initMessageSource();

				// 初始化ApplicationEventMulticaster该类作为事件发布者，
				// 可以存储所有事件监听者信息，并根据不同的事件，通知不同的事件监听者。
				initApplicationEventMulticaster();

				// 预留给 AbstractApplicationContext 的子类用于初始化其他特殊的 bean，
				// 该方法需要在所有单例 bean 初始化之前调用
				// 比如Web容器就会去初始化一些和主题展示相关的Bean（ThemeSource）
				onRefresh();

				// 注册监听器（检查监听器的bean并注册它们）
				registerListeners();

				//设置自定义的类型转化器ConversionService，
				// 设置自定义AOP相关的类LoadTimeWeaverAware，
				// 清除临时的ClassLoader
				// ，实例化所有的类（懒加载的类除外）
				finishBeanFactoryInitialization(beanFactory);

				// 初始化容器的生命周期事件处理器，（默认使用DefaultLifecycleProcessor），调用扩展了SmartLifecycle接口的start方法
				// 当Spring容器加载所有bean并完成初始化之后，会接着回调实现该接口的类中对应的方法（start()方法）
				// 并发布容器刷新完毕事件ContextRefreshedEvent给对应的事件监听者
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				//销毁已创建的Bean
				destroyBeans();

				// Reset 'active' flag.
				//取消refresh操作，重置容器的同步标识
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// 重置Spring内核中的共用的缓存，因为我们可能再也不需要单例bean的元数据了……
				resetCommonCaches();
			}
		}
	}
</code></pre>
<h2 id="四-容器获取bean">四、容器获取Bean</h2>
<blockquote>
<p>主要了解的是@Autowired注解的，使用类型的注入方式。</p>
</blockquote>
<p><strong>方法递归调用顺序</strong>：</p>
<ol>
<li>getBean()</li>
<li>dogetBean()</li>
<li>getSingleton()：从缓存中获取</li>
<li>createBeanInstance()：创建未赋值的Bean实例</li>
<li>addSingletonFactory()：为了防止循环引用，将对象引用放入三级缓存</li>
<li>populateBean：进行依赖注入</li>
</ol>
<h3 id="1-getbean">1. getBean</h3>
<blockquote>
<p>是AbstractAutowireCapableBeanFactory的getBean方法，真正工作的是doGetBean方法</p>
</blockquote>
<p><strong>核心逻辑</strong>：</p>
<ol>
<li>将GetBean方法传入的名字进行处理，比如是不是用&amp;符号打头，以及尝试从别名集合中获取真正的名字，可能会出现获取到的依然是别名，所以就会递归查询，直到查询不出别名</li>
<li>根据Bean的名字，尝试从缓存中获取单例Bean实例，可能是单例Bean或者FactoryBean本身，如果存在Bean实例直接返回，或者存在FactoryBean，会调用getObject方法返回Bean实例</li>
<li>循环依赖判断，就是A中存在属性B，B中存在属性A，就出现了循环的依赖问题，即A的创建依赖于B的创建，B的创建依赖于A的创建</li>
<li>递归去父容器获取BeanDefinition实例，最后会合并子类和父类的BeanDefinition，防止出现BeanDefinition过期的情况</li>
<li>递归实例化显示依赖的Bean，如果A中的depends-on属性指向B，则B要先被实例化，依赖关系会注册到Set中，保存了A依赖哪些以及哪些依赖A。如果人为定义的属性出现循环依赖，则会直接出现异常，因为Spring框架，认为这个创建顺序是必须要严格遵守的</li>
<li>根据不同的Scope采用不同的策略创建Bean，最后放入到一级缓存中，并将二级三级缓存清除，并且注册在Bean创建成功列表</li>
<li>对Bean进行类型检查</li>
</ol>
<p><strong>FactoryBean和ObjectBean的区别？</strong></p>
<ul>
<li>
<p>ObjectBean功能和FactoryBean类似，但是为了区别用户自定义的和框架自己使用的，采用了两套名字</p>
</li>
<li>
<p>框架使用ObjectBean接口的不同实现类，会产生不同Scope的实例对象</p>
</li>
</ul>
<h3 id="2-单例的三级缓存">2. 单例的三级缓存</h3>
<ul>
<li>先从<strong>singletonObjects这个一级缓存</strong>获取，主要包含最终形态的Bean实例</li>
<li>如果一级缓存没有获取到，就会给一级缓存加锁，<strong>从二级缓存获取，也就是earlySingletonObjects</strong>，因为前面已经加锁，所以二级缓存以及三级缓存都是采用的HashMap来提升性能，二级缓存是早期的bean实例，还没有给属性赋值</li>
<li>如果二级缓存没有获取到，就会<strong>从三级缓存获取，也就是singletonFactorys</strong>中获取，这里面存储的是ObjectBean，类似于FactoryBean。如果此时获取到，就会调用getObject方法，存入二级缓存，然后删除三级缓存，防止重复创建</li>
</ul>
<h3 id="3-如何判断是否是循环依赖">3. 如何判断是否是循环依赖？</h3>
<ol>
<li>
<p>创建一个Bean时，就会记录在一个列表中，单例模式会记录在Set集合中，而原型模式会记录在一个ThreadLocal中，确保一个线程创建一个</p>
</li>
<li>
<p>如果A依赖B，就会先创建B，B此时依赖A，就会再创建A，发现A正在被创建，就认为有循环依赖，防止doGetBean递归调用</p>
</li>
<li>
<p>支持单例模式的循环依赖</p>
</li>
<li>
<p>对原型模式，如果判断到循环依赖，就会抛出异常，是不支持的</p>
</li>
</ol>
<p><strong>源码：</strong></p>
<pre><code class="language-java">	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		//尝试从一级缓存里面获取完备的Bean
		Object singletonObject = this.singletonObjects.get(beanName);
		//如果完备的单例还没有创建出来，创建中的Bean的名字会被保存在singletonsCurrentlyInCreation中
		//因此看看是否正在创建
		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
			//尝试给一级缓存对象加锁，因为接下来就要对缓存对象操作了
			synchronized (this.singletonObjects) {
				//尝试从二级缓存earlySingletonObjects这个存储还没进行属性添加操作的Bean实例缓存中获取
				singletonObject = this.earlySingletonObjects.get(beanName);
				//如果还没有获取到并且第二个参数为true，为true则表示bean允许被循环引用
				if (singletonObject == null &amp;&amp; allowEarlyReference) {
					//从三级缓存singletonFactories这个ObjectFactory实例的缓存里尝试获取创建此Bean的单例工厂实例
					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
					//如果获取到工厂实例
					if (singletonFactory != null) {
						//调用单例工厂的getObject方法返回对象实例
						singletonObject = singletonFactory.getObject();
						//将实例放入二级缓存里
						this.earlySingletonObjects.put(beanName, singletonObject);
						//从三级缓存里移除
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
</code></pre>
<h3 id="4-dogetbean源代码">4. doGetBean源代码</h3>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
		//通过三种形式获取beanName
		// 一个是原始的beanName，一个是加了&amp;的，一个是别名
		final String beanName = transformedBeanName(name);
		Object bean;
		// 尝试从单例缓存集合里获取bean实例
		Object sharedInstance = getSingleton(beanName);
		//如果先前已经创建过单例Bean的实例，并且调用的getBean方法传入的参数为空
		//则执行if里面的逻辑
		//args之所以要求为空是因为如果有args，则需要做进一步赋值，因此无法直接返回
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isTraceEnabled()) {
				//如果Bean还在创建中，则说明是循环引用
				if (isSingletonCurrentlyInCreation(beanName)) {
                //...
                }
			}
			// 如果是普通bean，直接返回，如果是FactoryBean，则返回他的getObject
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}
		//若scope为prototype或者单例模式但是缓存中还不存在bean
		else {
			//如果scope为prototype并且显示还在创建中，则基本是循环依赖的情况
			//针对prototype的循环依赖，spring无解，直接抛出异常
			// A-&gt;B-&gt;A
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// 从当前容器中找不到指定名称的bean,此时递归去parentFactory查找
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				// 主要针对FactoryBean，将Bean的&amp;重新加上
				String nameToLookup = originalBeanName(name);
				//如果parent容器依旧是AbstractBeanFactory的实例
				//instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					//直接递归调用方法来查找
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				//....
			}
			//typeCheckOnly 是用来判断调用 getBean() 是否仅仅是为了类型检查获取 bean，而不是为了创建Bean
			if (!typeCheckOnly) {
				// 如果不是仅仅做类型检查则是创建bean
				markBeanAsCreated(beanName);
			}

			try {
				//将父类的BeanDefinition与子类的BeanDefinition进行合并覆盖
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				//对合并的BeanDefinition做验证，主要看属性是否为abstract的
				checkMergedBeanDefinition(mbd, beanName, args);
				// 获取当前Bean所有依赖Bean的名称
				String[] dependsOn = mbd.getDependsOn();
				// 如果当前Bean设置了dependsOn的属性
				//depends-on用来指定Bean初始化及销毁时的顺序
				//&lt;bean id=a Class=&quot;com.imooc.A&quot; depends-on=&quot;b&quot; /&gt;
				// &lt;bean id=b Class=&quot;com.imooc.B&quot; /&gt;
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						//校验该依赖是否已经注册给当前 bean,注意这里传入的key是当前的bean名称
						//这里主要是判断是否有以下这种类型的依赖：
						//&lt;bean id=&quot;beanA&quot; class=&quot;BeanA&quot; depends-on=&quot;beanB&quot;&gt;
						//&lt;bean id=&quot;beanB&quot; class=&quot;BeanB&quot; depends-on=&quot;beanA&quot;&gt;
						//如果有，则直接抛出异常
						if (isDependent(beanName, dep)) {
							//...
						}
						//缓存依赖调用，注意这里传入的key是被依赖的bean名称
						registerDependentBean(dep, beanName);
						//递归调用getBean方法，注册Bean之间的依赖（如C需要晚于B初始化，而B需要晚于A初始化
						// 初始化依赖的bean
						getBean(dep);

					}
				}

				//如果BeanDefinition为单例
				if (mbd.isSingleton()) {
					//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象
					sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// 显式从单例缓存中删除 bean 实例
							// 因为单例模式下为了解决循环依赖，可能它已经存在了，所以将其销毁
							destroySingleton(beanName);
							throw ex;
						}
					});
					// 如果是普通bean，直接返回，是FactoryBean，返回他的getObject
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					//Prototype每次都会创建一个新的对象
					Object prototypeInstance = null;
					//默认的功能是注册当前创建的prototype对象为正在创建中
					beforePrototypeCreation(beanName);
					//创建原型对象实例
					prototypeInstance = createBean(beanName, mbd, args);
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				//要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中
				//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中
				//比较常用，如：request、session、application等生命周期
						
		}

		//对创建的Bean实例对象进行类型检查
		if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
			//....
		}
		return (T) bean;
	}
</code></pre>
<h2 id="六-容器创建bean">六、容器创建Bean</h2>
<blockquote>
<p>这个是doGetBean方法里面的CreatBean</p>
</blockquote>
<h3 id="1-创建前的准备">1. 创建前的准备</h3>
<blockquote>
<p>AbstractAutowireCapableBeanFactory类的createBean方法</p>
</blockquote>
<ol>
<li>Bean类型的解析，主要是解析获取Class对象</li>
<li>处理方法覆盖，比如说lookup-method属性以及replaced-method属性指定的Bean中是否有这些方法，以及是否出现方法的重载，否则还需要对方法进行处理</li>
<li>做Bean实例化前的后置处理</li>
<li>最后调用doCreatBean方法进行创建</li>
</ol>
<p><strong>源码：</strong></p>
<pre><code class="language-java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
		//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载
		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
			//克隆一份BeanDefinition，用来设置上加载出来的class对象
			//之所以后续用该副本操作，是因为不希望将解析的class绑定到缓存里的BeanDefinition
			//因为class有可能是每次都需要动态解析出来的
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		//校验和准备Bean中的方法覆盖
		mbdToUse.prepareMethodOverrides();
		//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象
		//resolveBeforeInstantiation只是针对有自定义的targetsource，
		// 因为自定义的targetsource不是spring的bean那么肯定不需要进行后续的一系列的实例化,初始化。
		// 所以可以在resolveBeforeInstantiation直接进行proxy
		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		if (bean != null) {
			return bean;
		}
		//创建Bean的入口
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
	}
</code></pre>
<h3 id="2-docreatbean">2. doCreatBean</h3>
<ol>
<li>
<p>通过工厂方法比如说factory-method方法，或者使用无参构造器注入以及含参构造器注入最终创建一个无属性的Bean实例，在这一步会判断是否需要利用CGLIB替换方法</p>
</li>
<li>
<p>执行Bean实例化后的后置处理器，其中包含记录被@Autowired或者@Value方法标记的属性或者方法实例，便于后续的依赖处理，但是这个标记不会标记JDK自带的类，防止对JDK底层源码进行更改；也无法标记静态属性和方法</p>
</li>
<li>
<p>会创建BeanFactory注册到三级缓存中，并清空了二级缓存</p>
</li>
<li>
<p>判断是否Bean允许提前暴露，需要满足单例、支持循环依赖、以及正在被创建三个条件，这个Bean还没有填充属性，从BeanFactory获取实例，清除三级缓存，并放入二级缓存</p>
</li>
<li>
<p>填充Bean属性，执行populateBean方法</p>
</li>
<li>
<p>对Bean进行初始化操作，先判断是否实现了Aware接口，让用户感知到Bean创建，然后在执行初始化方法，最后执行Bean初始化完成的后置处理器</p>
</li>
<li>
<p>注册相关销毁逻辑</p>
</li>
<li>
<p>返回创建好的Bean</p>
</li>
</ol>
<p><strong>先注册在三级缓存，再从三级缓存取出实例化的原因？</strong></p>
<p><strong>源码：</strong></p>
<pre><code class="language-java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {
		// Instantiate the bean.
		//bean实例包装类
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			//从未完成创建的包装Bean缓存中清理并获取相关中的包装Bean实例，毕竟是单例的，只能存一份
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			//创建bean的时候，这里创建bean的实例有三种方法
			//1.工厂方法创建
			//2.构造方法的方式注入
			//3.无参构造方法注入
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		//获取被包装的Bean，后续对bean的改动相当于对Wrapper的改动，反之依然
		final Object bean = instanceWrapper.getWrappedInstance();
		//获取实例化对象的类型
		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}
		//调用BeanDefinition属性合并完成后的BeanPostProcessor后置处理器
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				//被@Autowired、@Value标记的属性在这里获取
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
 				mbd.postProcessed = true;
			}
		}
		//向容器中缓存单例模式的Bean对象，以防循环引用
		//判断是否是早期引用的bean，如果是，则允许其提前暴露引用
		//这里判断的逻辑主要有三个：
		//1.是否为单例
		//2.是否允许循环引用
		//3.是否是在创建中的bean
		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
						&quot;' to allow for resolving potential circular references&quot;);
			}
			//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用
			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
		}


		//Bean对象的初始化，依赖注入在此触发
		//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean
		Object exposedObject = bean;
		//填充bean实例的属性
		populateBean(beanName, mbd, instanceWrapper);
		//初始化bean，过程如下：
		//1：判断是否实现了BeanNameAware，BeanClassLoaderAware，
		//   BeanFactoryAware方法，如果有，则设置相关的属性
		//2: 调用bean初始化的前置（BeanPostProcessor）操作
		//3: 执行初始化的方法。
		//	如果有initializingBean，则调用afterPropertiesSet
		//	如果有InitMethod，则调用初始方法
		//4: 调用bean初始化的后置（BeanPostProcessor）操作
		exposedObject = initializeBean(beanName, exposedObject, mbd);
		//若允许循环依赖，则解决相关的循环依赖
		if (earlySingletonExposure) {
			//获取指定名称的已注册的单例模式Bean对象
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				//如果经过initializeBean执行后返回的bean还是同一个（不是代理对象实例,即没有被增强）
				if (exposedObject == bean) {
					// 确保根据名称获取到的的已注册的Bean和正在实例化的Bean是同一个
					exposedObject = earlySingletonReference;
				}
				//如果上面的if没通过，则表明引用的bean和注入的bean不一致，则需要看看依赖于此Bean的先前是否已经注入了不完善的Bean
				// allowRawInjectionDespiteWrapping 标注是否允许此Bean的原始类型被注入到其它Bean里面，
				// 即使自己最终会被包装（代理）
				// dependentBeanMap记录着每个依赖于此Bean的Bean实例集合
				//当发生循环引用时不允许新创建实例对象
				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
					//获取依赖于当前Bean的Bean实例
					for (String dependentBean : dependentBeans) {
						//移除掉只是用来进行类型检查的单例Bean
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					/**
					 * 因为bean创建后其所依赖的bean一定是已经创建的
					 * actualDependentBeans不为空则表示当前bean创建后其依赖的bean却没有全部创建完，也就是说存在循环依赖
					 */
					if (!actualDependentBeans.isEmpty()) {
						//....
					}
				}
			}
		}
		//注册Bean的销毁逻辑
		registerDisposableBeanIfNecessary(beanName, bean, mbd);
		return exposedObject;
	}
</code></pre>
<h3 id="3-如何解决循环依赖">3. 如何解决循环依赖</h3>
<blockquote>
<p>如果A依赖B，B依赖A</p>
</blockquote>
<ol>
<li>假设A先开始创建，会进行doCreateBean的处理，生成一个没有任何属性的实例</li>
<li>将A实例对应的ObjectFactory放入三级缓存，此时只有三级缓存保存了实例</li>
<li>对A进行属性赋值，此时会尝试获取实例B，由于还没有创建，就会递归进入doCreateBean创建实例B</li>
<li>将B实例对用的ObjectFactory放入三级缓存，此时三级缓存保存了A和B实例</li>
<li>对B实例进行赋值时，会调用getBean方法尝试从三级缓存中获取A实例，此时就可以获取到A的实例，并完成赋值</li>
<li>获取到A实例后，就会将该实例放入二级缓存，并清除三级缓存</li>
<li>方法返回A的属性赋值，将完整的B实例注册到A实例的属性中</li>
<li>两个实例放入一级缓存，清空其他的缓存</li>
</ol>
<h3 id="4-spring都会出现哪些情况的循环依赖">4. Spring都会出现哪些情况的循环依赖？</h3>
<ol>
<li>构造器循环依赖</li>
<li>Setter注入循环依赖</li>
</ol>
<p><strong>构造器循环依赖</strong></p>
<pre><code class="language-java">@Repository
public class Company {
	private Staff staff;
	@Autowired
	public Company(Staff staff){
		this.staff = staff;
	}
}

@Repository
public class Staff {
	private Company company;
	@Autowired
	public Staff(Company company){
		this.company = company;
	}
}

</code></pre>
<p><strong>Setter注入循环依赖</strong></p>
<pre><code class="language-java">@Repository
public class BoyFriend {
	@Autowired
	private GirlFriend girlFriend;
}

@Repository
public class GirlFriend {
	@Autowired
	private BoyFriend boyFriend;
}

</code></pre>
<ul>
<li>
<p><strong>不支持原型模式的循环依赖的</strong>：没有提供了三级缓存的机制支持，只能通过Bean名字放入缓存中阻断三级缓存</p>
</li>
<li>
<p><strong>对于构造器单例循环依赖问题</strong>：因为创建无属性Bean的时候，构造器依赖其他Bean，无法放入第三级缓存中，就会出现循环的调用</p>
</li>
</ul>
<h3 id="源码">源码</h3>
<pre><code class="language-java">	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
		//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载
		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
			//克隆一份BeanDefinition，用来设置上加载出来的class对象
			//之所以后续用该副本操作，是因为不希望将解析的class绑定到缓存里的BeanDefinition
			//因为class有可能是每次都需要动态解析出来的
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		//校验和准备Bean中的方法覆盖
		mbdToUse.prepareMethodOverrides();
		//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象
		//resolveBeforeInstantiation只是针对有自定义的targetsource，
		// 因为自定义的targetsource不是spring的bean那么肯定不需要进行后续的一系列的实例化,初始化。
		// 所以可以在resolveBeforeInstantiation直接进行proxy
		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		if (bean != null) {
			return bean;
		}
		//创建Bean的入口
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
	}
</code></pre>
<h2 id="七-容器的bean依赖注入">七、容器的Bean依赖注入</h2>
<blockquote>
<p>这个是doCreatBean方法里面的populateBean方法</p>
</blockquote>
<p><strong>处理逻辑</strong></p>
<ol>
<li>如果注册了后置处理器，要在设置属性前去修改Bean状态，也可以控制是否继续给Bean设置属性值，这时用户已经赋值了</li>
<li>针对XML配置，如果配置了是按名字装配或者按照类型，则先保存这个配置</li>
<li>调用后置处理器，对没有经过第二步处理的属性进行处理，比如说通过注解注入的，尝试从容器的缓存中获取，而且@Autowire并非非得按照类型来查找，在根据类型没有找到时，会尝试使用类型的名字按照名字装配或者按照别名装配</li>
<li>注解装配完成后，就会注入XML方式配置的</li>
<li>注入的Bean实例并非直接反射创建，而是还是要通过getBean方法从三级缓存获取或者创建一个新的，注入的方式还是通过反射设置</li>
</ol>
<p><strong>源码</strong></p>
<pre><code class="language-java">	protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
		// 给InstantiationAwareBeanPostProcessors最后一次机会在属性注入前修改Bean的属性值，也可以控制是否继续填充Bean
		// 具体通过调用postProcessAfterInstantiation方法，如果调用返回false,表示不必继续进行依赖注入，直接返回
		// 主要是让用户可以自定义属性注入。比如用户实现一个 InstantiationAwareBeanPostProcessor 类型的后置处理器，
		// 并通过 postProcessAfterInstantiation 方法向 bean 的成员变量注入自定义的信息。
		boolean continueWithPropertyPopulation = true;
		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						continueWithPropertyPopulation = false;
						break;
					}
				}
			}
		}
		//如果上面设置 continueWithPropertyPopulation = false，表明用户可能已经自己填充了
		// bean 的属性，不需要 Spring 帮忙填充了。此时直接返回即可
		if (!continueWithPropertyPopulation) {
			return;
		}
		// pvs是一个MutablePropertyValues实例，里面实现了PropertyValues接口，
		// 提供属性的读写操作实现，同时可以通过调用构造函数实现深拷贝
		//获取BeanDefinition里面为Bean设置上的属性值
		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
		// 根据Bean配置的依赖注入方式完成注入，默认是0，即不走以下逻辑，所有的依赖注入都需要在xml文件中有显式的配置
		// 如果设置了相关的依赖装配方式，会遍历Bean中的属性，根据类型或名称来完成相应注入，无需额外配置
		int resolvedAutowireMode = mbd.getResolvedAutowireMode();
		if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

			// 根据beanName进行autowiring自动装配处理
			// 	&lt;bean id=&quot;boyFriend&quot; class=&quot;com.imooc.dao.impl.BoyFriend&quot;  autowire=&quot;byName&quot;&gt;&lt;/bean&gt;
			if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);
			}

			//根据Bean的类型进行autowiring自动装配处理
			//	&lt;bean id=&quot;boyFriend&quot; class=&quot;com.imooc.dao.impl.BoyFriend&quot;  autowire=&quot;byType&quot;&gt;&lt;/bean&gt;
			if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);
			}
			pvs = newPvs;
		}
		// 容器是否注册了InstantiationAwareBeanPostProcessor
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		// 是否进行依赖检查，默认为false
		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

		PropertyDescriptor[] filteredPds = null;
		if (hasInstAwareBpps) {
			if (pvs == null) {
				pvs = mbd.getPropertyValues();
			}
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					//在这里会对@Autowired标记的属性进行依赖注入
					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
					if (pvsToUse == null) {
						if (filteredPds == null) {
							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
						}
						// 对解析完但未设置的属性再进行处理
						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvsToUse == null) {
							return;
						}
					}
					pvs = pvsToUse;
				}
			}
		}
		// 依赖检查，对应depend-on属性，3.0已经弃用此属性
		if (needsDepCheck) {
			// 过滤出所有需要进行依赖检查的属性编辑器
			if (filteredPds == null) {
				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			}
			checkDependencies(beanName, mbd, filteredPds, pvs);
		}

		if (pvs != null) {
			//最终将属性注入到Bean的Wrapper实例里，这里的注入主要是供
			//显式配置了autowiredbyName或者ByType的属性注入，
			//针对注解来讲，由于在AutowiredAnnotationBeanPostProcessor已经完成了注入，
			//所以此处不执行
			applyPropertyValues(beanName, mbd, bw, pvs);
		}
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】SpringAOP源码分析]]></title>
        <id>https://xzzz2020.github.io/post/JG9MpEbxa/</id>
        <link href="https://xzzz2020.github.io/post/JG9MpEbxa/">
        </link>
        <updated>2020-09-10T12:14:40.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-springaop%E7%9A%84%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B">一、SpringAOP的总体流程</a></li>
<li><a href="#%E4%BA%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E4%B8%8Aenableaspectjautoproxy%E5%B0%B1%E8%83%BD%E6%94%AF%E6%8C%81aop">二、为什么在启动类加上@EnableAspectJAutoProxy就能支持AOP</a>
<ul>
<li><a href="#%E4%B8%89-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90aop%E7%9A%84%E6%9C%8D%E5%8A%A1">三、如何注册解析AOP的服务？</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E5%8A%A0%E8%BD%BD%E5%88%86%E6%9E%90">四、横切逻辑加载分析</a>
<ul>
<li><a href="#1-targetsource%E6%8E%A5%E5%8F%A3">1. TargetSource接口</a></li>
<li><a href="#2-buildaspectjadvisors%E6%96%B9%E6%B3%95">2. buildAspectJAdvisors方法</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E7%BB%87%E5%85%A5">五、横切逻辑织入</a>
<ul>
<li><a href="#1-%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E7%9A%84%E7%BB%87%E5%85%A5%E6%96%B9%E6%B3%95%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%89%E4%B8%A4%E4%B8%AA">1. 横切逻辑的织入方法提供的有两个</a></li>
<li><a href="#2-%E6%B5%81%E7%A8%8B">2. 流程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-springaop的总体流程">一、SpringAOP的总体流程</h2>
<ul>
<li>注册解析AOP的服务</li>
<li>解析和加载横切逻辑</li>
<li>将横切逻辑织入目标Bean中</li>
</ul>
<h2 id="二-为什么在启动类加上enableaspectjautoproxy就能支持aop">二、为什么在启动类加上@EnableAspectJAutoProxy就能支持AOP</h2>
<p>注解有两个属性</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
   boolean proxyTargetClass() default false;   
   boolean exposeProxy() default false;
}
</code></pre>
<p><strong>proxyTargetClass</strong></p>
<ul>
<li>如果为true，则将全部使用CGLIb进行代理；如果为false，则会尽可能使用JDK的动态代理，如果对象没有实现接口，将会使用CGLIb</li>
</ul>
<p><strong>exposeProxy</strong></p>
<ul>
<li>
<p>决定是否可以将动态代理对象暴露出来</p>
</li>
<li>
<p>如果设置为true将会放入AopContext类的ThreadLocal属性中的中，这样就可以通过容器获取到该动态代理的对象</p>
</li>
</ul>
<p><strong>SpringAOP的流程</strong></p>
<ol>
<li>注册解析AOP的服务</li>
<li>解析和加载横切逻辑</li>
<li>将横切逻辑织入目标Bean中</li>
</ol>
<h3 id="三-如何注册解析aop的服务">三、如何注册解析AOP的服务？</h3>
<ul>
<li>主要依靠@Import(AspectJAutoProxyRegistrar.class)注解</li>
</ul>
<pre><code class="language-java">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

   
   @Override
   public void registerBeanDefinitions(
         AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
       //往容器注册一个AOP基于注解的自动代理创建器，负责动态代理的创建
      AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
		//注册注解的两个信息
      AnnotationAttributes enableAspectJAutoProxy =
            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
      if (enableAspectJAutoProxy != null) {
         if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
         }
         if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
         }
      }
   }

}
</code></pre>
<blockquote>
<p><strong>registerBeanDefinitions()方法有两个参数：</strong></p>
<ul>
<li>AnnotationMetadata：保存注解相关的信息</li>
<li>BeanDefinitionRegistry：往容器注册BeanDefinition</li>
</ul>
</blockquote>
<p><strong>该方法做的事情：</strong></p>
<ol>
<li>往容器注册一个AOP基于注解的自动代理创建器，负责动态代理的创建</li>
<li>根据注解属性，注册的相关配置</li>
</ol>
<p><strong>什么时候将配置注册到容器中？</strong></p>
<ul>
<li>在容器初始化执行Refresh方法的时候，通过容器级别的后置处理器注册的</li>
</ul>
<h2 id="四-横切逻辑加载分析">四、横切逻辑加载分析</h2>
<h3 id="1-targetsource接口">1. TargetSource接口</h3>
<ul>
<li>实现该接口，可以实现池化的操作，将存取代理类或者替换代理类</li>
</ul>
<p><strong>SingletonTargetSource</strong>：确保被代理的实例是单例的，定义了一个final的Object类，确保每次调用的都是同一个实例</p>
<pre><code class="language-java">private final Object target;
@Override
public Class&lt;?&gt; getTargetClass() {
	return this.target.getClass();
}
</code></pre>
<p><strong>ProtoTypeTargetSource</strong>：确保被代理的实例是多例的，每次调用时都会返回一个新的实例</p>
<pre><code class="language-java">@Override
public Object getTarget() throws BeansException {
   return newPrototypeInstance();
}
</code></pre>
<p><strong>其他的还有</strong></p>
<ul>
<li>提供池化的CommonsPool2TargetSource，类似于线程池</li>
<li>提供热交换的HotSwappableTargetSource，可以增删改查代理实例</li>
</ul>
<h3 id="2-buildaspectjadvisors方法">2. buildAspectJAdvisors方法</h3>
<ol>
<li>从容器中获取所有的beanName</li>
<li>遍历所有的beanName，解析出被@Aspect注解标记的类</li>
<li>提取Aspect类中的Advisors</li>
<li>将结果放入缓存</li>
</ol>
<pre><code class="language-java">public List&lt;Advisor&gt; buildAspectJAdvisors() {
	List&lt;String&gt; aspectNames = this.aspectBeanNames;

	if (aspectNames == null) {
		synchronized (this) {
			aspectNames = this.aspectBeanNames;
			if (aspectNames == null) {
				List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();
				//用于保存切面的名称的集合
				aspectNames = new ArrayList&lt;&gt;();
				//获取所有的beanName
				// AOP功能中在这里传入的是Object对象，代表去容器中获取到所有的组件的名称，然后再
				// 进行遍历，这个过程是十分的消耗性能的，所以说Spring会再这里加入了保存切面信息的缓存。
				String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
						this.beanFactory, Object.class, true, false);
				//遍历我们从IOC容器中获取处的所有Bean的名称
				for (String beanName : beanNames) {
					if (!isEligibleBean(beanName)) {
						continue;
					}
					//获取对应的bean的类型
					Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);
					if (beanType == null) {
						continue;
					}
					//提取@Aspect注解标记的Class
					if (this.advisorFactory.isAspect(beanType)) {
						//是切面类
						//加入到缓存中
						aspectNames.add(beanName);
						AspectMetadata amd = new AspectMetadata(beanType, beanName);
						if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
							MetadataAwareAspectInstanceFactory factory =
									new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
							//Aspect里面的advice和pointcut被拆分成一个个的advisor，
							// advisor里的advice和pointcut是1对1的关系
							List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
							if (this.beanFactory.isSingleton(beanName)) {
								//单例则直接将Advisor类存到缓存
								this.advisorsCache.put(beanName, classAdvisors);
							}
							else {
								// 否则将其对应的工厂缓存
								this.aspectFactoryCache.put(beanName, factory);
							}
							advisors.addAll(classAdvisors);
						}
						else {
							// Per target or per this.
							if (this.beanFactory.isSingleton(beanName)) {
								throw new IllegalArgumentException(&quot;Bean with name '&quot; + beanName +
										&quot;' is a singleton, but aspect instantiation model is not singleton&quot;);
							}
							MetadataAwareAspectInstanceFactory factory =
									new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
							this.aspectFactoryCache.put(beanName, factory);
							advisors.addAll(this.advisorFactory.getAdvisors(factory));
						}
					}
				}
				this.aspectBeanNames = aspectNames;
				return advisors;
			}
		}
	}

	if (aspectNames.isEmpty()) {
		return Collections.emptyList();
	}
	List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();
	for (String aspectName : aspectNames) {
		List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);
		if (cachedAdvisors != null) {
			advisors.addAll(cachedAdvisors);
		}
		else {
			MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
			advisors.addAll(this.advisorFactory.getAdvisors(factory));
		}
	}
	return advisors;
}
</code></pre>
<h2 id="五-横切逻辑织入">五、横切逻辑织入</h2>
<blockquote>
<p>在Bean完成初始化后，利用责任链模式进行横切逻辑的织入。</p>
</blockquote>
<h3 id="1-横切逻辑的织入方法提供的有两个">1. 横切逻辑的织入方法提供的有两个</h3>
<ul>
<li>第一个是正常流程的织入入口，通过后置处理器实现</li>
<li>第二个是循环依赖的织入入口，通过获取EarlyBeanReference实现</li>
</ul>
<h3 id="2-流程">2. 流程</h3>
<ul>
<li>
<p><strong>横切逻辑的织入前会进行一系列的判断</strong></p>
<ul>
<li>被织入的类名称不能是空</li>
<li>判断该类是否需要跳过织入或者是基础的类，比如实现了Advice、Pointcut等接口</li>
</ul>
</li>
<li>
<p><strong>获取合适的切面，利用AspectJ框架，进行类级别的初筛和方法级别的精确筛选，这些切面在容器创建的时候已经完成解析</strong></p>
<ul>
<li>初筛只能校验within的表达式，对于execution，只能检验精确到某个类的，表达式使用的包名加类名</li>
</ul>
</li>
<li>
<p><strong>创建Bean对应的代理，默认使用SingletonTargetSource用于封装实现类的信息，根据Bean是否实现了接口来决定使用JDK动态代理或者CGLib</strong></p>
</li>
<li>
<p><strong>将生成的动态代理，放入缓存中</strong></p>
</li>
</ul>
<pre><code class="language-java">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
		//已经被处理过
		if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) {
			return bean;
		}
		//不需要被织入逻辑的
		if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
			return bean;
		}
		//是不是基础的bean 是不是需要跳过的
		if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
			this.advisedBeans.put(cacheKey, Boolean.FALSE);
			return bean;
		}


		// 返回匹配当前Bean的所有Advice\Advisor\Interceptor
		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
		if (specificInterceptors != DO_NOT_PROXY) {
			this.advisedBeans.put(cacheKey, Boolean.TRUE);
			//创建Bean对应的代理，SingletonTargetSource用于封装实现类的信息
			Object proxy = createProxy(
					bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
			this.proxyTypes.put(cacheKey, proxy.getClass());
			return proxy;
		}
		//该Bean是不需要进行代理的，下次就不需要重复生成了
		this.advisedBeans.put(cacheKey, Boolean.FALSE);
		return bean;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】自定义SpringMVC]]></title>
        <id>https://xzzz2020.github.io/post/aAuoQMUUV/</id>
        <link href="https://xzzz2020.github.io/post/aAuoQMUUV/">
        </link>
        <updated>2020-09-10T12:13:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a>
<ul>
<li><a href="#1-springmvc%E7%9A%84%E5%BC%95%E5%87%BA">1. SpringMVC的引出</a></li>
<li><a href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89mvc%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD">2. 自定义MVC提供的功能</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%BB%BA%E7%AB%8B%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%99%A8">二、建立请求转发器</a>
<ul>
<li><a href="#1-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA">1. 请求的拦截</a></li>
<li><a href="#2-%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82">2. 责任链处理请求</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%99%A8">三、请求处理器</a>
<ul>
<li><a href="#1-%E8%AF%B7%E6%B1%82%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">1. 请求预处理器</a></li>
<li><a href="#2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E5%99%A8">2. 静态资源处理器</a></li>
<li><a href="#3-jsp%E5%A4%84%E7%90%86%E5%99%A8">3. JSP处理器</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-controller%E5%A4%84%E7%90%86%E5%99%A8">四、Controller处理器</a>
<ul>
<li><a href="#1-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E5%92%8C%E9%85%8D%E7%BD%AE%E7%B1%BB">1. 相关注解和配置类</a></li>
<li><a href="#2-controllerrequestprocessor">2. ControllerRequestProcessor</a></li>
<li><a href="#3-%E5%BB%BA%E7%AB%8Bcontroller%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">3. 建立Controller方法与请求的映射关系</a></li>
<li><a href="#4-%E7%BB%99%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC">4. 给需要执行的方法参数赋值</a></li>
<li><a href="#5-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E6%89%A7%E8%A1%8C%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C">5. 利用反射执行获取执行的结果</a></li>
<li><a href="#6-%E6%A0%B9%E6%8D%AE%E7%BB%93%E6%9E%9C%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">6. 根据结果设置结果渲染器</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">五、处理结果渲染器</a>
<ul>
<li><a href="#1-%E9%BB%98%E8%AE%A4%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">1. 默认结果渲染器</a></li>
<li><a href="#2-%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">2. 异常结果渲染器</a></li>
<li><a href="#3-%E6%89%BE%E4%B8%8D%E5%88%B0%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93%E5%99%A8">3. 找不到路径渲染器</a></li>
<li><a href="#4-json%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93%E5%99%A8">4. Json结果渲染器</a></li>
<li><a href="#5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">5. 视图解析器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<h3 id="1-springmvc的引出">1. SpringMVC的引出</h3>
<ul>
<li>
<p>最开始都是用的Servlet</p>
</li>
<li>
<p>如果一个Servlet对应一个类，比如说商品类，但是如果我们除了需要查询产品还查询了订单，就需要访问两个Servlet</p>
</li>
<li>
<p>如果一个Servlet对应一个页面，比如说商品页，随着页面的增多，Servlet也会越来越多，同时如果一个页面有多个get请求，将无法处理</p>
</li>
</ul>
<p><strong>参照SpringMVC，仅通过DispatcherServlet进行请求派发这样可以让系统模块更加明确，该类的任务有</strong>：</p>
<ul>
<li>拦截全部请求</li>
<li>解析请求</li>
<li>派发给对应的Controller里面进行处理</li>
</ul>
<p><strong>通过下面的注解可以拦截到全部请求</strong></p>
<pre><code class="language-java">@WebServlet(&quot;/&quot;)
</code></pre>
<p><strong>下面的会对jsp请求也会进行拦截，如果我们在页面中转发到jsp，就会依然被拦截到这个类里</strong></p>
<pre><code class="language-java">@WebServlet(&quot;/*&quot;)
</code></pre>
<p>原因在tomcat的web.xml中，反斜杠是Servlet中特殊的匹配模式，优先级最低，比*.jsp优先级低，但是反斜杠星号属于路径匹配，优先级比*.jsp高</p>
<pre><code class="language-xml">&lt;!-- The mapping for the default servlet --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;default&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

 &lt;!-- The mappings for the JSP servlet --&gt;    
 &lt;servlet-mapping&gt;                                      
     &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;          
     &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;              
     &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;            
 &lt;/servlet-mapping&gt;                                     
</code></pre>
<h3 id="2-自定义mvc提供的功能">2. 自定义MVC提供的功能</h3>
<ul>
<li>
<p>对所有的请求结果进行转发，利用责任链模式处理对应的请求</p>
</li>
<li>
<p>进行编码相关的预处理</p>
</li>
<li>
<p>支持<strong>静态资源、JSP以及Controller</strong>的请求处理，<strong>需要被转发的Controller需要在类和方法上都加入@RequestMapping注解，目前只提供Get和Post两种请求方法</strong></p>
</li>
<li>
<p>提供<strong>基本类型</strong>的参数转换，将请求的参数赋值在方法上，但是<strong>要求每个参数都需要加上@RequestParam注解</strong></p>
</li>
<li>
<p><strong>如果方法上有@ResponseBody注解，将提供Json的视图渲染</strong></p>
</li>
<li>
<p><strong>如果方法上没有提供@ResponseBody注解，将提供ModelAndView的页面渲染，返回值可以是ModelAndView，或者String类型，渲染到JSP页面</strong></p>
</li>
</ul>
<h2 id="二-建立请求转发器">二、建立请求转发器</h2>
<h3 id="1-请求的拦截">1. 请求的拦截</h3>
<p><strong>建立DispatcherServlet</strong></p>
<ul>
<li>初始化容器</li>
<li>初始化请求处理器责任链</li>
<li>通过责任链模式来依次调用请求处理器对请求进行处理</li>
<li>对处理结果进行渲染</li>
</ul>
<pre><code class="language-java">/**
 * 1.完成框架的初始化
 * 2.对请求进行分发
 * 3.对结果进行渲染
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:05
 */
@WebServlet(&quot;/*&quot;)
public class DispatcherServlet extends HttpServlet {
    //处理器列表
    private List&lt;RequestProcessor&gt; Processor = new ArrayList&lt;&gt;();

    @Override
    public void init(){
        //1.初始化容器
        BeanContainer beanContainer = BeanContainer.getInstance();
        beanContainer.loadBeans(&quot;com.imooc&quot;);
        new AspectWeaver().doAop();
        new DependencyInjector().doIoc();
        //2.初始化请求处理器责任链
        Processor.add(new PreRequestProcessor());
        Processor.add(new StaticResourceRequestProcessor(getServletContext()));
        Processor.add(new JspRequestProcessor(getServletContext()));
        Processor.add(new ControllerRequestProcessor());
    }
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) {
        //1.创建责任链对象实例
        RequestProcessorChain requestProcessorChain = new RequestProcessorChain(Processor.iterator(), req, resp);
        //2.通过责任链模式来依次调用请求处理器对请求进行处理
        requestProcessorChain.doRequestProcessorChain();
        //3.对处理结果进行渲染
        requestProcessorChain.doRender();
    }
}
</code></pre>
<h3 id="2-责任链处理请求">2. 责任链处理请求</h3>
<pre><code class="language-java">/**
 * 责任链处理实例
 * 1.以责任链的模式执行注册的请求处理器
 * 2.委派给特定的Render实例对处理的结果进行渲染
 *
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:05
 */
@Data
@Slf4j
public class RequestProcessorChain {

    //请求处理器迭代器
    private final Iterator&lt;RequestProcessor&gt; requestProcessorIterator;
    //请求Request
    private final HttpServletRequest request;
    //请求Response
    private final HttpServletResponse response;
    //http请求方法
    private String requestMethod;
    //http请求路径
    private String requestPath;
    //请求状态码
    private int responseCode;
    //请求结果渲染器
    private ResultRender resultRender;

    public RequestProcessorChain(Iterator&lt;RequestProcessor&gt; requestProcessorIterator, HttpServletRequest req, HttpServletResponse resp) {
        this.requestProcessorIterator = requestProcessorIterator;
        this.request = req;
        this.response = resp;
        this.requestMethod = req.getMethod();
        this.requestPath = req.getPathInfo();
        this.responseCode = HttpServletResponse.SC_OK;
    }

    /**
     * 以责任链的模式处理请求
     */
    public void doRequestProcessorChain() {
        //1.通过迭代器遍历注册的请求处理器实现类列表
        try {
            while (requestProcessorIterator.hasNext()) {
                //2.直到某个请求处理器执行后返回为false为止
                RequestProcessor requestProcessor = requestProcessorIterator.next();
                boolean processStatue = requestProcessor.process(this);
                if (!processStatue) {
                    break;
                }
            }
        } catch (Exception e) {
            //3.期间如果出现异常，则交由内部异常渲染器处理
            this.resultRender = new InternalErrorResultRender();
            log.error(&quot;doRequestProcessorChain error:&quot;, e);
        }

    }

    /**
     * 结果渲染器
     */
    public void doRender() {
        //1.如果请求处理器实现类均未选择合适的渲染器，则使用默认的
        if (this.resultRender == null) {
            this.resultRender = new DefaultResultRender();
        }
        try {
            //2.调用渲染器的render方法对结果进行渲染
            resultRender.render(this);
        } catch (Exception e) {
            log.error(&quot;doRender error:&quot;, e);
            throw new RuntimeException(e);
        }
    }
}
</code></pre>
<h2 id="三-请求处理器">三、请求处理器</h2>
<blockquote>
<p>采用责任链模式，如果没有被当前处理器处理，则交给下一个处理器处理，直到有处理器处理成功</p>
</blockquote>
<h3 id="1-请求预处理器">1. 请求预处理器</h3>
<pre><code class="language-java">/**
 * 请求预处理，包括进行统一的UTF-8编码以及路径处理
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:06
 */
@Slf4j
public class PreRequestProcessor implements RequestProcessor {
    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        // 1.设置请求编码，将其统一设置成UTF-8
        requestProcessorChain.getRequest().setCharacterEncoding(&quot;UTF-8&quot;);
        // 2.将请求路径末尾的/剔除，为后续匹配Controller请求路径做准备
        // （一般Controller的处理路径是/aaa/bbb，所以如果传入的路径结尾是/aaa/bbb/，
        // 就需要处理成/aaa/bbb）
        String requestPath = requestProcessorChain.getRequestPath();
        //http://localhost:8080/simpleframework requestPath=&quot;/&quot;
        if(requestPath.length() &gt; 1 &amp;&amp; requestPath.endsWith(&quot;/&quot;)){
            requestProcessorChain.setRequestPath(requestPath.substring(0, requestPath.length() - 1));
        }
        log.info(&quot;preprocess request {} {}&quot;, requestProcessorChain.getRequestMethod(), requestProcessorChain.getRequestPath());
        return true;
    }
}
</code></pre>
<h3 id="2-静态资源处理器">2. 静态资源处理器</h3>
<blockquote>
<p>利用的tomcat默认请求派发器RequestDispatcher处理</p>
</blockquote>
<pre><code class="language-java">/**
 * 静态资源请求的处理，包括但不限于图片、css、以及js文件等
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:08
 */
@Slf4j
public class StaticResourceRequestProcessor implements RequestProcessor {
    public static final String DEFAULT_TOMCAT_SERVLET = &quot;default&quot;;
    public static final String STATIC_RESOURCE_PREFIX = &quot;/static/&quot;;
    //tomcat默认请求派发器RequestDispatcher的名称
    RequestDispatcher defaultDispatcher;

    public StaticResourceRequestProcessor(ServletContext servletContext) {
        this.defaultDispatcher = servletContext.getNamedDispatcher(DEFAULT_TOMCAT_SERVLET);
        if(this.defaultDispatcher == null){
            throw new RuntimeException(&quot;There is no default tomcat servlet&quot;);
        }
        log.info(&quot;The default servlet for static resource is {}&quot;, DEFAULT_TOMCAT_SERVLET);
    }

    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        //1.通过请求路径判断是否是请求的静态资源 webapp/static
        if(isStaticResource(requestProcessorChain.getRequestPath())){
            //2.如果是静态资源，则将请求转发给default servlet处理
            defaultDispatcher.forward(requestProcessorChain.getRequest(), requestProcessorChain.getResponse());
            return false;
        }
        return true;
    }
    //通过请求路径前缀（目录）是否为静态资源 /static/
    private boolean isStaticResource(String path){
        return path.startsWith(STATIC_RESOURCE_PREFIX);
    }
}
</code></pre>
<h3 id="3-jsp处理器">3. JSP处理器</h3>
<blockquote>
<p>利用的tomcat的jspServlet处理</p>
</blockquote>
<pre><code class="language-java">/**
 * jsp资源请求处理
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:08
 */
public class JspRequestProcessor implements RequestProcessor {

    //jsp请求的RequestDispatcher的名称
    private static final String JSP_SERVLET = &quot;jsp&quot;;
    //Jsp请求资源路径前缀
    private static final String  JSP_RESOURCE_PREFIX = &quot;/templates/&quot;;

    /**
     * jsp的RequestDispatcher,处理jsp资源
     */
    private RequestDispatcher jspServlet;

    public JspRequestProcessor(ServletContext servletContext) {
        jspServlet = servletContext.getNamedDispatcher(JSP_SERVLET);
        if (null == jspServlet) {
            throw new RuntimeException(&quot;there is no jsp servlet&quot;);
        }
    }

    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        if (isJspResource(requestProcessorChain.getRequestPath())) {
            jspServlet.forward(requestProcessorChain.getRequest(), requestProcessorChain.getResponse());
            return false;
        }
        return true;
    }

    /**
     * 是否请求的是jsp资源
     */
    private boolean isJspResource(String url) {
        return url.startsWith(JSP_RESOURCE_PREFIX);
    }

}
</code></pre>
<h2 id="四-controller处理器">四、Controller处理器</h2>
<h3 id="1-相关注解和配置类">1. 相关注解和配置类</h3>
<h3 id="2-controllerrequestprocessor">2. ControllerRequestProcessor</h3>
<p><strong>功能</strong>：</p>
<ul>
<li>针对特定请求，选择匹配的Controllerf方法进行处理</li>
<li>解析出请求里的参数及其对应的值，并赋值给Controller方法的参数</li>
<li>选择合适的Render，为后续请求处理结果的渲染做准备</li>
</ul>
<h3 id="3-建立controller方法与请求的映射关系">3. 建立Controller方法与请求的映射关系</h3>
<blockquote>
<p>请求中包含的信息有路径和请求参数，所以需要根据这些信息找到对应的Controller方法</p>
</blockquote>
<p><strong>存储请求的信息</strong></p>
<pre><code class="language-java">/**
 * 存储http请求路径和请求方法
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/5 16:45
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class RequestPathInfo {
    //http请求方法
    private String httpMethod;
    //http请求路径
    private String httpPath;

}
</code></pre>
<p><strong>存储Controller以及方法的信息</strong></p>
<pre><code class="language-java">/**
 * 封装待执行的Controller及其方法实例和参数的映射
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/5 16:40
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ControllerMethod {
    //Controller对应的Class对象
    private Class&lt;?&gt; controllerClass;
    //执行的Controller方法实例
    private Method invokeMethod;
    //方法参数名称以及对应的参数类型
    private Map&lt;String,Class&lt;?&gt;&gt; methodParameters;
}
</code></pre>
<p><strong>建立的映射关系就是RequestPathInfo与ControllerMethod的，这样就可以根据请求定位到对应的方法</strong></p>
<pre><code class="language-java">private Map&lt;RequestPathInfo, ControllerMethod&gt; pathControllerMethodMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<h3 id="4-给需要执行的方法参数赋值">4. 给需要执行的方法参数赋值</h3>
<pre><code class="language-java">/**
 * 给方法赋值的工具类
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/7 16:10
 */
public class ConverterUtil {
    /**
     * 返回基本数据类型的空值
     *需要特殊处理的基本类型即int\double\short\long\byte\float\boolean
     * @param type 参数类型
     * @return 对应的空值
     */
    public static Object primitiveNull(Class&lt;?&gt; type) {
        if (type == int.class || type == double.class ||
                type == short.class || type == long.class ||
                type == byte.class || type == float.class) {
            return 0;
        } else if(type == boolean.class){
            return false;
        }
        return null;
    }
    /**
     * String类型转换成对应的参数类型
     *
     * @param type  参数类型
     * @param requestValue 值
     * @return 转换后的Object
     */
    public static Object convert(Class&lt;?&gt; type, String requestValue) {
        if(isPrimitive(type)){
            if(ValidationUtil.isEmpty(requestValue)){
                return primitiveNull(type);
            }
            if (type.equals(int.class) || type.equals(Integer.class)) {
                return Integer.parseInt(requestValue);
            } else if (type.equals(String.class)) {
                return requestValue;
            } else if (type.equals(Double.class) || type.equals(double.class)) {
                return Double.parseDouble(requestValue);
            } else if (type.equals(Float.class) || type.equals(float.class)) {
                return Float.parseFloat(requestValue);
            } else if (type.equals(Long.class) || type.equals(long.class)) {
                return Long.parseLong(requestValue);
            } else if (type.equals(Boolean.class) || type.equals(boolean.class)) {
                return Boolean.parseBoolean(requestValue);
            } else if (type.equals(Short.class) || type.equals(short.class)) {
                return Short.parseShort(requestValue);
            } else if (type.equals(Byte.class) || type.equals(byte.class)) {
                return Byte.parseByte(requestValue);
            }
            return requestValue;
        } else {
            throw new RuntimeException(&quot;count not support non primitive type conversion yet&quot;);
        }
    }

    /**
     * 判定是否基本数据类型(包括包装类以及String)
     *
     * @param type 参数类型
     * @return 是否为基本数据类型
     */
    private static boolean isPrimitive(Class&lt;?&gt; type) {
        return type == boolean.class
                || type == Boolean.class
                || type == double.class
                || type == Double.class
                || type == float.class
                || type == Float.class
                || type == short.class
                || type == Short.class
                || type == int.class
                || type == Integer.class
                || type == long.class
                || type == Long.class
                || type == String.class
                || type == byte.class
                || type == Byte.class
                || type == char.class
                || type == Character.class;
    }
}
</code></pre>
<h3 id="5-利用反射执行获取执行的结果">5. 利用反射执行获取执行的结果</h3>
<pre><code class="language-java">Object controller = beanContainer.getBean(controllerMethod.getControllerClass());
Method invokeMethod = controllerMethod.getInvokeMethod();
invokeMethod.setAccessible(true);
Object result;
try {
    if (methodParam.size()==0){
        result = invokeMethod.invoke(controller);
    }else {
        result = invokeMethod.invoke(controller,methodParam.toArray());
    }
} catch (IllegalAccessException e) {
    throw new RuntimeException(e);
} catch (InvocationTargetException e) {
    //如果是调用异常的话，需要通过e.getTargetException()
    // 去获取执行方法抛出的异常
    throw new RuntimeException(e.getTargetException());
}
</code></pre>
<h3 id="6-根据结果设置结果渲染器">6. 根据结果设置结果渲染器</h3>
<pre><code class="language-java">ResultRender resultRender;
boolean isJson = controllerMethod.getInvokeMethod().isAnnotationPresent(ResponseBody.class);
if (isJson){
    resultRender = new JsonResultRender(result);
}else {
    resultRender = new ViewResultRender(result);
}
requestProcessorChain.setResultRender(resultRender);
</code></pre>
<p><strong>完整代码如下</strong>：</p>
<pre><code class="language-java">/**
 * 将请求转发给对应的Controller进行处理
 *
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:10
 */
@Slf4j
public class ControllerRequestProcessor implements RequestProcessor {
    //IOC容器
    private BeanContainer beanContainer;
    //请求和Controller的映射
    private Map&lt;RequestPathInfo, ControllerMethod&gt; pathControllerMethodMap = new ConcurrentHashMap&lt;&gt;();

    /**
     * 依靠容器，建立起请求路径、请求方法与Controller方法实例的映射
     */
    public ControllerRequestProcessor() {
        this.beanContainer = BeanContainer.getInstance();
        // 获取被@RequestMapping标记的Controller类
        Set&lt;Class&lt;?&gt;&gt; requestMappingSet = beanContainer.getClassesByAnnotation(RequestMapping.class);
        // 建立映射
        initPathControllerMethodMap(requestMappingSet);
    }

    /**
     * 建立起请求路径、请求方法与Controller方法实例的映射
     *
     * @param requestMappingSet 需要被转发的Controller
     */
    private void initPathControllerMethodMap(Set&lt;Class&lt;?&gt;&gt; requestMappingSet) {
        if (ValidationUtil.isEmpty(requestMappingSet)) {//如果没有类被@RequestMapping标记
            return;
        }
        //1.遍历所有被@RequestMapping标记的类，获取类上面该注解的属性值作为一级路径
        for (Class&lt;?&gt; requestMappingClass : requestMappingSet) {
            //获取@RequestMapping注解
            RequestMapping requestMapping = requestMappingClass.getAnnotation(RequestMapping.class);
            //获取注解值
            String basePath = requestMapping.value();
            if (!basePath.startsWith(&quot;/&quot;)) {//如果不是以“/”开头，为了方便处理，加上“/”
                basePath = &quot;/&quot; + basePath;
            }
            //2.遍历类里所有被@RequestMapping标记的方法，获取方法上面该注解的属性值，作为二级路径
            Method[] methods = requestMappingClass.getDeclaredMethods();
            if (ValidationUtil.isEmpty(methods)) {
                continue;
            }
            for (Method method : methods) {
                if (method.isAnnotationPresent(RequestMapping.class)) {//获取方法被@RequestMapping标记的
                    //获取@RequestMapping注解
                    RequestMapping methodRequest = method.getAnnotation(RequestMapping.class);
                    //获取注解值
                    String methodPath = methodRequest.value();
                    if (!methodPath.startsWith(&quot;/&quot;)) {//如果不是以“/”开头，为了方便处理，加上“/”
                        methodPath = &quot;/&quot; + methodPath;
                    }
                    //拼接一级和二级路径路径
                    String url = basePath + methodPath;
                    //3.解析方法里被@RequestParam标记的参数，
                    // 获取该注解的属性值，作为参数名，
                    // 获取被标记的参数的数据类型，建立参数名和参数类型的映射
                    Map&lt;String, Class&lt;?&gt;&gt; methodParams = new HashMap&lt;&gt;();
                    //获取方法的参数
                    Parameter[] parameters = method.getParameters();
                    if (!ValidationUtil.isEmpty(parameters)) {
                        for (Parameter parameter : parameters) {
                            //获取方法参数上的注解属性
                            RequestParam requestParam = parameter.getAnnotation(RequestParam.class);
                            //目前暂定为Controller方法里面所有的参数都需要@RequestParam注解
                            if (requestParam == null) {//如果方法参数没有注解，则暂时报错
                                throw new RuntimeException(&quot;The parameter must have @RequestParam&quot;);
                            }
                            methodParams.put(requestParam.value(), parameter.getType());
                        }
                    }
                    //4.将获取到的信息封装成RequestPathInfo实例和ControllerMethod实例，放置到映射表里
                    String httpMethod = String.valueOf(methodRequest.method());//获取注解中所要求的请求方法
                    RequestPathInfo requestPathInfo = new RequestPathInfo(httpMethod, url);
                    //如果出现了重复的路径
                    if (this.pathControllerMethodMap.containsKey(requestPathInfo)) {
                        log.warn(&quot;duplicate url:{} registration，current class {} method{} will override the former one&quot;,
                                requestPathInfo.getHttpPath(), requestMappingClass.getName(), method.getName());
                    }
                    ControllerMethod controllerMethod = new ControllerMethod(requestMappingClass, method, methodParams);
                    this.pathControllerMethodMap.put(requestPathInfo, controllerMethod);
                }
            }
        }


    }

    /**
     * 处理请求
     *
     * @param requestProcessorChain 责任链
     * @return 返回一定成功
     * @throws Exception 处理出错会抛出异常
     */
    @Override
    public boolean process(RequestProcessorChain requestProcessorChain) throws Exception {
        //1.解析HttpServletRequest的请求方法,请求路径，获取对应的ControllerMethod实例
        String method = requestProcessorChain.getRequestMethod();//获取请求的方法类型
        String path = requestProcessorChain.getRequestPath();//获取请求路径
        ControllerMethod controllerMethod = this.pathControllerMethodMap.get(new RequestPathInfo(method, path));//查找对应的路径和方法
        if (controllerMethod == null) {//找不到请求路径
            requestProcessorChain.setResultRender(new ResourceNotFoundResultRender(method, path));
            return false;
        }
        //2.解析请求参数，并传递给获取到的ControllerMethod实例去执行
        Object result = invokeControllerMethod(controllerMethod, requestProcessorChain.getRequest());
        //3.根据处理的结果，选择对应的render进行渲染
        setResultRender(result, controllerMethod, requestProcessorChain);
        return false;
    }

    /**
     * 根据处理的结果，选择对应的render进行渲染
     *
     * @param result                处理的结果
     * @param controllerMethod      执行的Controller及其方法
     * @param requestProcessorChain 请求处理链
     */
    private void setResultRender(Object result, ControllerMethod controllerMethod, RequestProcessorChain requestProcessorChain) {
        if (result == null) {
            return;
        }
        ResultRender resultRender;
        boolean isJson = controllerMethod.getInvokeMethod().isAnnotationPresent(ResponseBody.class);
        if (isJson) {
            resultRender = new JsonResultRender(result);
        } else {
            resultRender = new ViewResultRender(result);
        }
        requestProcessorChain.setResultRender(resultRender);
    }

    /**
     * 解析请求参数，并传递给获取到的ControllerMethod实例去执行
     *
     * @param controllerMethod 需要执行的Controller配置
     * @param request          http请求
     * @return 处理的结果
     */
    private Object invokeControllerMethod(ControllerMethod controllerMethod, HttpServletRequest request) {
        //1.从请求里获取GET或者POST的参数名及其对应的值
        Map&lt;String, String&gt; requestParamMap = new HashMap&lt;&gt;();
        //GET，POST方法的请求参数获取方式
        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
        for (Map.Entry&lt;String, String[]&gt; parameter : parameterMap.entrySet()) {
            if (ValidationUtil.isEmpty(parameter.getValue())) {
                //只支持一个参数对应一个值的形式
                requestParamMap.put(parameter.getKey(), parameter.getValue()[0]);
            }
        }
        //2.根据获取到的请求参数名及其对应的值，以及controllerMethod里面的参数和类型的映射关系，去实例化出方法对应的参数
        List&lt;Object&gt; methodParam = new ArrayList&lt;&gt;();
        Map&lt;String, Class&lt;?&gt;&gt; methodParameterMap = controllerMethod.getMethodParameters();
        for (String paramName : methodParameterMap.keySet()) {
            Class&lt;?&gt; type = methodParameterMap.get(paramName);
            String requestValue = requestParamMap.get(paramName);
            Object value;
            //只支持String 以及基础类型char,int,short,byte,double,long,float,boolean,及它们的包装类型
            if (requestValue == null) {
                //将请求里的参数值转成适配于参数类型的空值
                value = ConverterUtil.primitiveNull(type);
            } else {
                value = ConverterUtil.convert(type, requestValue);
            }
            methodParam.add(value);
        }
        //3.执行Controller里面对应的方法并返回结果
        Object controller = beanContainer.getBean(controllerMethod.getControllerClass());
        Method invokeMethod = controllerMethod.getInvokeMethod();
        invokeMethod.setAccessible(true);
        Object result;
        try {
            if (methodParam.size() == 0) {
                result = invokeMethod.invoke(controller);
            } else {
                result = invokeMethod.invoke(controller, methodParam.toArray());
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            //如果是调用异常的话，需要通过e.getTargetException()
            // 去获取执行方法抛出的异常
            throw new RuntimeException(e.getTargetException());
        }
        return result;
    }


}
</code></pre>
<h2 id="五-处理结果渲染器">五、处理结果渲染器</h2>
<h3 id="1-默认结果渲染器">1. 默认结果渲染器</h3>
<blockquote>
<p>如果请求处理器实现类均未选择合适的渲染器，则使用默认的结果渲染器</p>
</blockquote>
<pre><code class="language-java">if (this.resultRender == null) {
    this.resultRender = new DefaultResultRender();
}
</code></pre>
<p><strong>主要将处理的结果状态码返回，默认为200</strong></p>
<pre><code class="language-java">/**
 * 默认渲染器，只会返回状态码
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:28
 */
public class DefaultResultRender implements ResultRender {
    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        //将相应状态码设置到response中
        requestProcessorChain.getResponse().setStatus(requestProcessorChain.getResponseCode());
    }
}

</code></pre>
<h3 id="2-异常结果渲染器">2. 异常结果渲染器</h3>
<blockquote>
<p>以责任链的模式处理请求，期间如果出现异常，则交由内部异常渲染器处理</p>
</blockquote>
<pre><code class="language-java">/**
 * 以责任链的模式处理请求
 */
public void doRequestProcessorChain() {
    //1.通过迭代器遍历注册的请求处理器实现类列表
    try {
        while (requestProcessorIterator.hasNext()) {
            //2.直到某个请求处理器执行后返回为false为止
            RequestProcessor requestProcessor = requestProcessorIterator.next();
            boolean processStatue = requestProcessor.process(this);
            if (!processStatue) {
                break;
            }
        }
    } catch (Exception e) {
        //3.期间如果出现异常，则交由内部异常渲染器处理
        this.resultRender = new InternalErrorResultRender(e.getMessage());
        log.error(&quot;doRequestProcessorChain error:&quot;, e);
    }

}
</code></pre>
<p><strong>设置状态码500和异常信息</strong></p>
<pre><code class="language-java">/**
 * 处理在请求中出现的异常
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:31
 */
public class InternalErrorResultRender implements ResultRender {

    private String errorMsg;

    public InternalErrorResultRender(String errorMsg){
        this.errorMsg = errorMsg;
    }

    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        HttpServletResponse response = requestProcessorChain.getResponse();
        //设置状态码500和错误信息
        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,errorMsg);
    }
}
</code></pre>
<h3 id="3-找不到路径渲染器">3. 找不到路径渲染器</h3>
<blockquote>
<p>在根据请求路径转发到Controller时，找不到对应的对象或者方法，则使用该渲染器</p>
</blockquote>
<p><strong>返回404和请求的路径及方法</strong></p>
<pre><code class="language-java">/**
 * 渲染找不到资源结果的渲染器
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:32
 */
public class ResourceNotFoundResultRender implements ResultRender {

    private String httpMethod;
    private String httpPath;

    public ResourceNotFoundResultRender(String httpMethod, String httpPath) {
        this.httpMethod = httpMethod;
        this.httpPath = httpPath;
    }

    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        requestProcessorChain.getResponse().sendError(HttpServletResponse.SC_NOT_FOUND,
                &quot;获取不到对应的请求资源：请求路径[&quot; + httpPath + &quot;]&quot; + &quot;请求方法[&quot; + httpMethod + &quot;]&quot;);
    }
}
</code></pre>
<h3 id="4-json结果渲染器">4. Json结果渲染器</h3>
<blockquote>
<p>当方法上面使用@ResponseBody注解时，利用Gson将结果转换成Json数据返回</p>
</blockquote>
<pre><code class="language-java">/**
 * 将结果返回成Json数据
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:29
 */
public class JsonResultRender implements ResultRender {
    private Object jsonData;
    public JsonResultRender(Object jsonData) {
        this.jsonData = jsonData;
    }

    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        //设置响应头
        requestProcessorChain.getResponse().setContentType(&quot;application/json&quot;);
        requestProcessorChain.getResponse().setCharacterEncoding(&quot;UTF-8&quot;);
        //响应流写入经过Gson格式化的处理结果
        PrintWriter writer = requestProcessorChain.getResponse().getWriter();
        Gson gson = new Gson();
        String str = gson.toJson(jsonData);
        writer.write(str);
        writer.flush();
    }
}
</code></pre>
<h3 id="5-视图解析器">5. 视图解析器</h3>
<blockquote>
<p>当方法上面没用使用@ResponseBody注解时，将使用视图解析器</p>
</blockquote>
<p><strong>模仿Spring MVC 定义一个视图ModelAndView</strong></p>
<pre><code class="language-java">/**
 * 存储请求结果，以及显示该数据的视图
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/7 18:02
 */

public class ModelAndView {
    //页面所在的路径
    @Getter
    private String view;
    //页面的数据
    @Getter
    private Map&lt;String ,Object&gt; model = new HashMap&lt;&gt;();

    public ModelAndView setView(String view) {
        this.view = view;
        return this;
    }
    //这样可以使用一连串的设置
    //modelAndView.setView(&quot;addheadline.jsp&quot;).addViewData(&quot;aaa&quot;, &quot;bbb&quot;);
    public ModelAndView addViewData(String attributeName, Object attributeValue){
        model.put(attributeName,attributeValue);
        return this;
    }
}
</code></pre>
<p><strong>视图解析器则根据返回结果的不同，而进行跳转</strong></p>
<ul>
<li>如果是String数据，则创建一个ModelAndView对象，并将数据加入到视图地址</li>
<li>如果是ModelAndView，则会解析其中的视图地址和数据</li>
</ul>
<pre><code class="language-java">/**
 * 渲染页面，比如ModelAndView类型
 * @author xzzz2020
 * @version 1.0
 * @date 2020/9/4 16:29
 */
public class ViewResultRender implements ResultRender {
    public static final String VIEW_PATH = &quot;/templates/&quot;;

    private ModelAndView modelAndView;
    /**
     * 对传入的参数进行处理，并赋值给ModelAndView成员变量
     * @param mv
     */
    public ViewResultRender(Object mv) {
        if(mv instanceof ModelAndView){
            //1.如果入参类型是ModelAndView，则直接赋值给成员变量
            this.modelAndView = (ModelAndView)mv;
        } else if(mv instanceof  String){
            //2.如果入参类型是String，则为视图，需要包装后才赋值给成员变量
            this.modelAndView = new ModelAndView().setView((String)mv);
        } else {
            //3.针对其他情况，则直接抛出异常
            throw new RuntimeException(&quot;illegal request result type&quot;);
        }
    }

    /**
     * 将请求处理结果按照视图路径转发至对应视图进行展示
     * @param requestProcessorChain
     * @throws Exception
     */
    @Override
    public void render(RequestProcessorChain requestProcessorChain) throws Exception {
        HttpServletRequest request = requestProcessorChain.getRequest();
        HttpServletResponse response = requestProcessorChain.getResponse();
        //视图路径
        String path = modelAndView.getView();
        Map&lt;String, Object&gt; model = modelAndView.getModel();
        for(Map.Entry&lt;String, Object&gt; entry : model.entrySet()){
            request.setAttribute(entry.getKey(), entry.getValue());
        }
        //JSP
        request.getRequestDispatcher(VIEW_PATH +path).forward(request, response);

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】自定义SpringIOC]]></title>
        <id>https://xzzz2020.github.io/post/axgzRz0gg/</id>
        <link href="https://xzzz2020.github.io/post/axgzRz0gg/">
        </link>
        <updated>2020-09-10T12:11:26.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%89%8B%E5%86%99springioc%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B">一、手写SpringIOC容器简介</a></li>
<li><a href="#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E6%B3%A8%E8%A7%A3">二、创建注解</a></li>
<li><a href="#%E4%B8%89-%E6%8F%90%E5%8F%96%E6%A0%87%E8%AE%B0%E5%AF%B9%E8%B1%A1">三、提取标记对象</a>
<ul>
<li><a href="#1-%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%8A%A0%E8%BD%BD">1. 指定范围加载</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%AE%9E%E7%8E%B0ioc%E5%AE%B9%E5%99%A8">四、实现IOC容器</a>
<ul>
<li><a href="#1-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%8D%95%E4%BE%8B">1. 枚举的单例</a></li>
<li><a href="#2-%E4%BF%9D%E5%AD%98class%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%BD%BD%E4%BD%93">2. 保存Class对象及其实例的载体</a></li>
<li><a href="#3-%E5%AE%B9%E5%99%A8%E5%8A%A0%E8%BD%BD">3. 容器加载</a></li>
<li><a href="#4-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">4. 容器的操作（增删改查）</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">五、依赖注入</a>
<ul>
<li><a href="#1-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E8%A7%A3">1. 依赖注入的注解</a></li>
<li><a href="#2-%E5%AF%B9%E6%9C%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">2. 对有注解的属性进行依赖注入</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-手写springioc容器简介">一、手写SpringIOC容器简介</h2>
<p><strong>已经实现的功能有</strong>：</p>
<ol>
<li><strong>提供注解@Service、@Component、@Controller、@Repositor，标记需要加载到IOC容器管理的类</strong></li>
<li>提供了一个ClassUtil工具类，<strong>支持加载指定包下及其子包所有.class文件</strong>，支持注入属性，支持通过反射class加载实例化对象（<strong>仅支持默认构造</strong>）</li>
<li>提供IOC容器BeanContainer，支持通过ClassUtil工具类，加载被注解标记的类，目前<strong>仅支持单例模式以及非懒加载的方式</strong></li>
<li><strong>提供IOC容器增产改的方法，获取IOC的Bean的方式有：通过class直接加载；获取某一个标记的注解所有class集合；获取全部的class集合；获取父类或者接口的实现类结合Class</strong></li>
<li><strong>提供依赖注入的注解@Autowired，仅支持注入到属性上，该注解提供一个value，用户可以指定获取具体的接口实现类的名称</strong></li>
<li>提供完成所有标记在IOC容器中对象属性依赖注入的类DependencyInjector，将扫描@Autowired，根据用户定义的注解value或者默认值注入到属性中</li>
</ol>
<blockquote>
<p>使用BeanContainer的loadBeans方法，指定框架需要管理的包路径，将相关类加入到IOC容器中，再利用DependencyInjector的doIoc方法实现属性的依赖注入。</p>
</blockquote>
<p><strong>实现的思路为</strong>：</p>
<ol>
<li>创建注解</li>
<li>提取标记对象</li>
<li>实现容器</li>
<li>依赖注入</li>
</ol>
<p><strong>提取标记对象</strong></p>
<ol>
<li>指定范围，获取范围内全部的类</li>
<li>遍历所有类，获取被注解标记的类并加载到容器里</li>
</ol>
<h2 id="二-创建注解">二、创建注解</h2>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {
}
</code></pre>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Controller {
}
</code></pre>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Repository {
}
</code></pre>
<pre><code class="language-java">//设置是作用在类上面的
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Service {
}
</code></pre>
<h2 id="三-提取标记对象">三、提取标记对象</h2>
<h3 id="1-指定范围加载">1. 指定范围加载</h3>
<ul>
<li>
<p>首先需要获取到一个类加载器，通过类加载器加载用户指定包的资源，类加载器详解，查看这个文章：<a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/">类加载器总结</a></p>
</li>
<li>
<p>获取类加载的方式，可以通过当前的线程获取</p>
</li>
</ul>
<pre><code class="language-java">/**
 * 获取类加载器
 *
 * @return 当前类加载器
 */
public static ClassLoader getClassLoader() {
    return Thread.currentThread().getContextClassLoader();
}
</code></pre>
<ul>
<li>由于用户传递过来的只是个包名称，而对于不同的机器，项目所在的位置不同，所以就需要通过类加载器获取到资源的具体路径</li>
</ul>
<pre><code class="language-java">URL url = classLoader.getResource(packageName.replace(&quot;.&quot;, &quot;/&quot;));
</code></pre>
<ul>
<li>getResource()接收的是一个以反斜杠分割的路径，而一般用户提供的都是以“.”分割的，所以我们需要替换成反斜杠</li>
<li>classLoader.getResource()方法返回的是一个URL，可以获取到协议，域名，端口号，路径，请求参数，如：https[协议]😕/www.xzzz2020.cn[域名]:80[端口号]/public/simplespring[路径]?id=xxx[请求参数]</li>
<li>而我们需要关注的是这样的URL：<strong>file:///F:/study/Spring</strong>，该资源可以定位本机的唯一资源，所以需要通过URL类中两个方法getProtocol()和getPath()获取定位包的文件协议和绝对路径</li>
<li>接着主要是递归调用目录所有.class文件，利用反射Class.forName方法创建实例，并加入到集合中</li>
</ul>
<p><strong>完整代码如下所示：</strong></p>
<pre><code class="language-java">/**
 * 类加载工具类
 * @author xzzz2020
 * @version 1.0
 * @date 2020/7/31 13:20
 */

@Slf4j
public final class ClassUtil {

    private static final String FILE_PROTOCLO = &quot;file&quot;;

    private ClassUtil() {
    }

    /**
     * 获取包下类的集合
     *
     * @param packageName 包名
     * @return 获取类的集合
     */
    public static Set&lt;Class&lt;?&gt;&gt; extractPackageClass(String packageName) {
        //1. 获取类的加载器，为了获取项目发布的实际路径
        ClassLoader classLoader = getClassLoader();
        //2. 通过类加载器获取到加载的资源信息
        URL url = classLoader.getResource(packageName.replace(&quot;.&quot;, &quot;/&quot;));
        if (url == null) {
            log.warn(&quot;unable to retrieve anything from package: &quot; + packageName);
            return null;
        } else {
            log.info(&quot;load path is &quot;+url.getProtocol()+&quot;://&quot;+url.getPath());
        }
        //3. 根据不同的资源类型，采用不同的方式获取资源的集合
        Set&lt;Class&lt;?&gt;&gt; classSet = null;
        //过滤出文件类型的资源
        if (url.getProtocol().equalsIgnoreCase(FILE_PROTOCLO)){
            classSet = new HashSet&lt;&gt;();
            File packageDirectory = new File(url.getPath());//获取文件的实际路径
            //递归遍历该目录下所有的class文件
            extractClassFile(classSet,packageDirectory,packageName);
        }
        return classSet;
    }

    /**
     * 递归遍历该目录下所有的class文件
     * @param emptyClassSet 装载目标类的集合
     * @param fileSource 文件或目录
     * @param packageName 加载的包路径
     */
    private static void extractClassFile(Set&lt;Class&lt;?&gt;&gt; emptyClassSet, File fileSource, String packageName) {
        if (!fileSource.isDirectory()){

        }else {
            //列出当前目录的所有文件和文件夹
            File[] files = fileSource.listFiles(new FileFilter() {
                /**
                 * 该方法是过滤当前目录下的所有文件和目录
                 * @param file 文件目录
                 * @return 如果是目录，返回true，如果是.class文件，加载到容器中，其他的返回false
                 */
                @Override
                public boolean accept(File file) {
                    if (file.isDirectory()){
                        return true;
                    }else {
                        //获取文件的绝对值路径
                        String absoluteFilePath = file.getAbsolutePath();
                        if (absoluteFilePath.endsWith(&quot;.class&quot;)){
                            //如果是class文件，直接加载
                            addToClassSet(absoluteFilePath);
                        }
                        //TODO 此处可以加入针对其他类型资源的处理
                    }
                    return false;
                }

                /**
                 * 根据class文件的绝对值路径，获取并生成class对象，并放入classSet中
                 * @param absoluteFilePath 文件的绝对值路径
                 */
                private void addToClassSet(String absoluteFilePath) {
                    //1.从class文件的绝对值路径里提取出包含了package的类名
                    //如/Users/baidu/imooc/springframework/sampleframework/target/classes/cn/xzzz2020/entity/dto/MainPageInfoDTO.class
                    //需要弄成cn.xzzz2020.entity.dto.MainPageInfoDTO
                    absoluteFilePath  = absoluteFilePath.replace(File.separator, &quot;.&quot;);
                    String className = absoluteFilePath.substring(absoluteFilePath.indexOf(packageName));
                    className = className.substring(0,className.lastIndexOf(&quot;.&quot;));
                    //2.通过反射机制获取对应的Class对象并加入到classSet里
                    Class&lt;?&gt; targetClass = loadClass(className);
                    emptyClassSet.add(targetClass);
                }
            });
            //递归遍历全部目录
            if (files!=null){//如果file的数组为空，使用foreach，还是会抛出空指针异常
                for (File file : files) {
                    extractClassFile(emptyClassSet,file,packageName);
                }
            }

        }
    }

    /**
     * 获取类加载器
     *
     * @return 当前类加载器
     */
    public static ClassLoader getClassLoader() {
        return Thread.currentThread().getContextClassLoader();
    }

    /**
     * 获取class对象
     * @param className class全限定类名
     * @return
     */
    public static Class&lt;?&gt; loadClass(String className){
        try {
            return Class.forName(className);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            log.error(&quot;Load class error &quot; + e);
            throw new RuntimeException();
        }
    }
    
    
    /**
     * 实例化类对象
     * @param clazz 需要实例化的class
     * @param accessible 是否允许使用私有的构造函数
     * @param &lt;T&gt; 对象
     * @return
     */
    public static &lt;T&gt; T newInstance(Class&lt;?&gt; clazz,boolean accessible){
        try {
            Constructor constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(accessible);
            return (T) constructor.newInstance();
        } catch (Exception e) {
            log.error(&quot;newInstance &quot;+clazz+&quot; error &quot;+e);
            throw new RuntimeException();
        }
    }
    
    /**
     * 设置类的属性值
     * @param field 成员变量
     * @param target 类实例
     * @param value 成员变量的值
     * @param accessible 是否允许设置私有属性
     */
    public static void setField(Field field,Object target,Object value,boolean accessible){
        field.setAccessible(accessible);
        try {
            field.set(target,value);
        } catch (Exception e) {
            log.error(&quot;setFiled error &quot;,e);
            throw new RuntimeException(e);
        }
    }

}
</code></pre>
<h2 id="四-实现ioc容器">四、实现IOC容器</h2>
<p><strong>容器一般由以下组成部分：</strong></p>
<ul>
<li>保存Class对象及其实例的载体</li>
<li>容器的加载</li>
<li>容器的操作方式</li>
</ul>
<blockquote>
<p>容器首先是单例的，但是传统的单例只能避免多线程下重复创建的问题，面对反射的强大能力，很容易就被创建一个新的对象</p>
<p>而Java提供了一个枚举类的形式，可以从源码层面避免创建多个对象。</p>
</blockquote>
<h3 id="1-枚举的单例">1. 枚举的单例</h3>
<pre><code class="language-java">//设置私有构造器
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Slf4j
public class BeanContainer {

    /**
     * 获取容器实例
     * @return 容器
     */
    public static BeanContainer getInstance() {
        return BeanContainerHolder.HOLDER.getInstance();
    }

    private enum BeanContainerHolder{
        HOLDER;
        private BeanContainer instance;
        BeanContainerHolder(){
            instance = new BeanContainer();
        }

        public BeanContainer getInstance() {
            return instance;
        }
    }
}
</code></pre>
<h3 id="2-保存class对象及其实例的载体">2. 保存Class对象及其实例的载体</h3>
<p>为了方便调用，将采用map的方式创建载体，但是不是使用HashMap，而是ConcurrentHashMap以保证高并发下的容器线程安全。</p>
<pre><code class="language-java">//存放所有被标记的map
private final Map&lt;Class&lt;?&gt;,Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<h3 id="3-容器加载">3. 容器加载</h3>
<pre><code class="language-java">/**
 * 加载Bean到容器中
 * @param packageName 包名称
 */
public synchronized void loadBeans(String packageName){
    //判断是否重复加载
    if (isLoaded()){
        log.warn(&quot;BeanContainer has been loaded.&quot;);
        return;
    }
    //获取指定包下面的class对象
    Set&lt;Class&lt;?&gt;&gt; classSet = ClassUtil.extractPackageClass(packageName);
    //判断能否加载对象
    if (ValidationUtil.isEmpty(classSet)){
        log.warn(&quot;This package &quot;+packageName+&quot; has nothing.&quot;);
        return;
    }
    for (Class&lt;?&gt; clazz :classSet){
        for (Class&lt;? extends Annotation&gt; annotation : BEAN_ANNOTATION) {
            //如果类上面标记了自定义的注解，就放入到容器中
            if (clazz.isAnnotationPresent(annotation)){
                beanMap.put(clazz,ClassUtil.newInstance(clazz,true));
            }
        }
    }
    loaded = true;
}
</code></pre>
<h3 id="4-容器的操作增删改查">4. 容器的操作（增删改查）</h3>
<pre><code class="language-java">/**
 * 判断是否过容器
 * @return true代表已经加载过容器了
 */
public boolean isLoaded() {
    return loaded;
}
/**
 * 获取加载到容器中bean实例的个数
 * @return
 */
public int getBeansSize(){
    return beanMap.size();
}
/**
 * 添加对象实例到容器中
 * @param clazz 指定对象
 * @param bean 指定实例
 * @return 添加的对象
 */
public Object addBean(Class&lt;?&gt; clazz,Object bean){
    return beanMap.put(clazz, bean);
}
/**
 * 删除容器中bean的实例
 * @param clazz 指定对象
 * @return 删除的对象
 */
public Object removeBean(Class&lt;?&gt; clazz){
    return beanMap.remove(clazz);
}
/**
 * 获取指定对象的实例
 * @param clazz 指定对象
 * @return 指定实例
 */
public Object getBean(Class&lt;?&gt; clazz){
    return beanMap.get(clazz);
}
/**
 * 获取容器中所有对象的集合
 * @return 对象集合
 */
public Set&lt;Class&lt;?&gt;&gt; getClasses(){
    return beanMap.keySet();
}
/**
 * 获取容器中所有实例化对象集合
 * @return 实例化对象集合
 */
public Set&lt;Object&gt; getBeans(){
    return new HashSet&lt;&gt;(beanMap.values());
}
/**
 * 根据注解获取对象集合
 * @param annotation 注解
 * @return
 */
public Set&lt;Class&lt;?&gt;&gt; getClassesByAnnotation(Class&lt;? extends Annotation&gt; annotation){
    //1.获取beanMap的所有class对象
    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();
    if(ValidationUtil.isEmpty(keySet)){
        log.warn(&quot;nothing in beanMap&quot;);
        return null;
    }
    //2.通过注解筛选被注解标记的class对象，并添加到classSet里
    Set&lt;Class&lt;?&gt;&gt; classSet = new HashSet&lt;&gt;();
    for (Class&lt;?&gt; clazz : keySet) {
        if (clazz.isAnnotationPresent(annotation)){
            classSet.add(clazz);
        }
    }
    return classSet.size()&gt;0?classSet:null;
}
/**
 * 通过接口或者父类获取实现类或者子类的Class集合，不包括其本身
 *
 * @param interfaceOrClass 接口Class或者父类Class
 * @return Class集合
 */
public Set&lt;Class&lt;?&gt;&gt; getClassesBySuper(Class&lt;?&gt; interfaceOrClass){
    //1.获取beanMap的所有class对象
    Set&lt;Class&lt;?&gt;&gt; keySet = getClasses();
    if(ValidationUtil.isEmpty(keySet)){
        log.warn(&quot;nothing in beanMap&quot;);
        return null;
    }
    //2.通过keySet的元素是否是传入的接口或者子类，如果是，并添加到classSet里
    Set&lt;Class&lt;?&gt;&gt; classSet = new HashSet&lt;&gt;();
    for (Class&lt;?&gt; clazz : keySet) {
        //isAssignableFrom可以判断是否是同一个类或者其超类
        if (interfaceOrClass.isAssignableFrom(clazz) &amp;&amp; !clazz.equals(interfaceOrClass)){
            classSet.add(clazz);
        }
    }
    return classSet.size()&gt;0?classSet:null;
}
</code></pre>
<h2 id="五-依赖注入">五、依赖注入</h2>
<h3 id="1-依赖注入的注解">1. 依赖注入的注解</h3>
<pre><code class="language-java">/**
 * @author xzzz2020
 * @version 1.0
 * @date 2020/7/31 17:06
 */

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Autowired {
    String value() default &quot;&quot;;
}
</code></pre>
<h3 id="2-对有注解的属性进行依赖注入">2. 对有注解的属性进行依赖注入</h3>
<pre><code class="language-java">/**
 * 提供依赖注入
 *
 * @author xzzz2020
 * @version 1.0
 * @date 2020/7/31 17:12
 */
@Slf4j
public class DependencyInjector {
    //Bean容器
    private BeanContainer beanContainer;

    public DependencyInjector() {
        beanContainer = BeanContainer.getInstance();
    }

    /**
     * 执行依赖注入
     */
    public void doIoc() {
        if (ValidationUtil.isEmpty(beanContainer.getClasses())) {
            log.warn(&quot;empty classset in BeanContainer&quot;);
            return;
        }
        //1.遍历Bean容器中所有的Class对象
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClasses();
        for (Class&lt;?&gt; clazz : classSet) {
            //2.遍历Class对象的所有成员变量
            Field[] fields = clazz.getDeclaredFields();
            if (ValidationUtil.isEmpty(fields)){
                continue;
            }
            //3.找出被Autowired标记的成员变量
            for (Field field : fields) {
                if (field.isAnnotationPresent(Autowired.class)){
                    //获取属性上面的注解，来解析属性
                    Autowired autowired = field.getAnnotation(Autowired.class);
                    String value = autowired.value();
                    //4.获取这些成员变量的类型
                    Class&lt;?&gt; fieldClazz = field.getType();
                    //5.获取这些成员变量的类型在容器里对应的实例
                    Object fieldValue = getFieldInstance(fieldClazz,value);
                    //获取不到对象，注入失败
                    if (fieldValue == null){
                        throw new RuntimeException(&quot;unable to inject relevant type，target fieldClass is:&quot; + fieldClazz.getName() + &quot; in &quot; +clazz.getSimpleName() );
                    }
                    //6.通过反射将对应的成员变量实例注入到成员变量所在类的实例里
                    Object targetBean = beanContainer.getBean(clazz);
                    ClassUtil.setField(field,targetBean,fieldValue,true);
                }
            }

        }

    }

    /**
     * 根据class对象获取其对象或者实现类
     * @param fieldClazz 属性定义的对象
     * @return
     */
    private Object getFieldInstance(Class&lt;?&gt; fieldClazz,String value) {
        Object fieldValue = beanContainer.getBean(fieldClazz);
        if (fieldValue!=null){
            return fieldClazz;
        }else {
           Class&lt;?&gt; implClass = getImplementClass(fieldClazz,value);
           if (implClass!=null){
               return beanContainer.getBean(implClass);
           }else {
               return null;
           }
        }
    }

    /**
     * 获取接口的实现类
     * @param fieldClazz 接口
     * @return
     */
    private Class&lt;?&gt; getImplementClass(Class&lt;?&gt; fieldClazz,String value) {
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesBySuper(fieldClazz);
        if (!ValidationUtil.isEmpty(classSet)){
            if (ValidationUtil.isEmpty(value)){//代表用户没有指定具体是那个实现类
                if (classSet.size()==1){
                    return classSet.iterator().next();
                }else {//如果该接口有多个实现类，则抛出异常
                    throw new RuntimeException(&quot;multiple implemented classes for &quot; + fieldClazz.getName() + &quot; please set @Autowired's value to pick one&quot;);
                }
            }else {//用户指定具体实现子类
                for (Class&lt;?&gt; clazz : classSet) {
                    if (value.equals(clazz.getSimpleName())){//是用户的指定类
                        return clazz;
                    }
                }
            }
        }
        return null;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】自定义SpringAOP]]></title>
        <id>https://xzzz2020.github.io/post/c2A2Jmewz/</id>
        <link href="https://xzzz2020.github.io/post/c2A2Jmewz/">
        </link>
        <updated>2020-09-10T12:07:20.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a>
<ul>
<li><a href="#1-aop%E7%9A%84%E5%BC%95%E5%87%BA">1. AOP的引出</a></li>
<li><a href="#2-%E8%87%AA%E7%A0%94aop%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD">2. 自研AOP提供的功能</a></li>
<li><a href="#3-aop%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">3. AOP的核心概念：</a></li>
<li><a href="#4-advice%E7%9A%84%E7%A7%8D%E7%B1%BB">4. Advice的种类：</a></li>
<li><a href="#5-%E5%88%87%E9%9D%A2%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">5. 切面执行顺序</a></li>
<li><a href="#6-introduction-%E5%BC%95%E5%85%A5%E5%9E%8Badvice">6. Introduction--引入型Advice</a></li>
<li><a href="#7-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">7. JDK动态代理</a></li>
<li><a href="#8-cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">8. CGLIb动态代理</a></li>
<li><a href="#9-springaop%E7%9A%84%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6">9. SpringAOP的底层机制</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%88%A9%E7%94%A8cglib%E5%AE%9E%E7%8E%B0aop%E9%80%BB%E8%BE%91">二、利用CGLib实现AOP逻辑</a>
<ul>
<li><a href="#1-%E5%AE%8C%E6%88%90%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%88%9B%E5%BB%BA">1. 完成注解的创建</a></li>
<li><a href="#2-%E5%88%87%E9%9D%A2%E6%A8%A1%E6%9D%BF%E7%B1%BB">2. 切面模板类</a></li>
<li><a href="#3-%E8%A2%AB%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E7%BB%87%E5%85%A5%E5%AE%9E%E7%8E%B0">3. 被代理类的织入实现</a></li>
<li><a href="#4-%E6%89%A7%E8%A1%8C%E5%AE%B9%E5%99%A8%E7%9A%84aop%E6%93%8D%E4%BD%9C">4. 执行容器的AOP操作</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%BC%95%E5%85%A5aspectj%E6%A1%86%E6%9E%B6">三、引入AspectJ框架</a>
<ul>
<li><a href="#1-aspectj%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">1. AspectJ框架简介</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2. 环境配置</a></li>
<li><a href="#3-%E8%A7%A3%E6%9E%90aspect%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E5%AE%9A%E4%BD%8D%E8%A2%AB%E7%BB%87%E5%85%A5%E7%9B%AE%E6%A0%87">3. 解析Aspect表达式并定位被织入目标</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<h3 id="1-aop的引出">1. AOP的引出</h3>
<p><strong>在开发中除了有业务需求，也会存在系统需求：</strong></p>
<ul>
<li><strong>添加日志信息</strong>：为每个方法添加统计统计</li>
<li>**添加系统权限校验：**针对某些方法进行限制</li>
<li><strong>事务控制</strong>：针对持久化的数据，进行事务的精细控制</li>
</ul>
<p><strong>面向对象编程需要在每个方法加入通用的代码，代码没有被复用，同时增加维护成本</strong></p>
<p>软件工程里面有一个概念叫做关注点分离，即不同的问题交给不同的部分去解决，面向切面编程（AOP）就是一种关注点分离的技术。</p>
<p>将业务功能代码和系统层面代码分离，系统通用化功能的代码实现就是切面Aspect。Aspect之于AOP，相当于class之于OOP，Bean之于IOC。</p>
<h3 id="2-自研aop提供的功能">2. 自研AOP提供的功能</h3>
<ul>
<li>
<p>利用CGLIB实现对目标类方法的增强</p>
<ul>
<li>定义MethodInterceptor实现类，完成对方法的增强，methodProxy的invokeSuper方法复杂执行原定的方法逻辑，在这个方法执行前后以及出现异常的时候，可以织入相关逻辑。同时定义了@Order注解，对切面按照指定的顺序执行。</li>
<li>利用Enhancer的create方法，传入目标类和对方法增强的织入逻辑，动态产生一个增强后的类，替换掉原来的类</li>
</ul>
</li>
<li>
<p>引入AspectJ的表达式解析能力，更加灵活的定义切点</p>
<ul>
<li><strong>PointcutParser</strong>：提供对表达式语法的支持，利用parsePointcutExpression方法，解析表达式，将返回一个PointcutExpression接口的实现类</li>
<li><strong>PointcutExpression接口</strong>：用于验证类或者方法是否符合表达式规则，couldMatchJoinPointsInType方法提供类的粗检查，只能校验within的表达式，其他的都会表达true；matchesMethodExecution方法提供对方法的精确检查</li>
</ul>
</li>
</ul>
<h3 id="3-aop的核心概念">3. AOP的核心概念：</h3>
<ul>
<li>**切面Aspect：**将横切关注点逻辑逻辑进行模块化封装的实体对象</li>
<li>**通知Advice：**好比是Class里面的方法，还定义了织入逻辑的时机</li>
<li>**连接点JoinPoint：**允许使用Advice的地方</li>
<li>**切入点PointCut：**定义一系列规则对JoinPoint进行筛选</li>
<li>**目标对象Target：**符合PointCut的对象</li>
<li><strong>织入</strong>：将Aspect模块化的横切关注点集成到OOP里</li>
<li>**织入器：**完成织入过程的执行者，如ajc</li>
</ul>
<h3 id="4-advice的种类">4. Advice的种类：</h3>
<blockquote>
<p>需要注意一点@Around注解如果使用了try..catch..，就会让@AfterThrowing注解失败</p>
</blockquote>
<ul>
<li>**BeforeAdvice：**在JoinPoint前被执行的Advice，无法阻止JoinPoint的执行，除非发生了异常</li>
<li>**AfterAdvice：**好比try..catch..finally里面的finally方法，不管方法是否发生异常，都会最终执行</li>
<li>**AfterReturningAdvice：**在JoinPoint正常执行后，才能正在执行，如果出现异常，则无法执行</li>
<li>**AfterThrowingAdvice：**在JoinPoint在执行时抛出才会触发</li>
<li>**AroundAdvice：**可以在JoinPoint执行前后进行织入，也可以决定JoinPoint是否需要执行</li>
</ul>
<p><strong>分拆的原因</strong>：丰富Advice的语义，可以单独将某个环节拆出来用，并能依据不同场景，最小化织入Advice</p>
<h3 id="5-切面执行顺序">5. 切面执行顺序</h3>
<blockquote>
<p>多个Aspect可以使用@Order进行排序，数值越小越先执行</p>
</blockquote>
<ol>
<li>@Around，JoinPoint的proceed方法执行前</li>
<li>@Before，在@Around选择执行时触发，在执行前织入</li>
<li>@Around方法执行以及执行后逻辑</li>
<li>@After</li>
<li>如果正常执行，是@AfterReturning，出现异常是@AfterThrowing</li>
</ol>
<h3 id="6-introduction-引入型advice">6. Introduction--引入型Advice</h3>
<ul>
<li>为目标类引入新接口，而不需要目标类做任何实现</li>
<li>使得目标类在使用过程中转型成新接口对象，调用新接口方法</li>
</ul>
<h3 id="7-jdk动态代理">7. JDK动态代理</h3>
<h3 id="8-cglib动态代理">8. CGLIb动态代理</h3>
<ul>
<li>不要求被代理类实现接口</li>
<li>内部主要封装了ASM Java字节码操作框架，可以帮助我们安全的操作字节码</li>
<li>动态生成一个子类以覆盖非final的方法，绑定钩子回调自定义拦截器</li>
</ul>
<p><strong>被代理类：</strong></p>
<pre><code class="language-java">public class CommonPayment {
    public void pay() {
        System.out.println(&quot;个人名义或者公司名义都可以走这个支付通道&quot;);
    }
}
</code></pre>
<p><strong>方法拦截器：</strong></p>
<pre><code class="language-java">public class AlipayMethodInterceptor implements MethodInterceptor {
    /**
     *
     * @param proxy 生成的代理对象
     * @param method 被增强的方法
     * @param args 方法的参数
     * @param methodProxy 增强后的方法
     * @return 方法的返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        beforePay();
        Object result = methodProxy.invokeSuper(proxy,args);
        afterPay();
        return result;
    }

    private void afterPay() {
        System.out.println(&quot;支付给公司&quot;);
    }

    private void beforePay() {
        System.out.println(&quot;从银行取款&quot;);
    }

}
</code></pre>
<p><strong>Cglib工具类</strong>：</p>
<pre><code class="language-java">public class CglibUtil {
    public static &lt;T&gt; T creatProxy(T targetObject, MethodInterceptor interceptor){
        Object proxy = Enhancer.create(targetObject.getClass(), interceptor);
        return (T) proxy;
    }
}
</code></pre>
<p><strong>JDK动态代理和Cglib的区别？</strong></p>
<blockquote>
<p>JDK动态代理做了很多优化，所以性能和Cglib差异不大</p>
</blockquote>
<ul>
<li>JDK动态代理是基于反射实现的，要求业务类必须实现接口，是JDK原生，在JVM运行更可靠，可以减少依赖</li>
<li>Cglib基于ASM机制实现，通过生成业务类的子类作为代理类，无需实现接口，能实现代理类的无侵入</li>
</ul>
<h3 id="9-springaop的底层机制">9. SpringAOP的底层机制</h3>
<ul>
<li>是Cglib与JDK动态代理共存的</li>
<li><strong>默认策略</strong>：如果Bean实现了接口采用JDK动态代理的方式，否则使用CGlib</li>
</ul>
<h2 id="二-利用cglib实现aop逻辑">二、利用CGLib实现AOP逻辑</h2>
<blockquote>
<p>由于CGLib不需要实现接口，实现比较简单</p>
</blockquote>
<h3 id="1-完成注解的创建">1. 完成注解的创建</h3>
<p><strong>标记类为切面，实现横切逻辑</strong></p>
<pre><code class="language-java">//只能注入到类上
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Aspect {
    /*
    * 需要被织入横切逻辑的注解标签
    */
    Class&lt;? extends Annotation&gt; value();
}
</code></pre>
<p><strong>标记切面的执行顺序</strong></p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Order {
    /*
    值越小，越先执行
     */
    int value() default Integer.MAX_VALUE;
}
</code></pre>
<h3 id="2-切面模板类">2. 切面模板类</h3>
<blockquote>
<p>切面需要继承该类，并重写相应的方法实现横切逻辑</p>
<p>如果没有重写，则相应方法为空，不影响结果</p>
</blockquote>
<pre><code class="language-java">public abstract class DefaultAspect {
    /**
     * 事前拦截
     * @param targetClass 被代理的目标类
     * @param method 被代理的目标方法
     * @param args 被代理的目标方法对应的参数列表
     * @throws Throwable
     */
    public void before(Class&lt;?&gt; targetClass, Method method, Object[] args) throws Throwable{

    }
    /**
     * 事后拦截
     * @param targetClass 被代理的目标类
     * @param method 被代理的目标方法
     * @param args 被代理的目标方法对应的参数列表
     * @param returnValue 被代理的目标方法执行后的返回值
     * @throws Throwable
     */
    public Object afterReturning(Class&lt;?&gt; targetClass, Method method, Object[] args, Object returnValue) throws Throwable{
        return returnValue;
    }
    /**
     *
     * @param targetClass 被代理的目标类
     * @param method 被代理的目标方法
     * @param args 被代理的目标方法对应的参数列表
     * @param e 被代理的目标方法抛出的异常
     * @throws Throwable
     */
    public void afterThrowing(Class&lt;?&gt; targetClass, Method method, Object[] args,  Throwable e) throws Throwable{

    }
}
</code></pre>
<h3 id="3-被代理类的织入实现">3. 被代理类的织入实现</h3>
<blockquote>
<ul>
<li>
<p>实现CGLib中MethodInterceptor接口的intercept方法，实现被代理类的切入逻辑</p>
</li>
<li>
<p>会自动对传入的切面按照order排序</p>
</li>
</ul>
</blockquote>
<pre><code class="language-java">public class AspectListExecutor implements MethodInterceptor {
    //被代理的类
    private Class&lt;?&gt; targetClass;
    //排过序的Aspect列表
    @Getter
    private List&lt;AspectInfo&gt; sortedAspectInfos;

    public AspectListExecutor(Class&lt;?&gt; targetClass, List&lt;AspectInfo&gt; aspectInfos) {
        this.targetClass = targetClass;
        this.sortedAspectInfos = sortAspectInfoList(aspectInfos);
    }

    /**
     * 根据aspectInfos的Order属性值进行排序
     *
     * @param aspectInfos
     * @return
     */
    private List&lt;AspectInfo&gt; sortAspectInfoList(List&lt;AspectInfo&gt; aspectInfos) {
        aspectInfos.sort(new Comparator&lt;AspectInfo&gt;() {
            @Override
            public int compare(AspectInfo o1, AspectInfo o2) {
                //按照order的大小排序
                return o1.getOrderIndex() - o2.getOrderIndex();
            }
        });
        return aspectInfos;
    }

    /**
     * 实现被代理类的织入逻辑
     * @param proxy 生成的代理对象
     * @param method 被增强的方法
     * @param args 方法的参数
     * @param methodProxy 增强后的方法
     * @return 方法的返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        Object returnValue = null;
        if (ValidationUtil.isEmpty(sortedAspectInfos)){
            return null;
        }
        try {
            //1.按照order的顺序升序执行完所有Aspect的before方法
            invokeBeforeAdvices(method,args);
            //2.执行被代理类的方法
            returnValue = methodProxy.invokeSuper(proxy,args);
            //3.如果被代理方法正常返回，则按照order的顺序降序执行完所有Aspect的afterReturning方法
            returnValue = invokeAfterReturningAdvice(method,args,returnValue);
        } catch (Throwable throwable) {
            //4.如果被代理方法抛出异常，则按照order的顺序降序执行完所有Aspect的afterThrowing方法
            invokeAfterThrowingAdvices(method,args,throwable);
        }
        return returnValue;
    }

    //如果被代理方法抛出异常，则按照order的顺序降序执行完所有Aspect的afterThrowing方法
    private void invokeAfterThrowingAdvices(Method method, Object[] args, Throwable throwable) throws Throwable {
        for(int i = sortedAspectInfos.size()-1;i&gt;=0;i--){
           sortedAspectInfos.get(i).getDefaultAspect().afterThrowing(targetClass,method,args,throwable);
        }
    }

    //如果被代理方法正常返回，则按照order的顺序降序执行完所有Aspect的afterReturning方法
    private Object invokeAfterReturningAdvice(Method method, Object[] args, Object returnValue) throws Throwable {
        Object result = null;
        for(int i = sortedAspectInfos.size()-1;i&gt;=0;i--){
            result = sortedAspectInfos.get(i).getDefaultAspect().afterReturning(targetClass,method,args,returnValue);
        }
        return result;
    }

    //按照order的顺序升序执行完所有Aspect的before方法
    private void invokeBeforeAdvices(Method method, Object[] args) throws Throwable {
        for (AspectInfo sortedAspectInfo : sortedAspectInfos) {
            sortedAspectInfo.getDefaultAspect().before(targetClass,method,args);
        }
    }
}
</code></pre>
<h3 id="4-执行容器的aop操作">4. 执行容器的AOP操作</h3>
<p><strong>基本逻辑为：</strong></p>
<ol>
<li>将所有被@Aspect注解标记的切面类获取</li>
<li>根据切面类的切入点不同，进行分类</li>
<li>根据不同的切入点，生成该切入点的动态代理类，替换掉容器中没有被代理的类</li>
</ol>
<pre><code class="language-java">public class AspectWeaver {
    private BeanContainer beanContainer;

    public AspectWeaver() {
        beanContainer = BeanContainer.getInstance();
    }

    public void doAop() {
        //1.获取所有的切面类
        Set&lt;Class&lt;?&gt;&gt; aspectSet = beanContainer.getClassesByAnnotation(Aspect.class);
        if (ValidationUtil.isEmpty(aspectSet)) {
            return;
        }
        //2.将切面类按照不同的织入目标分类
        Map&lt;Class&lt;? extends Annotation&gt;, List&lt;AspectInfo&gt;&gt; categorizedMap = new HashMap&lt;&gt;();
        for (Class&lt;?&gt; aspectClass : aspectSet) {
            //验证切面
            if (verifyAspect(aspectClass)) {
                categorizeAspect(categorizedMap, aspectClass);
            } else {
                //不遵守规范则直接抛出异常
                throw new RuntimeException(&quot;@Aspect and @Order must be added to the Aspect class, and Aspect class must extend from DefaultAspect&quot;);
            }
        }
        //3.按照不同的织入目标，分别去按序织入Aspect的逻辑
        if (!ValidationUtil.isEmpty(categorizedMap)){
            for (Class&lt;? extends Annotation&gt; category : categorizedMap.keySet()) {
                weaveByCategory(category,categorizedMap.get(category));
            }
        }
    }

    private void weaveByCategory(Class&lt;? extends Annotation&gt; category, List&lt;AspectInfo&gt; aspectInfos) {
        //1.获取被代理类的集合
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClassesByAnnotation(category);
        if (ValidationUtil.isEmpty(classSet)){
            return;
        }
        //2.遍历被代理类，分别为每个被代理类生成动态代理实例
        for (Class&lt;?&gt; targerClass : classSet) {
            //创建动态代理对象
            AspectListExecutor aspectListExecutor = new AspectListExecutor(targerClass,aspectInfos);
            //本质调用的这个Enhancer.create(targetClass,interceptor);
            Object proxyBean = ProxyCreator.createProxy(targerClass, aspectListExecutor);
            //3.将动态代理的实例对象添加到容器中，取代未被代理前的实例
            beanContainer.addBean(targerClass,proxyBean);
        }
    }

    //将切面类按照不同的织入目标分类
    private void categorizeAspect(Map&lt;Class&lt;? extends Annotation&gt;, List&lt;AspectInfo&gt;&gt; categorizedMap, Class&lt;?&gt; aspectClass) {
        Order orderTag = aspectClass.getAnnotation(Order.class);
        Aspect aspectTag = aspectClass.getAnnotation(Aspect.class);
        DefaultAspect bean = (DefaultAspect) beanContainer.getBean(aspectClass);
        AspectInfo aspectInfo = new AspectInfo(orderTag.value(),bean);
        //获取织入点的集合
        List&lt;AspectInfo&gt; infoList = categorizedMap.getOrDefault(aspectTag.value(), new ArrayList&lt;AspectInfo&gt;());
        infoList.add(aspectInfo);
        categorizedMap.put(aspectTag.value(),infoList);
    }

    //框架中一定要遵守给Aspect类添加@Aspect和@Order标签的规范，同时，必须继承自DefaultAspect.class
    //此外，@Aspect的属性值不能是它本身
    private boolean verifyAspect(Class&lt;?&gt; aspectClass) {
        return aspectClass.isAnnotationPresent(Aspect.class)
                &amp;&amp; aspectClass.isAnnotationPresent(Order.class)
                &amp;&amp; DefaultAspect.class.isAssignableFrom(aspectClass)
                &amp;&amp; aspectClass.getAnnotation(Aspect.class).value() != Aspect.class;
    }
}

/**
 * 创建动态代理对象
 * @author xzzz2020
 * @version 1.0
 * @date 2020/8/8 11:33
 */
public class ProxyCreator {

    public static Object createProxy(Class&lt;?&gt; targetClass, MethodInterceptor interceptor){
        return Enhancer.create(targetClass,interceptor);
    }
}

</code></pre>
<h2 id="三-引入aspectj框架">三、引入AspectJ框架</h2>
<blockquote>
<p>让Pointcut更加灵活，引入AspectJ的切面表达式和相关的定位解析机制</p>
</blockquote>
<h3 id="1-aspectj框架简介">1. AspectJ框架简介</h3>
<ul>
<li>定义了切面语法以及切面语法的解析机制</li>
<li>提供了强大的织入工具，由于Cglib只支持方法的织入，而AspectJ可以支持所有的织入，比如说属性或者构造函数</li>
</ul>
<p><strong>支持多种时机的织入，</strong></p>
<ul>
<li><strong>编译时织入（静态织入）</strong>：利用ajc编译器而不是Javac编译器，将源文件编译成class文件，并将切面逻辑织入到class文件</li>
<li><strong>编译后织入（静态织入）</strong>：先利用Javac将源文件编译成class文件，再利用ajc将切面逻辑织入到class文件</li>
<li><strong>类加载期织入（动态织入，Load Time Weaving）</strong>：利用java agent，在类加载的时候织入切面逻辑</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>
<p>相比于Spring性能更高，Spring是在类加载后才去生成一个动态代理的对象，而AspectJ是在编译期或者类加载时期完成切面逻辑的替换</p>
<blockquote>
<p>SpringAOP在容器Refresh时已经完成了加载，同时类是单例的，存储在缓存中，实际使用时性能差距并不大</p>
</blockquote>
</li>
</ul>
<p><strong>对于Spring而言仅仅使用了AspectJ的切面语法，并没用使用ajc编译器</strong></p>
<ul>
<li>避免增加用户的学习成本，即使用20%的学习成本满足80%的需求</li>
<li>只是默认不使用，如果想用ajc还是可以引入的</li>
<li>织入机制还是沿用了CGLIB以及JDK动态代理机制</li>
</ul>
<h3 id="2-环境配置">2. 环境配置</h3>
<p><strong>引入aspectjweaver的JAR包，以支持表达式的解析。</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>修改@Aspect注解</strong></p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Aspect {
    String pointcut();
}
</code></pre>
<h3 id="3-解析aspect表达式并定位被织入目标">3. 解析Aspect表达式并定位被织入目标</h3>
<p><strong>有两个关键的类</strong></p>
<ul>
<li><strong>PointcutParser</strong>：提供对表达式语法的支持，利用parsePointcutExpression方法，解析表达式，将返回一个PointcutExpression接口的实现类</li>
<li><strong>PointcutExpression接口</strong>：用于验证类或者方法是否符合表达式规则，couldMatchJoinPointsInType方法提供类的粗检查，只能校验within的表达式，其他的都会表达true；matchesMethodExecution方法提供对方法的精确检查</li>
</ul>
<pre><code class="language-java">public class PointcutLocator {
    //表达式解析器，判断类和方法是否符合表达式
    private PointcutExpression pointcutExpression;

    public PointcutLocator(String expression){
        //Pointcut解析器,支持所有AspectJ的所有语法树，解析String类型的Pointcut语法
        PointcutParser pointcutParser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingContextClassloaderForResolution(
                PointcutParser.getAllSupportedPointcutPrimitives()
        );
        this.pointcutExpression = pointcutParser.parsePointcutExpression(expression);
    }

    /**
     * 判断传入的Class对象是否符合Pointcut表达式（初筛）
     * @param targetClass 目标类
     * @return 是否匹配
     */
    public boolean roughMatches(Class&lt;?&gt; targetClass){
        //只能校验within的表达式，其他的都会表达true
        return pointcutExpression.couldMatchJoinPointsInType(targetClass);
    }

    /**
     * 判断传入的Method对象是否符合Pointcut表达式（精确筛选）
     * @param method 目标方法
     * @return 是否匹配
     */
    public boolean accurateMatches(Method method){
        ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);
        //判断是否完全匹配
        return shadowMatch.alwaysMatches();
    }
}
</code></pre>
<p><strong>修改AspectInfo类，提供对表达式解析的支持</strong></p>
<pre><code class="language-java">@AllArgsConstructor
@Getter
@ToString
public class AspectInfo {
    //Aspect的执行顺序
    private  int OrderIndex;
    //Aspect
    private  DefaultAspect defaultAspect;

    private PointcutLocator pointcutLocator;

}
</code></pre>
<p><strong>修改doAop的逻辑以支持表达式</strong></p>
<pre><code class="language-java">public class AspectWeaver {
    private BeanContainer beanContainer;

    public AspectWeaver() {
        beanContainer = BeanContainer.getInstance();
    }

    public void doAop() {
        //1.获取所有的切面类
        Set&lt;Class&lt;?&gt;&gt; aspectSet = beanContainer.getClassesByAnnotation(Aspect.class);
        if (ValidationUtil.isEmpty(aspectSet)) {
            return;
        }
        //2.拼装AspectInfoList
        List&lt;AspectInfo&gt; aspectInfoList = packAspectInfoList(aspectSet);
        //3.遍历容器的所有类
        Set&lt;Class&lt;?&gt;&gt; classSet = beanContainer.getClasses();
        for (Class&lt;?&gt; targetClass : classSet) {
            //排除切面类本身
            if(!targetClass.isAnnotationPresent(Aspect.class)){
                //4.粗筛符合条件的切面
                List&lt;AspectInfo&gt; roughMatchedAspectList = collectRoughMatchedAspectListForSpecificClass(aspectInfoList,targetClass);
                //5.尝试进行Aspect织入
                wrapIfNecessary(roughMatchedAspectList,targetClass);
            }
        }


    }

    /**
     *
     * @param roughMatchedAspectList
     * @param targetClass
     */
    private void wrapIfNecessary(List&lt;AspectInfo&gt; roughMatchedAspectList, Class&lt;?&gt; targetClass) {
        if(!ValidationUtil.isEmpty(roughMatchedAspectList)){
            //创建动态代理对象
            AspectListExecutor aspectListExecutor = new AspectListExecutor(targetClass,roughMatchedAspectList);
            Object proxy = ProxyCreator.createProxy(targetClass, aspectListExecutor);
            beanContainer.addBean(targetClass,proxy);
        }
    }

    /**
     * 粗筛选出存在对应切点的切面逻辑
     * @param aspectInfoList 切面集合
     * @param targetClass 目标类
     * @return
     */
    private List&lt;AspectInfo&gt; collectRoughMatchedAspectListForSpecificClass(List&lt;AspectInfo&gt; aspectInfoList, Class&lt;?&gt; targetClass) {
        List&lt;AspectInfo&gt; roughMatchedAspectList = new ArrayList&lt;&gt;();
        for (AspectInfo aspectInfo : aspectInfoList) {
            //粗筛
            if (aspectInfo.getPointcutLocator().roughMatches(targetClass)){
                roughMatchedAspectList.add(aspectInfo);
            }
        }
        return roughMatchedAspectList;
    }

    /**
     * 验证被@Aspect注解标记的类是否符合要求
     * 如果符合要求，取出所需的Pointcut表达式，Order值以及对应的Bean
     * @param aspectSet
     * @return
     */
    private List&lt;AspectInfo&gt; packAspectInfoList(Set&lt;Class&lt;?&gt;&gt; aspectSet) {
        List&lt;AspectInfo&gt; aspectInfos = new ArrayList&lt;&gt;();
        for (Class&lt;?&gt; aspectClass : aspectSet) {
            if (verifyAspect(aspectClass)){
                Order orderTag = aspectClass.getAnnotation(Order.class);
                Aspect aspectTag = aspectClass.getAnnotation(Aspect.class);
                DefaultAspect defaultAspect = (DefaultAspect) beanContainer.getBean(aspectClass);
                //初始化表达式定位器
                PointcutLocator pointcutLocator = new PointcutLocator(aspectTag.pointcut());
                AspectInfo aspectInfo = new AspectInfo(orderTag.value(),defaultAspect,pointcutLocator);
                aspectInfos.add(aspectInfo);
            }else {
                //不遵守规范则直接抛出异常
                throw new RuntimeException(&quot;@Aspect and @Order must be added to the Aspect class, and Aspect class must extend from DefaultAspect&quot;);
            }
        }
        return aspectInfos;
    }

    //框架中一定要遵守给Aspect类添加@Aspect和@Order标签的规范，同时，必须继承自DefaultAspect.class
    //此外，@Aspect的属性值不能是它本身
    private boolean verifyAspect(Class&lt;?&gt; aspectClass) {
        return aspectClass.isAnnotationPresent(Aspect.class) &amp;&amp;
                aspectClass.isAnnotationPresent(Order.class) &amp;&amp;
                DefaultAspect.class.isAssignableFrom(aspectClass);
    }

}
</code></pre>
<p><strong>在织入之前做一次精确的判断</strong></p>
<pre><code class="language-java">@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    Object returnValue = null;
    //对代理类进行精筛
    collectAccurateMatchedAspectList(method);
    if (ValidationUtil.isEmpty(sortedAspectInfos)){
        return methodProxy.invokeSuper(proxy,args);
    }
    try {
        //1.按照order的顺序升序执行完所有Aspect的before方法
        invokeBeforeAdvices(method,args);
        //2.执行被代理类的方法
        returnValue = methodProxy.invokeSuper(proxy,args);
        //3.如果被代理方法正常返回，则按照order的顺序降序执行完所有Aspect的afterReturning方法
        returnValue = invokeAfterReturningAdvice(method,args,returnValue);
    } catch (Throwable throwable) {
        //4.如果被代理方法抛出异常，则按照order的顺序降序执行完所有Aspect的afterThrowing方法
        invokeAfterThrowingAdvices(method,args,throwable);
    }
    return returnValue;
}

    /**
     * 对代理类进行精筛
     * @param method
     */
    private void collectAccurateMatchedAspectList(Method method) {
        if (!ValidationUtil.isEmpty(sortedAspectInfos)){
            Iterator&lt;AspectInfo&gt; iterator = sortedAspectInfos.iterator();
            while (iterator.hasNext()){
                AspectInfo aspectInfo = iterator.next();
                if (!aspectInfo.getPointcutLocator().accurateMatches(method)){
                    iterator.remove();
                }
            }
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【2021届】Java面试复习提纲]]></title>
        <id>https://xzzz2020.github.io/post/1gW2y906H/</id>
        <link href="https://xzzz2020.github.io/post/1gW2y906H/">
        </link>
        <updated>2020-09-06T02:36:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章主要是作为一个Java复习的提纲，采用的并不是对每一个知识点进行讲解的形式，它的目的很纯粹，就是为了检测自己的掌握程度，针对面试题目复习，如果掌握不够好，建议先去专栏学习：<a href="https://xzzz2020.gitee.io/tag/Interview_summary/">面试复习专栏</a></p>
<p>你可以将其作为<strong>模拟面试</strong>的问题来源，测试你的熟练程度；也可以当作面试前的<strong>知识点梳理</strong>，对一些细节问题进行填补；</p>
<p>当然，这个笔记本也同样适用于那些能够通过简历筛选，但是对计算机基础所知甚少的人，如果你之前从未在学校修过或者自学过这些课程，你依然可以通过这份笔记<strong>快速备战面试</strong>。</p>
</blockquote>
<blockquote>
<p>首先，如果对Java学习的体系不了解，建议先去这个博客保存一下这张图：<a href="https://blog.csdn.net/qq_43040688/article/details/105819866">Java技能图谱</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-java%E5%9F%BA%E7%A1%80">一、Java基础</a>
<ul>
<li><a href="#11-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">1.1 语言基础</a></li>
<li><a href="#12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">1.2 面向对象</a></li>
<li><a href="#13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">1.3 面向对象</a></li>
<li><a href="#14-%E5%BC%82%E5%B8%B8">1.4 异常</a></li>
<li><a href="#15-%E6%95%B0%E7%BB%84">1.5 数组</a></li>
<li><a href="#16-%E5%B8%B8%E7%94%A8%E7%B1%BB">1.6 常用类</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81">二、容器集合（源码）</a>
<ul>
<li><a href="#21-list">2.1 List</a></li>
<li><a href="#22-set">2.2 Set</a></li>
<li><a href="#23-map">2.3 Map</a></li>
<li><a href="#24-collections">2.4 Collections</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%B9%B6%E5%8F%91">三、并发</a>
<ul>
<li><a href="#31-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80">3.1 并发基础</a></li>
<li><a href="#32-cas">3.2 CAS</a></li>
<li><a href="#33-synchronize%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96">3.3 Synchronize原理及优化</a></li>
<li><a href="#34-juc%E5%B7%A5%E5%85%B7">3.4 JUC工具</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-jvm">四、JVM</a>
<ul>
<li><a href="#41-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">4.1  类加载过程</a></li>
<li><a href="#42-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">4.2 类加载器</a></li>
<li><a href="#43-jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">4.3 JVM垃圾回收</a></li>
<li><a href="#44-jvm%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6">4.4 JVM内存机制</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-java%E9%AB%98%E7%BA%A7">五、Java高级</a>
<ul>
<li><a href="#51-%E5%8F%8D%E5%B0%84">5.1 反射</a></li>
<li><a href="#52-%E6%B3%A8%E8%A7%A3">5.2 注解</a></li>
<li><a href="#53-socket">5.3 Socket</a></li>
<li><a href="#54-nio-bio">5.4 Nio、Bio</a></li>
<li><a href="#55-%E6%B3%9B%E5%9E%8B">5.5 泛型</a></li>
<li><a href="#56-jdk8%E5%92%8C11">5.6 JDK8和11</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">六、操作系统</a></li>
<li><a href="#%E4%B8%83-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">七、计算机网络</a></li>
<li><a href="#%E5%85%AB-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">八、算法与数据结构</a></li>
<li><a href="#%E4%B9%9D-%E6%95%B0%E6%8D%AE%E5%BA%93mysql">九、数据库（MySQL）</a></li>
<li><a href="#%E5%8D%81-%E7%BC%93%E5%AD%98redis">十、缓存（Redis）</a>
<ul>
<li><a href="#101-redis%E5%9F%BA%E7%A1%80">10.1 Redis基础</a></li>
<li><a href="#102-%E8%B7%B3%E8%B7%83%E8%A1%A8">10.2 跳跃表</a></li>
<li><a href="#103-redis%E6%8C%81%E4%B9%85%E5%8C%96">10.3 Redis持久化</a></li>
<li><a href="#104-redis%E5%93%A8%E5%85%B5">10.4 Redis哨兵</a></li>
<li><a href="#105-redis%E9%85%8D%E7%BD%AE">10.5 Redis配置</a></li>
<li><a href="#106-redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">10.6 Redis主从复制</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80-spring">十一、Spring</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C-springboot">十二、SpringBoot</a></li>
<li><a href="#%E5%8D%81%E4%B8%89-springmvc">十三、SpringMVC</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B-mybatis">十四、Mybatis</a></li>
<li><a href="#%E5%8D%81%E4%BA%94-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">十五、常用设计模式</a></li>
<li><a href="#%E5%8D%81%E5%85%AD-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rocketmq-rabbitmq-kafka">十六、消息队列（RocketMq、rabbitMQ、kafka）</a></li>
<li><a href="#%E5%8D%81%E4%B8%83-%E5%BE%AE%E6%9C%8D%E5%8A%A1dubbo-zookeeper-springcloud">十七、微服务（Dubbo、zookeeper、SpringCloud）</a></li>
<li><a href="#%E5%8D%81%E5%85%AB-%E9%A1%B9%E7%9B%AE">十八、项目</a>
<ul>
<li><a href="#181-%E9%AB%98%E5%B9%B6%E5%8F%91">18.1 高并发</a></li>
<li><a href="#182-%E9%AB%98%E5%8F%AF%E7%94%A8">18.2 高可用</a></li>
<li><a href="#183-%E9%AB%98%E5%AE%89%E5%85%A8">18.3 高安全</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B9%9D-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">十九、系统架构</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81-netty">二十、Netty</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-java基础">一、Java基础</h2>
<h3 id="11-语言基础">1.1 语言基础</h3>
<h3 id="12-面向对象">1.2 面向对象</h3>
<h3 id="13-面向对象">1.3 面向对象</h3>
<h3 id="14-异常">1.4 异常</h3>
<h3 id="15-数组">1.5 数组</h3>
<h3 id="16-常用类">1.6 常用类</h3>
<h2 id="二-容器集合源码">二、容器集合（源码）</h2>
<h3 id="21-list">2.1 List</h3>
<h3 id="22-set">2.2 Set</h3>
<h3 id="23-map">2.3 Map</h3>
<h3 id="24-collections">2.4 Collections</h3>
<h2 id="三-并发">三、并发</h2>
<h3 id="31-并发基础">3.1 并发基础</h3>
<h3 id="32-cas">3.2 CAS</h3>
<h3 id="33-synchronize原理及优化">3.3 Synchronize原理及优化</h3>
<h3 id="34-juc工具">3.4 JUC工具</h3>
<h2 id="四-jvm">四、JVM</h2>
<h3 id="41-类加载过程">4.1  类加载过程</h3>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E4%B8%80-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">一、类的加载过程</a></li>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E4%BA%8C-%E5%8A%A0%E8%BD%BD">二、加载</a></li>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E4%B8%89-%E9%AA%8C%E8%AF%81">三、验证</a></li>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E5%9B%9B-%E5%87%86%E5%A4%87">四、准备</a></li>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E4%BA%94-%E8%A7%A3%E6%9E%90">五、解析</a></li>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E5%85%AD-%E5%88%9D%E5%A7%8B%E5%8C%96">六、初始化</a></li>
<li><a href="https://xzzz2020.gitee.io/post/FOuttAozI/#%E4%B8%83-%E5%8D%B8%E8%BD%BD">七、卸载</a></li>
</ul>
<h3 id="42-类加载器">4.2 类加载器</h3>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li>
<li><a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/#%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8">二、自定义加载器</a></li>
<li>三、双亲委派模型
<ul>
<li><a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/#1-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84">1. 双亲委派模型的好处</a></li>
<li><a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/#2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">2. 双亲委派模型实现源码分析</a></li>
<li><a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/#3-%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E4%B8%8D%E6%83%B3%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%80%8E%E4%B9%88%E5%8A%9E">3. 如果我们不想用双亲委派模型怎么办？</a></li>
<li><a href="https://xzzz2020.gitee.io/post/jTbAiVT5N/#4-classloaderloadclass-%E5%92%8C-classforname-%E7%9A%84%E5%8C%BA%E5%88%AB">4. ClassLoader.loadClass 和 Class.forName 的区别</a></li>
</ul>
</li>
</ul>
<h3 id="43-jvm垃圾回收">4.3 JVM垃圾回收</h3>
<ul>
<li>
<p>一、如何判断对象是否死亡？</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">1. 引用计数法</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">2. 可达性分析算法</a></li>
</ul>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#%E4%BA%8C-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8">二、四种引用</a></p>
</li>
<li>
<p>三、垃圾回收算法</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">1. 标记清除算法</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">2. 复制算法</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#3%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95">3.标记压缩算法</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">4. 分代收集算法</a></li>
</ul>
</li>
<li>
<p>四、常见的垃圾回收器有那些?</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#1-serial-%E6%94%B6%E9%9B%86%E5%99%A8">1. Serial 收集器</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#2-parnew-%E6%94%B6%E9%9B%86%E5%99%A8">2. ParNew 收集器</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#3-parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8">3. Parallel Scavenge 收集器</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#4-serial-old-%E6%94%B6%E9%9B%86%E5%99%A8">4. Serial Old 收集器</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#5-parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8">5. Parallel Old 收集器</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#6-cms-%E6%94%B6%E9%9B%86%E5%99%A8">6. CMS 收集器</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#7-g1-%E6%94%B6%E9%9B%86%E5%99%A8">7. G1 收集器</a></li>
</ul>
</li>
<li>
<p>五、其他</p>
<ul>
<li>
<p><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#1-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%8F%AF%E4%BB%A5gc%E5%90%97">1. 方法区可以GC吗？</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#2-%E5%93%AA%E4%BA%9B%E5%85%83%E7%B4%A0%E5%8F%AF%E4%BB%A5%E5%81%9Agc-root">2. 哪些元素可以做GC root？</a></p>
</li>
<li>
<ol start="3">
<li>Minor GC、Major GC和Full GC之间的区别？</li>
</ol>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#minor-gc">Minor GC</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#major-gc">Major GC</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#full-gc">Full GC</a></li>
</ul>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#4-%E5%B8%B8%E7%94%A8jvm%E5%8F%82%E6%95%B0">4. 常用JVM参数</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/Yuwv7VFrF/#5-%E9%A2%91%E7%B9%81fullgc%E7%9A%84%E5%8E%9F%E5%9B%A0">5. 频繁fullGC的原因？</a></p>
</li>
</ul>
<h3 id="44-jvm内存机制">4.4 JVM内存机制</h3>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">二、程序计数器</a></li>
<li>三、虚拟机栈
<ul>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E9%97%AE%E9%A2%98%E8%BE%A8%E6%9E%90">问题辨析</a></li>
</ul>
</li>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E5%9B%9B-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">四、本地方法栈</a></li>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E4%BA%94-%E5%A0%86">五、堆</a></li>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E5%85%AD-%E6%96%B9%E6%B3%95%E5%8C%BA">六、方法区</a></li>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E4%B8%83-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">七、运行时常量池</a></li>
<li><a href="https://xzzz2020.gitee.io/post/YkvbP7GKA/#%E5%85%AB-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">八、直接内存</a></li>
</ul>
</li>
</ul>
<h2 id="五-java高级">五、Java高级</h2>
<h3 id="51-反射">5.1 反射</h3>
<h3 id="52-注解">5.2 注解</h3>
<h3 id="53-socket">5.3 Socket</h3>
<h3 id="54-nio-bio">5.4 Nio、Bio</h3>
<h3 id="55-泛型">5.5 泛型</h3>
<h3 id="56-jdk8和11">5.6 JDK8和11</h3>
<h2 id="六-操作系统">六、操作系统</h2>
<h2 id="七-计算机网络">七、计算机网络</h2>
<h2 id="八-算法与数据结构">八、算法与数据结构</h2>
<h2 id="九-数据库mysql">九、数据库（MySQL）</h2>
<h2 id="十-缓存redis">十、缓存（Redis）</h2>
<h3 id="101-redis基础">10.1 Redis基础</h3>
<ul>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E4%B8%80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredis">一、简单介绍一下Redis</a></p>
</li>
<li>
<p>二、五种数据结构</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#1-%E5%AD%97%E7%AC%A6%E4%B8%B2-string">1. 字符串 string</a></li>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#2-%E5%88%97%E8%A1%A8-list">2. 列表 list</a></li>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#3-%E5%AD%97%E5%85%B8-hash">3. 字典 hash</a></li>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#4-%E9%9B%86%E5%90%88-set">4. 集合 set</a></li>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#5-%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8-zset">5. 有序列表 zset</a></li>
</ul>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E4%BA%8C-redis%E5%92%8Cmemcached%E7%9A%84%E5%8C%BA%E5%88%AB">二、Redis和Memcached的区别？</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E4%B8%89-%E4%B8%BA%E4%BB%80%E4%B9%88redis%E9%82%A3%E4%B9%88%E5%BF%AB">三、为什么Redis那么快？</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%9B%9B-%E4%BB%8E%E6%B5%B7%E9%87%8Fkey%E9%87%8C%E6%9F%A5%E8%AF%A2%E5%87%BA%E6%9F%90%E4%B8%80%E5%9B%BA%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84key">四、从海量Key里查询出某一固定前缀的Key？</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E4%BA%94-%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">五、如何用Redis实现异步消息队列</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%85%AD-redis%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">六、Redis有哪些使用场景？</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E4%B8%83-redis%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">七、redis的删除策略有哪些</a></p>
</li>
<li>
<p>八、什么是布隆过滤器？</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#1-%E5%8E%9F%E7%90%86">1. 原理</a></li>
</ul>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">2. 使用场景</a></p>
</li>
<li>
<p>九、缓存穿透</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">有哪些解决办法？</a></li>
</ul>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%8D%81-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">十、缓存雪崩</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%8D%81%E4%B8%80-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">十一、缓存预热</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%8D%81%E4%BA%8C-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7">十二、缓存降级</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%8D%81%E4%B8%89-%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">十三、过期键的删除策略</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%8D%81%E5%9B%9B-redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">十四、Redis的内存用完了会发生什么？</a></p>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/xjKzNVypB/#%E5%8D%81%E4%BA%94-redis%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3">十五、Redis事务相关</a></p>
</li>
</ul>
<h3 id="102-跳跃表">10.2 跳跃表</h3>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/MiE8tJSYr/#%E4%B8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E8%A1%A8">一、为什么要使用跳跃表？</a></li>
<li><a href="https://xzzz2020.gitee.io/post/MiE8tJSYr/#%E4%BA%8C-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8">二、什么是跳跃表？</a></li>
<li><a href="https://xzzz2020.gitee.io/post/MiE8tJSYr/#%E4%B8%89-redis%E5%AE%9E%E7%8E%B0">三、Redis实现</a></li>
</ul>
<h3 id="103-redis持久化">10.3 Redis持久化</h3>
<ul>
<li>
<p><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#%E4%B8%80-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89">一、持久化的意义</a></p>
</li>
<li>
<p>持久化详解</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#1-rdb%E5%92%8Caof%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D">1、RDB和AOF两种持久化机制的介绍</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#2-rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9">2、RDB持久化机制的优点</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#3-rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9">3、RDB持久化机制的缺点</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#4-aof%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9">4、AOF持久化机制的优点</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#5-aof%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9">5、AOF持久化机制的缺点</a></li>
<li><a href="https://xzzz2020.gitee.io/post/Y_OlIRTju/#6-rdb%E5%92%8Caof%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">6、RDB和AOF到底该如何选择</a></li>
</ul>
</li>
</ul>
<h3 id="104-redis哨兵">10.4 Redis哨兵</h3>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E4%B8%80-%E5%93%A8%E5%85%B5%E7%9A%84%E4%BB%8B%E7%BB%8D">一、哨兵的介绍</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E4%BA%8C-%E5%93%A8%E5%85%B5%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86">二、 哨兵的核心知识</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E4%B8%89-%E4%B8%BA%E4%BB%80%E4%B9%88redis%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%8F%AA%E6%9C%892%E4%B8%AA%E8%8A%82%E7%82%B9%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C">三、为什么redis哨兵集群只有2个节点无法正常工作？</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E5%9B%9B-%E7%BB%8F%E5%85%B8%E7%9A%843%E8%8A%82%E7%82%B9%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4">四、经典的3节点哨兵集群</a></li>
<li>五、两种数据丢失的情况
<ul>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#1-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">1. 异步复制导致的数据丢失</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#2-%E8%84%91%E8%A3%82%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">2. 脑裂导致的数据丢失</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#3-%E8%A7%A3%E5%86%B3">3. 解决</a></li>
</ul>
</li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E5%85%AD-sdown%E5%92%8Codown%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6">六、sdown和odown转换机制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E4%B8%83-%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6">七、哨兵集群的自动发现机制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E5%85%AB-slave%E9%85%8D%E7%BD%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E7%BA%A0%E6%AD%A3">八、slave配置的自动纠正</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E4%B9%9D-slave-master%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95">九、slave-&gt;master选举算法</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E5%8D%81-quorum%E5%92%8Cmajority">十、quorum和majority</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E5%8D%81%E4%B8%80-configuration-epoch">十一、configuration epoch</a></li>
<li><a href="https://xzzz2020.gitee.io/post/XQ2Qib6Xc/#%E5%8D%81%E4%BA%8C-configuraiton%E4%BC%A0%E6%92%AD">十二、configuraiton传播</a></li>
</ul>
<h3 id="105-redis配置">10.5 Redis配置</h3>
<ul>
<li>
<p>一、容灾策略</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#1-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AErdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6">1. 如何配置RDB持久化机制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#2-rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">2. RDB持久化机制的工作流程</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#3-aof%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE">3. AOF持久化的配置</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#4-aof-rewrite">4. AOF rewrite</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#5-aof%E7%A0%B4%E6%8D%9F%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E5%A4%8D">5. AOF破损文件的修复</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#6-aof%E5%92%8Crdb%E5%90%8C%E6%97%B6%E5%B7%A5%E4%BD%9C">6. AOF和RDB同时工作</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#7-%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5">7. 企业级的备份策略</a></li>
</ul>
</li>
<li>
<p>二、读写分离</p>
<ul>
<li>
<p><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#1-redis-replication%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B">1. redis replication主从复制过程</a></p>
</li>
<li>
<ol start="2">
<li>主从搭建</li>
</ol>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#%E4%BB%8E%E8%8A%82%E7%82%B9">从节点</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#%E4%B8%BB%E8%8A%82%E7%82%B9">主节点</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B5%8B%E8%AF%95">读写分离架构的测试</a></li>
</ul>
</li>
<li>
<p><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#3-%E5%BF%AB%E9%80%9F%E5%8E%8B%E6%B5%8B">3. 快速压测</a></p>
</li>
</ul>
</li>
<li>
<p>三、哨兵配置</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#1-%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E5%92%8C%E8%84%91%E8%A3%82%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">1. 解决异步复制和脑裂导致的数据丢失</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#2-%E9%85%8D%E7%BD%AE%E7%BB%8F%E5%85%B8%E4%B8%89%E8%8A%82%E7%82%B9%E5%93%A8%E5%85%B5">2. 配置经典三节点哨兵</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">3. 常用命令</a></li>
</ul>
</li>
<li>
<p>四、Redis-cluster集群配置</p>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#1-redis-cluster%E7%9A%84%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE">1. redis cluster的重要配置</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#2-%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">2. 编写配置文件</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#3-%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83">3. 准备环境</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#4-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4">4. 创建集群</a></li>
<li><a href="https://xzzz2020.gitee.io/post/IAIpFCygR/#5-%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">5. 添加删除节点</a></li>
</ul>
</li>
</ul>
<h3 id="106-redis主从复制">10.6 Redis主从复制</h3>
<ul>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#1-%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B">1. 复制的完整流程</a></li>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#2-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6">2. 数据同步相关的核心机制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#3-%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6">3. 全量复制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#4-%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6">4. 增量复制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#5-heartbeat">5. heartbeat</a></li>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#6-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6">6. 异步复制</a></li>
<li><a href="https://xzzz2020.gitee.io/post/y9Xr-Nu8H/#7-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B">7. 主从复制流程</a></li>
</ul>
<h2 id="十一-spring">十一、Spring</h2>
<h2 id="十二-springboot">十二、SpringBoot</h2>
<h2 id="十三-springmvc">十三、SpringMVC</h2>
<h2 id="十四-mybatis">十四、Mybatis</h2>
<h2 id="十五-常用设计模式">十五、常用设计模式</h2>
<h2 id="十六-消息队列rocketmq-rabbitmq-kafka">十六、消息队列（RocketMq、rabbitMQ、kafka）</h2>
<h2 id="十七-微服务dubbo-zookeeper-springcloud">十七、微服务（Dubbo、zookeeper、SpringCloud）</h2>
<h2 id="十八-项目">十八、项目</h2>
<h3 id="181-高并发">18.1 高并发</h3>
<h3 id="182-高可用">18.2 高可用</h3>
<h3 id="183-高安全">18.3 高安全</h3>
<h2 id="十九-系统架构">十九、系统架构</h2>
<h2 id="二十-netty">二十、Netty</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何进行消息队列技术选型？]]></title>
        <id>https://xzzz2020.github.io/post/ru-he-jin-xing-xiao-xi-dui-lie-ji-zhu-xuan-xing/</id>
        <link href="https://xzzz2020.github.io/post/ru-he-jin-xing-xiao-xi-dui-lie-ji-zhu-xuan-xing/">
        </link>
        <updated>2020-09-05T08:10:05.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E9%97%AE%E9%A2%98%E5%AF%BC%E8%AF%BB">一、问题导读</a></li>
<li><a href="#%E4%BA%8C-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BF%83%E7%90%86%E5%88%86%E6%9E%90">二、面试官心理分析</a></li>
<li><a href="#%E4%B8%89-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%96%E6%9E%90">三、面试题剖析</a>
<ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%95%8A">1. 为什么使用消息队列啊？</a></li>
<li><a href="#2-mq%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">2. MQ的优缺点</a></li>
<li><a href="#3-kafka-activemq-rabbitmq-rocketmq%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">3. kafka、activemq、rabbitmq、rocketmq都有什么优点和缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-问题导读">一、问题导读</h2>
<blockquote>
<p>为什么使用消息队列啊？消息队列有什么优点和缺点啊？kafka、activemq、rabbitmq、rocketmq都有什么区别以及适合哪些场景？</p>
</blockquote>
<h2 id="二-面试官心理分析">二、面试官心理分析</h2>
<p><strong>第一，你知道不知道你们系统里为什么要用消息队列这个东西？</strong></p>
<p><strong>第二，你既然用了消息队列这个东西，你知道不知道用了有什么好处？</strong></p>
<p><strong>第三，既然你用了MQ，可能是某一种MQ，那么你当时做没做过调研啊？</strong></p>
<h2 id="三-面试题剖析">三、面试题剖析</h2>
<h3 id="1-为什么使用消息队列啊">1. 为什么使用消息队列啊？</h3>
<ul>
<li>其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么</li>
<li>期望的一个回答是说，你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多的好处</li>
</ul>
<p><strong>消息队列的常见使用场景</strong></p>
<ul>
<li>
<p>比较核心的有3个：解耦、异步、削峰</p>
</li>
<li>
<p><strong>解耦</strong></p>
<ul>
<li>
<p>A系统发送个数据到BCD三个系统，接口调用发送，如果新加入或删除一个系统，就需要更改源码；如果某一个系统宕机或者访问超时，就还需要考虑是否需要重发，是否需要存储消息；如果发送另外一种类型的消息，也依然需要更改源码。这就是A系统跟其他系统严重耦合的地方。</p>
</li>
<li>
<p>如果加入了消息队列，现在A系统只需要将数据发送到MQ中即可，其他系统可以自己决定是否需要相关数据，如果需要，从MQ中消费数据即可。系统A不需要考虑谁需要消费消息，也不需要考虑消息的重试机制</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwOTA1MTEwMTUxODM5LnBuZw?x-oss-process=image/format,png" alt="image-20200905110151839" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p><strong>异步</strong></p>
<ul>
<li>
<p>A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要上百毫秒，最终请求总延时接近1s。一般要求在200ms以内，十分影响用户体验。</p>
</li>
<li>
<p>加入消息队列后，一个请求的总延时等于A系统写库的时间+向消息队列发送消息的时间，其他系统可以从消息队列中消费消息完成写库，可以极大的优化系统体验。</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwOTA1MTExMTI3OTg5LnBuZw?x-oss-process=image/format,png" alt="image-20200905111127989" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p><strong>削峰</strong></p>
<ul>
<li>如果一个系统在一个时刻，比如说秒杀活动时，系统需要突然处理大量的请求，可能就会造成系统的宕机，如果增加很多服务器，又会在其他时候浪费系统资源。</li>
<li>加入MQ时，将所有的请求发送到MQ中，如果系统A最多每秒处理2000个请求，就从MQ中每秒拉取2000个请求，这样可以保证系统在高峰时肯定不会宕机。</li>
</ul>
</li>
</ul>
<p><strong>面试技巧：</strong></p>
<ul>
<li>你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。在简历中体现出来这块东西，用MQ作解耦。</li>
</ul>
<h3 id="2-mq的优缺点">2. MQ的优缺点</h3>
<blockquote>
<p>优点就是上面的解耦、异步、削峰，主要讲缺点</p>
</blockquote>
<p><strong>系统可用性降低</strong>：系统引入的外部依赖越多，整个系统越容易挂掉，如果MQ出现问题，可能会导致整个系统崩溃。</p>
<p><strong>系统复杂性提高</strong>：加入MQ候，需要考虑很多问题，比如怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</p>
<p><strong>一致性问题</strong>：在异步处理消息时，A系统处理完了直接返回成功了，但是如果BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，就会出现一致性问题。</p>
<h3 id="3-kafka-activemq-rabbitmq-rocketmq都有什么优点和缺点">3. kafka、activemq、rabbitmq、rocketmq都有什么优点和缺点</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>
<td>10万级别，这是kafka最大的优点，就是吞吐量高。     一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降     这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td>
<td>topic从几十个到几百个的时候，吞吐量会大幅度下降     所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>微秒级，这是rabbitmq的一大特点，延迟是最低的</td>
<td>ms级</td>
<td>延迟在ms级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>非常高，分布式架构</td>
<td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td></td>
<td>经过参数优化配置，可以做到0丢失</td>
<td>经过参数优化配置，消息可以做到0丢失</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ领域的功能极其完备</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong>：</p>
<ul>
<li>
<p><strong>ActiveMQ</strong></p>
<ul>
<li><strong>非常成熟</strong>，功能强大，在业内大量的公司以及项目中都有应用</li>
<li><strong>偶尔会有较低概率丢失消息</strong></li>
<li>而且现在社区以及国内应用都越来越少，<strong>官方社区现在对ActiveMQ 5.x维护越来越少</strong>，几个月才发布一个版本</li>
<li>而且确实主要是基于解耦和异步来用的，<strong>较少在大规模吞吐的场景中使用</strong></li>
</ul>
</li>
<li>
<p><strong>RabbitMQ</strong></p>
<ul>
<li><strong>erlang语言开发，性能极其好，延时很低</strong></li>
<li><strong>吞吐量到万级，MQ功能比较完备</strong></li>
<li><strong>社区相对比较活跃，几乎每个月都发布几个版本分</strong></li>
<li><strong>开源提供的后台管理页面功能十分齐全，适合中小型项目使用</strong></li>
<li>但是问题也是显而易见的，RabbitMQ确实<strong>吞吐量会低一些</strong>，这是因为他做的实现机制比较重。</li>
<li>而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你<strong>很难去看懂源码</strong>，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。</li>
<li><strong>rabbitmq集群动态扩展会很麻烦</strong>，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</li>
</ul>
</li>
<li>
<p><strong>RocketMQ</strong></p>
<ul>
<li>
<p><strong>接口简单易用</strong>，而且毕竟在阿里大规模应用过，有阿里品牌保障</p>
</li>
<li>
<p>日处理消息上百亿之多，可以做到<strong>大规模吞吐</strong>，性能也非常好，<strong>分布式扩展也很方便</strong>，社区维护还可以，可靠性和可用性都是ok的，还<strong>可以支撑大规模的topic数量</strong>，支持复杂MQ业务场景</p>
</li>
<li>
<p>而且一个很大的优势在于，阿里出品都是java系的，我们<strong>可以自己阅读源码，定制自己公司的MQ，可以掌控</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Kafka</strong></p>
<ul>
<li>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是<strong>提供超高的吞吐量</strong>，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展</li>
<li>同时<strong>kafka最好是支撑较少的topic数量即可，保证其超高吞吐量</strong></li>
<li>而且kafka唯一的一点劣势是<strong>有可能消息重复消费</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略</li>
<li>这个特性天然<strong>适合大数据实时计算以及日志收集</strong></li>
</ul>
</li>
</ul>
<p><strong>个人建议</strong></p>
<ul>
<li>一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃</li>
<li>如果是中小型公司，基础架构研发能力较弱，采用RabbitMQ是不错的选择，虽然erlang语言阻止了大量的java工程师去深入研究和掌控他，但是社区十分活跃</li>
<li>如果系统有较大吞吐量需求，同时可能会有大量的topic，基础架构研发实力较强的大公司，完全可以采用RocketMQ，即使社区不再更新，也可以自己去维护</li>
<li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】RocketMq高级特性]]></title>
        <id>https://xzzz2020.github.io/post/czb-YfH6n/</id>
        <link href="https://xzzz2020.github.io/post/czb-YfH6n/">
        </link>
        <updated>2020-07-27T10:52:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8">一、消息存储</a>
<ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%98%E5%82%A8%E5%88%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%80%A7%E8%83%BD">1. 为什么要存储到文件系统？如何保证性能？</a></li>
<li><a href="#2-%E5%8A%A0%E5%85%A5%E6%8C%81%E4%B9%85%E5%8C%96%E5%90%8Erocketmq%E7%9A%84%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">2. 加入持久化后RocketMq的架构是什么样的？</a></li>
<li><a href="#3-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">3. 存储结构是什么样的？</a></li>
<li><a href="#4-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B">4. 刷盘机制有哪些？</a></li>
<li><a href="#5-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1">5. 如何保证消息不丢失？</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6">二、高可用机制</a>
<ul>
<li><a href="#1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%BB%E4%BB%8E">1. 消息消费的高可用（主从）</a></li>
<li><a href="#2-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9">2. 消息发送高可用（配置多个主节点）</a></li>
<li><a href="#3-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">3. 主从复制</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">三、负载均衡</a>
<ul>
<li><a href="#1-producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">1. Producer负载均衡</a></li>
<li><a href="#2-consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2. Consumer负载均衡</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6">四、消息重试机制</a>
<ul>
<li><a href="#1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E8%AF%95">1. 顺序消息的重试</a></li>
<li><a href="#2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E8%AF%95">2. 无序消息的重试</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97">五、死信队列</a></li>
<li><a href="#%E5%85%AD-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89">六、消费幂等</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A7%E7%94%9F%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF">1. 什么时候产生重复消息？</a></li>
<li><a href="#2-%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">2. 处理方式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E7%9A%84%E9%97%AE%E9%A2%98">七、如何解决消息积压的问题？</a>
<ul>
<li><a href="#%E5%85%AB-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAmq">八、如何设计一个Mq？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-消息存储">一、消息存储</h2>
<blockquote>
<p>分布式队列因为<strong>有高可靠性，保证消息不会丢失</strong>的要求，所以数据要进行持久化存储。.</p>
</blockquote>
<h3 id="1-为什么要存储到文件系统如何保证性能">1. 为什么要存储到文件系统？如何保证性能？</h3>
<p>持久化方式可以分成两大类</p>
<ul>
<li><strong>关系型数据库</strong>：ActiveMQ默认采用的KahaDB做消息存储，由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。</li>
<li><strong>文件系统</strong>：RocketMQ/Kafka/RabbitMQ）均采用的是消息刷盘至所部署虚拟机/物理机的文件系统来做持久化，刷盘一般可以分为异步刷盘和同步刷盘两种模式</li>
</ul>
<p><strong>一般来讲性能对比上：文件系统&gt;关系型数据库DB</strong></p>
<p><strong>RocketMq的文件存储系统有两点优化以保证性能</strong>：</p>
<ul>
<li><strong>消息存储（顺序写）</strong>：RocketMQ的消息用<code>顺序写</code>,保证了消息存储的速度。目前的高性能磁盘，顺序写速度可以达到600MB/s， 超过了一般网卡的传输速度，但是磁盘随机写的速度只有大概100KB/s</li>
<li><strong>消息发送（零拷贝）</strong>：将本机磁盘文件的内容发送到客户端需要进行多次复制，比如从磁盘复制数据到内核态内存；从内核态内存复制到用户态内存；从用户态内存复制到网络驱动，最后从网络驱动复制到网卡中。RocketMq采用Java中零拷贝的技术，让从内核态内存复制到用户态内存这一步省略，直接赋值到网络驱动中</li>
</ul>
<blockquote>
<p>零拷贝技术有个限制是不能超过2G，所以RocketMQ默认设置单个CommitLog日志数据文件为1G</p>
</blockquote>
<h3 id="2-加入持久化后rocketmq的架构是什么样的">2. 加入持久化后RocketMq的架构是什么样的？</h3>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLyVFNiVCNiU4OCVFNiU4MSVBRiVFNSVBRCU5OCVFNSU4MiVBOCVFNiU5NiVCOSVFNSVCQyU4Ri5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<h3 id="3-存储结构是什么样的">3. 存储结构是什么样的？</h3>
<p><strong>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的</strong></p>
<ul>
<li><code>CommitLog</code>：消息真正的<strong>物理存储文件</strong>是CommitLog，<strong>默认一个文件一个G</strong>，存储的是Topic，QueueId和Message，一个存储满了会自动创建一个新的。</li>
<li><code>ConsumeQueue</code>：是消息的逻辑队列，<strong>类似数据库的索引文件</strong>，存储的是指向物理存储的地址，为了加快消息的读取速度。消费者消费某条消息时，先查询索引获取CommitLog的对应的物理地址。每个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件，<strong>文件很小，通常会加载到内存中</strong>。如果该文件丢失或者损坏，可以通过CommitLog恢复</li>
</ul>
<ul>
<li><code>IndexFile</code>：也是个索引文件，<strong>为了消息查询提供了一种通过key或时间区间来查询消息的方法</strong>，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li>
</ul>
<h3 id="4-刷盘机制有哪些">4. 刷盘机制有哪些？</h3>
<ul>
<li><strong>同步刷盘</strong>（数据一定保存成功，但是速度慢）：在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</li>
<li><strong>异步刷盘</strong>（速度快，数据不一定保存成功）：在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLyVFNSU5MCU4QyVFNiVBRCVBNSVFNSU4OCVCNyVFNyU5QiU5OCVFNSU5MiU4QyVFNSVCQyU4MiVFNiVBRCVBNSVFNSU4OCVCNyVFNyU5QiU5OC5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<h3 id="5-如何保证消息不丢失">5. 如何保证消息不丢失？</h3>
<ul>
<li>RocketMq提供消息持久化机制，消息的刷盘策略分为同步刷盘和异步刷盘。同步刷盘即刷盘成功后再返回一个成功信息，能够保证数据一定保存成功，但是会降低系统吞吐量，异步刷盘与同步刷盘相反，我一般会采用同步刷盘的策略来保证消息不会丢失。</li>
<li>RocketMq采用的文件系统存储而不是关系型数据库存储，因为在一般情况下文件系统的性能是比数据库性能高的</li>
<li>而RocketMq为了提高文件系统的读写的高性能，做了两点优化。第一点是采用顺序写的方式，这样可以大大提高磁盘写的性能。第二点采用了零拷贝，原来的文件读取流程是：从磁盘复制数据到内核态内存；从内核态内存复制到用户态内存；从用户态内存复制到网络驱动，最后从网络驱动复制到网卡中发送，零拷贝则省去了从内核态内存复制到用户态内存的这一过程，提高了读取的性能，但是零拷贝对文件大小有要求，所以RocketMq的持久化文件commitlog默认为1G。</li>
<li>commitlog是存储了RocketMq的消息等核心信息，除此之外，还提供可一个ConsumeQueue作为持久化文件的索引，提高查询的效率，一般文件比较小，都是加载在内存中。除了ConsumeQueue之外，还会存储一个IndexFile文件，用来提供针对某一个key或者时间区间的查询。</li>
</ul>
<h2 id="二-高可用机制">二、高可用机制</h2>
<blockquote>
<p>RocketMq是天生支持分布式的，可以配置主从以及水平扩展</p>
<p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p>
</blockquote>
<h3 id="1-消息消费的高可用主从">1. 消息消费的高可用（主从）</h3>
<ul>
<li>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</li>
<li><strong>RocketMQ目前还不支持把Slave自动转成Master</strong>，如果机器资源不足，需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文件，用新的配置文件启动Broker。</li>
</ul>
<h3 id="2-消息发送高可用配置多个主节点">2. 消息发送高可用（配置多个主节点）</h3>
<ul>
<li>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。</li>
</ul>
<h3 id="3-主从复制">3. 主从复制</h3>
<blockquote>
<p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
</blockquote>
<ul>
<li><strong>同步复制</strong>：同步复制方式是等Master和Slave均写成功后才反馈给客户端写成功状态。如果Master出故障， Slave上有全部的备份数据，容易恢复同步复制会增大数据写入延迟，降低系统吞吐量。</li>
<li><strong>异步复制</strong>：异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失</li>
<li>通常情况下，<strong>应该把Master和Save配置成同步刷盘方式，主从之间配置成异步的复制方式</strong>，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。</li>
</ul>
<h2 id="三-负载均衡">三、负载均衡</h2>
<h3 id="1-producer负载均衡">1. Producer负载均衡</h3>
<p>Producer端，每个实例在发消息的时候，默认会<strong>轮询</strong>所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL3Byb2R1Y2VyJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUExLnBuZw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<h3 id="2-consumer负载均衡">2. Consumer负载均衡</h3>
<blockquote>
<p>如果consumer实例的数量比message queue的总数量还多的话，<strong>多出来的consumer实例将无法分到queue</strong>，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
</blockquote>
<ul>
<li>
<p>消费者的集群模式--启动多个消费者就可以保证消费者的负载均衡（均摊队列）</p>
</li>
<li>
<p><strong>默认使用的是均摊队列</strong>：会按照queue的数量和实例的数量平均分配queue给每个实例，这样每个消费者可以均摊消费的队列，如下图所示6个队列和三个生产者。</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2NvbnN1bWVyJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUExLnBuZw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<ul>
<li>另外一种平均的算法<strong>环状轮流分queue</strong>的形式，每个消费者，均摊不同主节点的一个消息队列，如下图所示：</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2NvbnN1bWVyJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUExMi5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<blockquote>
<p>对于广播模式并不是负载均衡的，要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
</blockquote>
<h2 id="四-消息重试机制">四、消息重试机制</h2>
<h3 id="1-顺序消息的重试">1. 顺序消息的重试</h3>
<ul>
<li>
<p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。</p>
</li>
<li>
<p>因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，<strong>避免阻塞</strong>现象的发生。</p>
</li>
</ul>
<h3 id="2-无序消息的重试">2. 无序消息的重试</h3>
<ul>
<li>
<p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
</li>
<li>
<p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
</li>
<li>
<p>消息队列 RocketMQ 默认允许每条消息<code>最多重试 16 次</code>，<strong>将会在接下来的 4 小时 46 分钟之内进行 16 次重试</strong>，如果依然失败就会进入死信队列。</p>
</li>
<li>
<p>一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p>
</li>
<li>
<p>也可以通过配置，让其不再重试，但是不建议这样</p>
</li>
</ul>
<pre><code class="language-java">public class MessageListenerImpl implements MessageListener {
    @Override
    public Action consume(Message message, ConsumeContext context) {
        try {
            doConsumeMessage(message);
        } catch (Throwable e) {
            //捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;
            return Action.CommitMessage;
        }
        //消息处理正常，直接返回 Action.CommitMessage;
        return Action.CommitMessage;
    }
}
</code></pre>
<h2 id="五-死信队列">五、死信队列</h2>
<p><strong>死信消息具有以下特性:</strong></p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p><strong>死信队列具有以下特性：</strong></p>
<ul>
<li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ul>
<p><strong>查看死信队列</strong></p>
<ol>
<li>在控制台查询出现死信队列的主题信息</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLyVFNiVBRCVCQiVFNCVCRiVBMSVFOSU5OCU5RiVFNSU4OCU5NyVFNCVCOCVCQiVFOSVBMiU5OC5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<ol start="2">
<li>在消息界面根据主题查询死信消息</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLyVFNiVBRCVCQiVFNCVCRiVBMSVFOSU5OCU5RiVFNSU4OCU5NyVFNCVCOCVCQiVFOSVBMiU5ODIucG5n?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<ol start="3">
<li>选择重新发送消息</li>
</ol>
<p>一条消息进入死信队列，<strong>意味着某些因素导致消费者无法正常消费该消息</strong>，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p>
<h2 id="六-消费幂等">六、消费幂等</h2>
<p>消息队列 RocketMQ 消费者在接收到消息以后，<strong>有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</strong></p>
<h3 id="1-什么时候产生重复消息">1. 什么时候产生重复消息？</h3>
<p>在互联网应用中，尤其在<strong>网络不稳定</strong>的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ul>
<li>
<p><strong>发送时消息重复</strong></p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li>
<p><strong>消费时消息重复</strong></p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li>
<p><strong>负载均衡时消息重复</strong>（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
</li>
</ul>
<h3 id="2-处理方式">2. 处理方式</h3>
<p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是<strong>以业务唯一标识作为幂等处理的关键依据</strong>，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<pre><code class="language-java">Message message = new Message();
message.setKey(&quot;ORDERID_100&quot;);
SendResult sendResult = producer.send(message);
</code></pre>
<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<pre><code class="language-java">consumer.subscribe(&quot;ons_test&quot;, &quot;*&quot;, new MessageListener() {
    public Action consume(Message message, ConsumeContext context) {
        String key = message.getKey()
        // 根据业务唯一标识的 key 做幂等处理
    }
});
</code></pre>
<p><strong>接下来，就需要根据业务进行处理：</strong></p>
<ul>
<li>拿个数据要写库，先根据主键查一下，如果这数据都有了，你就别插入了，只需要更新一下；或者可以设置一个唯一索引</li>
<li>如果是写Redis，每次操作都是set，天然可以保证幂等性</li>
<li>如果不是上面两种场景，需要让生产者发送每条数据的时候，里面<strong>加一个全局唯一的id</strong>，类似订单id之类的东西；**消费者需要先根据这个id去比如redis里查一下，之前消费过吗？**如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
</ul>
<h2 id="七-如何解决消息积压的问题">七、如何解决消息积压的问题？</h2>
<blockquote>
<p>这个可能出现在消费端出了问题，不消费了，或者消费的极其极其慢，导致大量的消息无法消费，最后消息队列集群的磁盘都快写满了</p>
</blockquote>
<p><strong>首先最重要的就是修复消费者，接着最大的问题就是在消费者重启后，如何快速处理积压的消息？</strong></p>
<ul>
<li>新建一个topic，临时建立好原先10倍或者20倍的queue数量</li>
<li>接着扩容临时的consumer，此时消费速度是原来的十几倍</li>
<li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li>
</ul>
<h3 id="八-如何设计一个mq">八、如何设计一个Mq？</h3>
<blockquote>
<p>是上面内容的一个总结，需要分点进行设计</p>
</blockquote>
<p><strong>扩展性</strong></p>
<ul>
<li>生产者的扩展性</li>
<li>消息队列的扩展性</li>
<li>消费者的扩展性</li>
</ul>
<p><strong>高可用性</strong></p>
<ul>
<li>如何设计刷盘策略？</li>
<li>如何保证消息0丢失？</li>
<li>如何保证在其中有机器宕机时，保障服务可用？</li>
</ul>
<p><strong>消息重试机制</strong></p>
<ul>
<li>当一个消息没有被消费时，如何进行重试，保证消息一定被消费？</li>
<li>当消费端不可用时，如何保证消费端重启后，依然可以消费消息？</li>
</ul>
<p><strong>心跳检测机制</strong></p>
<ul>
<li>如何检测生产者、消息队列和消费者是否宕机？</li>
</ul>
<p><strong>负载均衡模式</strong></p>
<ul>
<li>如何做到消息生产以及消费的负载均衡？</li>
</ul>
<p><strong>顺序消息</strong></p>
<ul>
<li>如何实现顺序消息？</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】JVM内存机制]]></title>
        <id>https://xzzz2020.github.io/post/YkvbP7GKA/</id>
        <link href="https://xzzz2020.github.io/post/YkvbP7GKA/">
        </link>
        <updated>2020-07-27T10:51:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9819683.html">JVM专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li>
<li><a href="#%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">二、程序计数器</a></li>
<li><a href="#%E4%B8%89-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">三、虚拟机栈</a>
<ul>
<li><a href="#%E9%97%AE%E9%A2%98%E8%BE%A8%E6%9E%90">问题辨析</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">四、本地方法栈</a></li>
<li><a href="#%E4%BA%94-%E5%A0%86">五、堆</a></li>
<li><a href="#%E5%85%AD-%E6%96%B9%E6%B3%95%E5%8C%BA">六、方法区</a></li>
<li><a href="#%E4%B8%83-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">七、运行时常量池</a></li>
<li><a href="#%E5%85%AB-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">八、直接内存</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简介">一、简介</h2>
<p>Java 虚拟机在执⾏ Java 程序的过程中会把它管理的内存划分成若⼲个不同的数据区域。 JDK. 1.8 和<br>
之前的版本略有不同</p>
<p><strong>jdk1.8之前</strong>：</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE1MTcwMjQxMTI1LnBuZw?x-oss-process=image/format,png" alt="image-20200715170241125" loading="lazy"></figure>
<p><strong>jdk1.8之后</strong>：</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE1MTcyNjIyNDUwLnBuZw?x-oss-process=image/format,png" alt="image-20200715172622450" loading="lazy"></figure>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h2 id="二-程序计数器">二、程序计数器</h2>
<blockquote>
<p>用来记住下一条指令的执行的地址，可以依次读取指令或者在多线程的时候，记录线程执行的位置，线程切换后，继续执行</p>
<p>是线程私有的，且不会出现内存溢出</p>
</blockquote>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h2 id="三-虚拟机栈">三、虚拟机栈</h2>
<blockquote>
<p>与程序计数器一样，Java 虚拟机栈也是线程私有的</p>
<p>描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的</p>
<p>每个虚拟栈中存放的是栈帧，每个栈帧对应着一次方法的调用，即每个方法需要的内存</p>
<p>方法执行时会入栈，所以栈顶的栈帧是正在执行的方法，方法执行结束或出现异常时，会出栈</p>
<p>当方法出现递归的时候，可能会造成栈帧过多，导致栈溢出</p>
</blockquote>
<p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h3 id="问题辨析">问题辨析</h3>
<ol>
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<blockquote>
<p>不需要<br>
每个方法执行后，都会被弹出栈，自动回收掉</p>
</blockquote>
<ol start="2">
<li>栈内存分配越大越好吗？</li>
</ol>
<blockquote>
<p>不是<br>
分配的越大，因为物理内存一定，会导致线程变少<br>
分配的更多，只是帮助更多次的递归调用</p>
</blockquote>
<ol start="3">
<li>方法内的局部变量是否线程安全？（<strong>看这个线程对变量是私有还是共享的</strong>）</li>
</ol>
<blockquote>
<p>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的<br>
如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全<br>
如果变量变成static类型，需要考虑线程安全</p>
</blockquote>
<h2 id="四-本地方法栈">四、本地方法栈</h2>
<blockquote>
<p>和虚拟机栈类似，只是用来存储native方法的栈帧</p>
</blockquote>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h2 id="五-堆">五、堆</h2>
<blockquote>
<p>是线程共享的，唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存</p>
<p>从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<p>由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等</p>
<p>这个是垃圾回收器主要负责回收的区域，当对象过大或者堆存储的对象过多时，就会进行垃圾回收，如果回收失败，最终户出现堆溢出</p>
<p>一个线程出现堆溢出，这个线程就会关闭，并且回收该线程创建的对象，此时JVM还没有关闭；如果其他线程在创建对象时，关闭线程并没有释放掉大量的堆空间，会导致其他线程也出现堆溢出，最终导致JVM关闭</p>
</blockquote>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE1MTc0NzQ1NjcwLnBuZw?x-oss-process=image/format,png" alt="image-20200715174745670" loading="lazy"></figure>
<h2 id="六-方法区">六、方法区</h2>
<p>⽅法区与 Java 堆⼀样，是各个线程共享的内存区域，它⽤于存储已被虚拟机加载的类信息、常量、静<br>
态变量、即时编译器编译后的代码等数据。</p>
<h2 id="七-运行时常量池">七、运行时常量池</h2>
<p>运⾏时常量池是⽅法区的⼀部分。 Class ⽂件中除了有类的版本、字段、⽅法、接口等描述信息外，还<br>
有常量池信息（⽤于存放编译期⽣成的各种字⾯量和符号引⽤）</p>
<p>既然运行时常量池时方法区的⼀部分，自然受到⽅法区内存的限制，当常量池无法再申请到内存时会抛<br>
出 OutOfMemoryError 异常。</p>
<blockquote>
<ol>
<li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<h2 id="八-直接内存">八、直接内存</h2>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzIwMjAwMzIwMTgyODI4NDg3LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzIwMjAwMzIwMTgzMTM2NDc5LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
]]></content>
    </entry>
</feed>