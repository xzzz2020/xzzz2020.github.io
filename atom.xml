<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-07-26T10:53:56.585Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[【总结】Redis持久化]]></title>
        <id>https://xzzz2020.github.io/post/Y_OlIRTju/</id>
        <link href="https://xzzz2020.github.io/post/Y_OlIRTju/">
        </link>
        <updated>2020-07-26T10:51:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_10005022.html">Redis专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89">一、持久化的意义</a></li>
<li><a href="#%E6%8C%81%E4%B9%85%E5%8C%96%E8%AF%A6%E8%A7%A3">持久化详解</a>
<ul>
<li><a href="#1-rdb%E5%92%8Caof%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D">1、RDB和AOF两种持久化机制的介绍</a></li>
<li><a href="#2-rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9">2、RDB持久化机制的优点</a></li>
<li><a href="#3-rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9">3、RDB持久化机制的缺点</a></li>
<li><a href="#4-aof%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9">4、AOF持久化机制的优点</a></li>
<li><a href="#5-aof%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9">5、AOF持久化机制的缺点</a></li>
<li><a href="#6-rdb%E5%92%8Caof%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">6、RDB和AOF到底该如何选择</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>主要解决以下问题：</p>
<ul>
<li>
<p>redis的持久化，RDB，AOF，区别，各自的特点是什么，适合什么场景</p>
</li>
<li>
<p>redis的企业级的持久化方案是什么，是用来跟哪些企业级的场景结合起来使用的？？？</p>
</li>
</ul>
</blockquote>
<h2 id="一-持久化的意义">一、持久化的意义</h2>
<p>比如你部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据</p>
<p>如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据</p>
<p>如果通过持久化将数据搞一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的</p>
<h2 id="持久化详解">持久化详解</h2>
<h3 id="1-rdb和aof两种持久化机制的介绍">1、RDB和AOF两种持久化机制的介绍</h3>
<p>RDB持久化机制，对redis中的数据执行周期性的持久化</p>
<p>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</p>
<p>如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制</p>
<p>通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云，云服务</p>
<p>如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务</p>
<p>如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。</p>
<h3 id="2-rdb持久化机制的优点">2、RDB持久化机制的优点</h3>
<p>（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据</p>
<p>（2）RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</p>
<p>（3）相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速</p>
<h3 id="3-rdb持久化机制的缺点">3、RDB持久化机制的缺点</h3>
<p>（1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据</p>
<p>（2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</p>
<h3 id="4-aof持久化机制的优点">4、AOF持久化机制的优点</h3>
<p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据</p>
<p>（2）AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复</p>
<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p>
<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
<h3 id="5-aof持久化机制的缺点">5、AOF持久化机制的缺点</h3>
<p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>
<p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>
<h3 id="6-rdb和aof到底该如何选择">6、RDB和AOF到底该如何选择</h3>
<p>（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据</p>
<p>（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug</p>
<p>（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】跳跃表]]></title>
        <id>https://xzzz2020.github.io/post/MiE8tJSYr/</id>
        <link href="https://xzzz2020.github.io/post/MiE8tJSYr/">
        </link>
        <updated>2020-07-26T10:49:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_10005022.html">Redis专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E8%A1%A8">一、为什么要使用跳跃表？</a></li>
<li><a href="#%E4%BA%8C-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8">二、什么是跳跃表？</a></li>
<li><a href="#%E4%B8%89-redis%E5%AE%9E%E7%8E%B0">三、Redis实现</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-为什么要使用跳跃表">一、为什么要使用跳跃表？</h2>
<p>Zset要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树/ 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p>
<ul>
<li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部</li>
<li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li>
<li><strong>大小考虑</strong>：平衡树结构更复杂，占的空间更多，而跳跃表相对简单</li>
</ul>
<h2 id="二-什么是跳跃表">二、什么是跳跃表？</h2>
<p>对于一个普通链表，需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，通常我们会使用 <strong>二分查找法</strong>，但二分查找是有序数组的，链表没办法进行位置定位，我们除了遍历整个找到第一个比给定数据大的节点为止 <em>（时间复杂度 O(n))</em> 似乎没有更好的办法。</p>
<p><strong>假如我们每相邻两个节点之间就增加一个指针，让指针指向下下一个节点，如图所示</strong>：</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzc4OTY4OTAtOGNhZTJjMjYxYzk1MGIzMi5wbmc?x-oss-process=image/format,png" alt="img" loading="lazy"></figure>
<ul>
<li>这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半</li>
</ul>
<p>现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，比如，我们想要查找 7，查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的：</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2JiZjUwYTNlLWYxM2UtNDlmZi04MmRmLTM0OGRiZjNiMTE2NS5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<ul>
<li>通过新增加的指针查找，我们不再需要与链表上的每一个节点逐一进行比较，这样改进之后需要比较的节点数大概只有原来的一半</li>
</ul>
<p>利用同样的方式，我们可以在新产生的链表上，继续为每两个相邻的节点增加一个指针，从而产生第三层链表：</p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2EyM2NjZTQ5LTEyYjgtNDkwMC1hNjhhLTEwM2E3OTEzNGNhMi5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<ul>
<li>在这个新的三层链表结构中，我们试着 <strong>查找 13</strong>，那么沿着最上层链表首先比较的是 11，发现 11 比 13 小，于是我们就知道只需要到 11 后面继续查找，<strong>从而一下子跳过了 11 前面的所有节点。</strong></li>
</ul>
<p>可以想象，当链表足够长，这样的多层链表结构可以帮助我们跳过很多下层节点，从而加快查找的效率，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 O(logn)。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的 2:1 的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点 （也包括新插入的节点） 重新进行调整，这会让时间复杂度重新蜕化成 O(n)。删除数据也有同样的问题。</p>
<p>为了避免这一问题，不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是 <strong>为每个节点随机出一个层数(level)</strong>。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中。</p>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzdiODRlYTJiLWM1OGItNDZhMi1hYzA1LTUwMTRkZjdkMGM4MS5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<p>从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，<strong>插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整</strong>，这就降低了插入操作的复杂度。</p>
<p>现在我们假设从我们刚才创建的这个结构中查找 23 这个不存在的数，那么查找路径会如下图：</p>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzVjYjM2YTY4LWE1ZTEtNDgzYi1hYzY5LWUwNWYzOTE0ZDA4NS5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<h2 id="三-redis实现">三、Redis实现</h2>
<ul>
<li><strong>随机层数</strong>：对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数，Redis 跳跃表默认允许最大的层数是 32</li>
<li><strong>插入节点实现</strong>：1.找到当前我需要插入的位置 ，其中包括相同 score 时的处理，如果值相同，则比较value值，是一个字符串的比较；2.创建新节点，调整前后的指针指向，完成插入</li>
<li><strong>元素排名的实现</strong>：跳跃表本身是有序的，Redis 在 skiplist 的 forward 指针上进行了优化，给每一个 forward 指针都增加了 <code>span</code> 属性，用来表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】网络原理]]></title>
        <id>https://xzzz2020.github.io/post/SfR2cO5PD/</id>
        <link href="https://xzzz2020.github.io/post/SfR2cO5PD/">
        </link>
        <updated>2020-07-26T10:47:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bosi%E5%92%8Ctcpip%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E5%88%86%E5%88%AB%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE">一、简单介绍一下OSI和TCP/IP结构和功能，分别用到哪些协议？</a>
<ul>
<li><a href="#1-%E5%BA%94%E7%94%A8%E5%B1%82">1. 应用层</a></li>
<li><a href="#2-%E8%BF%90%E8%BE%93%E5%B1%82">2. 运输层</a></li>
<li><a href="#3-%E7%BD%91%E7%BB%9C%E5%B1%82">3. 网络层</a></li>
<li><a href="#4-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">4. 数据链路层</a></li>
<li><a href="#5-%E7%89%A9%E7%90%86%E5%B1%82">5. 物理层</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">二、TCP 三次握手和四次挥手</a>
<ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">1. 为什么要三次握手？</a></li>
<li><a href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">2. 为什么要四次挥手？</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB">三、TCP和UDP的区别</a></li>
<li><a href="#%E5%9B%9B-tcp-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">四、TCP 协议如何保证可靠传输</a>
<ul>
<li><a href="#41-%E8%BF%9E%E7%BB%ADarq%E5%8D%8F%E8%AE%AE">4.1 连续ARQ协议</a></li>
<li><a href="#42-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.2  滑动窗口和流量控制</a></li>
<li><a href="#43-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">4.3 拥塞控制</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B">五、 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</a></li>
<li><a href="#%E5%85%AD-%E7%8A%B6%E6%80%81%E7%A0%81">六、状态码</a></li>
<li><a href="#%E4%B9%9D-%E5%90%84%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%85%B3%E7%B3%BB">九、各协议与HTTP协议的关系</a></li>
<li><a href="#%E5%8D%81-http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5">十、HTTP长连接和短连接</a></li>
<li><a href="#%E5%8D%81%E4%B8%80-cookie%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%92%8Csession%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">十一、Cookie的作用是什么?和Session有什么区别？</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C-http-10%E5%92%8Chttp-11%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">十二、HTTP 1.0和HTTP 1.1的主要区别是什么?</a></li>
<li><a href="#%E5%8D%81%E4%B8%89-uri%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">十三、URI和URL的区别是什么?</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B-http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB">十四、HTTP 和 HTTPS 的区别？</a></li>
<li><a href="#%E5%8D%81%E4%BA%94-http20">十五、HTTP/2.0</a>
<ul>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82">二进制分帧层</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81">服务端推送</a></li>
<li><a href="#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9">首部压缩</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%85%AD-get%E5%92%8Cpost%E7%9A%84%E6%AF%94%E8%BE%83">十六、GET和POST的比较</a></li>
<li><a href="#%E5%8D%81%E4%B8%83-socket%E7%AE%80%E4%BB%8B">十七、Socket简介</a>
<ul>
<li><a href="#1-socket%E7%9A%84%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B">1. Socket的通讯流程</a></li>
<li><a href="#2-%E5%88%A9%E7%94%A8java%E5%AE%9E%E7%8E%B0socket%E5%AE%9E%E7%8E%B0tcp%E5%92%8Cudp">2. 利用Java实现Socket实现TCP和UDP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-简单介绍一下osi和tcpip结构和功能分别用到哪些协议">一、简单介绍一下OSI和TCP/IP结构和功能，分别用到哪些协议？</h2>
<p>一般我们采用折中的思想，将计算系网络分为五层：</p>
<ul>
<li><strong>应用层</strong></li>
<li><strong>运输层</strong></li>
<li><strong>网络层</strong></li>
<li><strong>数据链路层</strong></li>
<li><strong>物理层</strong></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzIyMTMyMDQyOTk0LnBuZw?x-oss-process=image/format,png" alt="image-20200722132042994" loading="lazy"></figure>
<h3 id="1-应用层">1. 应用层</h3>
<ul>
<li>**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</li>
</ul>
<p><strong>常用的协议有</strong>：</p>
<ul>
<li>域名系统DNS协议</li>
<li>支持万维网应用的 <strong>HTTP协议</strong></li>
<li>支持电子邮件的 <strong>SMTP协议</strong></li>
</ul>
<p><strong>简单介绍一下DNS协议</strong></p>
<ul>
<li>负责将IP地址和域名相互映射，这样人们不需要记住复杂的IP地址，而只需要记住方便记忆的域名即可</li>
</ul>
<p><strong>简单介绍一下Http协议</strong></p>
<ul>
<li>
<p>所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
</li>
<li>
<p>支持客户/服务器模式，客户端可以发送请求，服务器会相应请求并返回数据</p>
</li>
</ul>
<h3 id="2-运输层">2. 运输层</h3>
<ul>
<li><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。</li>
</ul>
<p><strong>常用协议</strong>：</p>
<ul>
<li><strong>传输控制协议 TCP</strong>：面向连接的、可靠的</li>
<li><strong>用户数据协议 UDP</strong>：面向无连接的、不可靠的</li>
</ul>
<h3 id="3-网络层">3. 网络层</h3>
<ul>
<li><strong>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong></li>
</ul>
<p><strong>常用协议</strong>：</p>
<ul>
<li><strong>IP协议</strong></li>
</ul>
<h3 id="4-数据链路层">4. 数据链路层</h3>
<ul>
<li><strong>两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong></li>
</ul>
<h3 id="5-物理层">5. 物理层</h3>
<ul>
<li><strong>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong></li>
</ul>
<h2 id="二-tcp-三次握手和四次挥手">二、TCP 三次握手和四次挥手</h2>
<h3 id="1-为什么要三次握手">1. 为什么要三次握手？</h3>
<ul>
<li>
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
</li>
<li>
<p>第一次握手:建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_ SEND状态,等待服务器确认;</p>
</li>
<li>
<p>第二次握手:服务器收到SYN 包,必须确认客户的SYN(ack=j+1) ,同时自己也发送一个SYN包(syn=k) ,即<br>
SYN+ACK包，此时服务器进入SYN_RECV状态:</p>
</li>
<li>
<p>第三次握手:客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手。</p>
</li>
</ul>
<p><strong>目的是</strong>：为了初始化Sequence Number的初始值，同时保证建立可靠的连接</p>
<blockquote>
<p>SYN和ACK中的Sequence Number初始化使用了随机值，而每个包都有个序号，超时重传机制根据这个序号来判断确认收到了是哪个包。在三次握手的时候，告诉了对方初始化的序号是多少，这样就可以根据序号对应接下来哪些包收到了。</p>
</blockquote>
<p><strong>首次握手的隐患---SYN超时</strong></p>
<ul>
<li>Server收到Client的SYN ,回复SYN-ACK的时候未收到ACK确认</li>
<li>Server不断重试直至超时, Linux默认等待63秒才断开连接</li>
<li>可能会遭到SYN Flood攻击，即恶意用户发送一个SYN后，就下线，让服务端等到63秒，最后导致SYN等待队列被占满，无法和正常的用户建立连接</li>
</ul>
<p><strong>针对SYN Flood的防护措施</strong></p>
<ul>
<li>SYN队列满后,通过tcp_syncookies参数回发SYN Cookie</li>
<li>若为正常连接则Client会回发SYN Cookie ,直接根据cookie建立连接，不会因为队列满而无法建立连接；如果是恶意用户，则不会发送Cookie</li>
</ul>
<p><strong>建立连接后, Client出现故障怎么办？</strong></p>
<ul>
<li><strong>保护机制</strong>：向对方发送保活探测报文,如果未收到响应则继续发送，尝试次数达到保活探测数仍未收到响应则中断连接</li>
</ul>
<p><strong>下面是三次握手的含义</strong>：</p>
<ul>
<li>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
</li>
<li>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
</li>
<li>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzIyMTMzNjQ1NDg3LnBuZw?x-oss-process=image/format,png" alt="image-20200722133645487" loading="lazy"></figure>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK  应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP  连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="2-为什么要四次挥手">2. 为什么要四次挥手？</h3>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzIyMTMzODU3OTMzLnBuZw?x-oss-process=image/format,png" alt="image-20200722133857933" loading="lazy"></figure>
<blockquote>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B  跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束</p>
</blockquote>
<p><strong>服务器出现大量CLOSE_WAIT状态的原因？</strong></p>
<ul>
<li>可能浏览器发送关闭请求后，服务器在忙于读写</li>
<li>也可能代码出现了问题，特别是释放资源的代码忘记释放了资源</li>
</ul>
<h2 id="三-tcp和udp的区别">三、TCP和UDP的区别</h2>
<ul>
<li>TCP是面向连接，需要通过三次握手建立可靠连接，而UDP是面向无连接的</li>
<li><strong>可靠性</strong>：TCP有ARQ协议、超时重传等，可以保证其可靠性，而UDP没有这些东西，只是尽最大努力交付,不保证可靠交付</li>
<li><strong>有序性</strong>：TCP利用序列号可以保证其有序性，到达可能无序，最后会进行排序，而UDP无法保证有序性</li>
<li><strong>速度</strong>：TCP比较复杂所以比减慢，UDP比较快</li>
<li><strong>量级</strong>：TCP报文是20个字节，UDP报文是8个字节</li>
</ul>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="四-tcp-协议如何保证可靠传输">四、TCP 协议如何保证可靠传输</h2>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP  连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="41-连续arq协议">4.1 连续ARQ协议</h3>
<p>对于ARQ协议，如果每个数据报都发送确认收到，将十分消耗网络资源，在此问题上，提出了连续ARQ协议：</p>
<ul>
<li>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</li>
</ul>
<h3 id="42-滑动窗口和流量控制">4.2  滑动窗口和流量控制</h3>
<ul>
<li>
<p><strong>RTT</strong>：发送一个数据包到收到对应的ACK ,所花费的时间</p>
</li>
<li>
<p><strong>RTO</strong>：重传时间间隔，将根据RTT进行改变</p>
</li>
</ul>
<p><strong>滑动窗口的作用</strong>：</p>
<ul>
<li>
<p><strong>保证TCP的可靠性</strong>：采用ARQ协议和超时重传机制保证可靠性</p>
</li>
<li>
<p><strong>实现流量控制</strong>：TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
</li>
</ul>
<h3 id="43-拥塞控制">4.3 拥塞控制</h3>
<ul>
<li>
<p>当网络比较拥堵时，会控制发送数据的速度，防止发送较大的文件导致网络瘫痪</p>
</li>
<li>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
</li>
</ul>
<p><strong>有四种算法</strong>：</p>
<ul>
<li><strong>慢开始：</strong>  慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and  recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP  将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了  FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="五-在浏览器中输入url地址-显示主页的过程">五、 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h2>
<p><strong>总体来说分为以下几个过程</strong>:</p>
<ol>
<li>浏览器解析域名查找IP地址，使用的协议是DNS协议，DNS过程为：浏览器缓存、路由器缓存、DNS缓存</li>
<li>与服务器三次握手建立TCP连接（在建立TCP协议时，需要发送数据，需要使用IP协议、IP数据包在路由器之间传输，路由器的选择使用的OSPF协议、路由器和服务器通信时，需要将IP地址转换成MAC地址，需要用到ARP协议）</li>
<li>向服务器发送HTTP请求</li>
<li>服务器处理请求并返回HTTP响应</li>
<li>可能会释放TCP连接，这取决于HTTP版本</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h2 id="六-状态码">六、状态码</h2>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzIyMTM1NTI2NzY3LnBuZw?x-oss-process=image/format,png" alt="image-20200722135526767" loading="lazy"></figure>
<p><strong>1XX 信息</strong>：</p>
<ul>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
<p><strong>2XX 成功</strong>“：</p>
<ul>
<li><strong>200 OK</strong></li>
<li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<p><strong>3XX 重定向</strong>：</p>
<ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。<br>
注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-NoneMatch，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的<br>
POST 方法改成 GET 方法。</li>
</ul>
<p><strong>4XX 客户端错误</strong>：</p>
<ul>
<li>**400 Bad Request ：**请求报文中存在语法错误。</li>
<li>**401 Unauthorized ：**该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝，比如说IP被禁止</li>
<li><strong>404 Not Found</strong>：可能输入错误了URL</li>
</ul>
<p><strong>5XX 服务器错误</strong>：</p>
<ul>
<li>**500 Internal Server Error ：**服务器正在执行请求时发生错误。</li>
<li>**503 Service Unavailable ：**服务器暂时处于超负载或正在进行停机维护，现在无法处理请求，可能连接池满了或者服务器宕机</li>
</ul>
<h2 id="九-各协议与http协议的关系">九、各协议与HTTP协议的关系</h2>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzIyMTM1NjE2MDA1LnBuZw?x-oss-process=image/format,png" alt="image-20200722135616005" loading="lazy"></figure>
<h2 id="十-http长连接和短连接">十、HTTP长连接和短连接</h2>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<pre><code>Connection:keep-alive
</code></pre>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<h2 id="十一-cookie的作用是什么和session有什么区别">十一、Cookie的作用是什么?和Session有什么区别？</h2>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie  中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token  重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="十二-http-10和http-11的主要区别是什么">十二、HTTP 1.0和HTTP 1.1的主要区别是什么?</h2>
<ol>
<li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong>  :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>  :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="十三-uri和url的区别是什么">十三、URI和URL的区别是什么?</h2>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<h2 id="十四-http-和-https-的区别">十四、HTTP 和 HTTPS 的区别？</h2>
<blockquote>
<p>如果有恶意的软件劫持了用户发送的请求，最后模仿服务器向浏览器发送响应，浏览器是无法识别的，这就是劫持。</p>
</blockquote>
<ol>
<li>
<p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li>
<p>HTTPS需要到CA申请证书，HTTP不需要</p>
</li>
<li>
<p><strong>安全性和资源消耗</strong>：</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有  HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
<li>哈希算法:将任意长度的信息转换为固定长度的值,算法不可逆，比如说MD5算法</li>
</ul>
</li>
</ol>
<blockquote>
<p>SSL(Security Sockets Layer ,安全套接层)</p>
<ul>
<li>
<p>为网络通信提供安全及数据完整性的一-种安全协议</p>
</li>
<li>
<p>是操作系统对外的API , SSL3.0后更名为TLS</p>
</li>
<li>
<p>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p>
</li>
</ul>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200722173112251.png" alt="image-20200722173112251" style="zoom:50%;" />
<p><strong>HTTPS真的很安全吗?</strong></p>
<ul>
<li>浏览器默认填充http:// ，请求到服务器后需要进行https的跳转，在建立起HTTPS连接之前存在一次明文的HTTP请求和重定向，有被劫持的风险</li>
<li>可以使用HSTS ( HTTP Strict Transport Security )优化</li>
</ul>
<blockquote>
<p>HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。 HSTS最为核心的是一个HTTP响应头（HTTP Response Header），正是它可以让浏览器得知，在接下来的一段时间内，当前域名只能通过HTTPS进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。</p>
<p>比如设置在第一次HTTP连接中，得知要在接下来1年内在个对于当前域名及其子域名的后续通信应该强制性的只使用HTTPS，直到超过有效期为止。</p>
<p>同时，第一次的HTTP连接也可能会被劫持，所以浏览器中可以内置一个列表，放入那些必须使用https的域名，保证安全性</p>
</blockquote>
<h2 id="十五-http20">十五、HTTP/2.0</h2>
<p><strong>HTTP/1.x 缺陷，HTTP/1.x 实现简单是以牺牲性能为代价的</strong></p>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<h3 id="二进制分帧层">二进制分帧层</h3>
<ul>
<li>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</li>
</ul>
<h3 id="服务端推送">服务端推送</h3>
<ul>
<li>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</li>
</ul>
<h3 id="首部压缩">首部压缩</h3>
<ul>
<li>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</li>
<li>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。<br>
不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</li>
</ul>
<h2 id="十六-get和post的比较">十六、GET和POST的比较</h2>
<ul>
<li><strong>作用不同</strong>：GET 用于获取资源，而 POST 用于传输实体主体。</li>
<li><strong>参数不同</strong>：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，URL长度可能会受到浏览器的限制，而 POST 的参数存储在实体主体中，长度没有限制。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</li>
<li><strong>安全和幂等性</strong>：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的，而幂等性指同样的请求被执行一次与连续执行多次的效果是一样的  。GET 方法是安全的也是幂等的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</li>
<li><strong>缓存</strong>：GET请求可以被缓存、被存储，保存在浏览器上，而POST是非幂等的，所以必须交由服务器处理</li>
</ul>
<h2 id="十七-socket简介">十七、Socket简介</h2>
<ul>
<li>Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口</li>
</ul>
<h3 id="1-socket的通讯流程">1. Socket的通讯流程</h3>
<figure data-type="image" tabindex="6"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzIyMTc1MTU5OTQ0LnBuZw?x-oss-process=image/format,png" alt="image-20200722175159944" loading="lazy"></figure>
<h3 id="2-利用java实现socket实现tcp和udp">2. 利用Java实现Socket实现TCP和UDP</h3>
<p><strong>TCPServer</strong></p>
<pre><code class="language-java">public class TCPServer {
    public static void main(String[] args) throws IOException {
        //创建socket,并将socket绑定到65000端口
        ServerSocket ss = new ServerSocket(65000);
        //死循环，使得socket一直等待并处理客户端发送过来的请求
        while (true) {
            //监听65000端口，直到客户端返回连接信息后才返回
            Socket socket = ss.accept();
            //获取客户端的请求信息后，执行相关业务逻辑
            new LengthCalculator(socket).start();
        }
    }
}
</code></pre>
<p><strong>LengthCalculator</strong></p>
<pre><code class="language-java">public class LengthCalculator extends Thread {
    private Socket socket;

    public LengthCalculator(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            //获取socket的输出流
            OutputStream os = socket.getOutputStream();
            //获取socket的输入流
            InputStream is = socket.getInputStream();
            int ch;
            byte[] buff = new byte[1024];
            //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
            ch = is.read(buff);
            //将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过来的字符串
            String content = new String(buff, 0, ch);
            System.out.println(content);
            //往输出流里写入获得的字符串的长度，回发给客户端
            os.write(String.valueOf(content.length()).getBytes());
            //不要忘记关闭输入输出流以及socket
            is.close();
            os.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>TCPClient</strong></p>
<pre><code class="language-java">public class TCPClient {
    public static void main(String[] args) throws IOException {
        //创建socket，并指定连接的是本机的端口号为65000的服务器socket
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 65000);
        //获取输出流
        OutputStream os = socket.getOutputStream();
        //获取输入流
        InputStream is = socket.getInputStream();
        //将要传递给server的字符串参数转换成byte数组，并数组写入到输出流中
        os.write(&quot;hello world&quot;.getBytes());
        int ch;
        byte[] buff = new byte[1024];
        //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
        ch = is.read(buff);
        //将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度
        String content = new String(buff, 0, ch);
        System.out.println(content);
        //不要忘记关闭输入输出流以及socket
        is.close();
        os.close();
        socket.close();
    }
}
</code></pre>
<p><strong>UDPServer</strong></p>
<pre><code class="language-java">public class UDPServer {
    public static void main(String[] args) throws IOException {
        //服务端接受客户端发送的数据报
        DatagramSocket socket = new DatagramSocket(65001); //监听的端口号
        byte[] buff = new byte[100]; //存储从客户端接受到的内容
        DatagramPacket packet = new DatagramPacket(buff, buff.length);
        //接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中
        socket.receive(packet);
        byte[] data = packet.getData(); //从DatagramPacket对象 中获取到真正存储的数据
        //将数据从二进制转换成字符串形式
        String content = new String(data, 0, packet.getLength());
        System.out.println(content);
        //将要发送给客户端的数据转换成二进制
        byte[] sendedContent = String.valueOf(content.length()).getBytes();
        //服务端给客户端发送数据报
        //从DatagramPacket对象中获取到数据的来源地址与端口号
        DatagramPacket packetToClient = new DatagramPacket(sendedContent,
                sendedContent.length, packet.getAddress(), packet.getPort());
        socket.send(packetToClient); //发送数据给客户端
    }
}
</code></pre>
<p><strong>UDPClient</strong></p>
<pre><code class="language-java">public class UDPClient {
    public static void main(String[] args) throws IOException {
        //客户端发数据报给服务端
        DatagramSocket socket = new DatagramSocket();
        //要发送给服务端的数据
        byte[] buf = &quot;Hello World&quot;.getBytes();
        //将IP地址封装成InetAddress对象
        InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);
        //将要发送给服务端的数据封装成DatagramPacket对象需要填写上ip地址与端口号
        DatagramPacket packet = new DatagramPacket(buf, buf.length, address,
                65001);
        //发送数据给服务端
        socket.send(packet);
        //客户端接受服务端发送过来的数据报
        byte[] data = new byte[100];
        //创建DtagramPacket对 象用来存储服务端发送过来的数据
        DatagramPacket receivedPacket = new DatagramPacket(data, data.length);
        //将接受到的数据存储到DatagramPacket对象中
        socket.receive(receivedPacket);
        //将服务器端发送过来的数据取出来并打印到控制台
        String content = new String(receivedPacket.getData(), 0,
                receivedPacket.getLength());
        System.out.println(content);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】SQL语句]]></title>
        <id>https://xzzz2020.github.io/post/B4oG0L7Z4/</id>
        <link href="https://xzzz2020.github.io/post/B4oG0L7Z4/">
        </link>
        <updated>2020-07-26T10:45:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">一、常用数据处理函数</a>
<ul>
<li><a href="#1-substr">1. substr</a></li>
<li><a href="#2-trim">2. trim</a></li>
<li><a href="#3-ifnull">3. ifnull</a></li>
<li><a href="#4-case-when-then-else-end">4. case … when … then … else ... end</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">二、常用聚合函数</a></li>
<li><a href="#%E4%B8%89-%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2">三、分组查询</a>
<ul>
<li><a href="#1-group-by">1. group by</a></li>
<li><a href="#2-having">2. having</a></li>
<li><a href="#3-select-%E8%AF%AD%E5%8F%A5%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93">3. select 语句顺序总结</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E9%87%8D%E7%82%B9">四、连接查询（重点）</a>
<ul>
<li><a href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB">内连接外连接的区别？</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8">五、视图的作用</a></li>
<li><a href="#%E5%85%AD-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">六、如何创建删除索引？</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-常用数据处理函数">一、常用数据处理函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>substr</td>
<td>取子串（substr(被截取的字符串,起始下标,截取的长度)）</td>
</tr>
<tr>
<td>trim</td>
<td>去空</td>
</tr>
<tr>
<td>Ifnull</td>
<td>可以将 null 转换成一个具体值</td>
</tr>
<tr>
<td>case … when … then … else ... end</td>
<td>多个条件判断</td>
</tr>
</tbody>
</table>
<h3 id="1-substr">1. substr</h3>
<p>查询姓名以 M 开头所有的员工</p>
<pre><code class="language-sql">select * from emp where substr(ename, 1, 1)=upper('m');
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE0MTA1NTQxNjgwLnBuZw?x-oss-process=image/format,png" alt="image-20200714105541680" loading="lazy"></figure>
<h3 id="2-trim">2. trim</h3>
<p><code>会去首尾空格，不会去除中间的空格</code></p>
<p>取得工作岗位为 manager 的所有员工</p>
<pre><code class="language-sql">select * from emp where job=trim(upper('manager '));
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE0MTA1NTMzNDc1LnBuZw?x-oss-process=image/format,png" alt="image-20200714105533475" loading="lazy"></figure>
<h3 id="3-ifnull">3. ifnull</h3>
<pre><code class="language-sql">select ifnull(comm,0) from emp; 
</code></pre>
<p>如果 comm 为 null 就替换为 0 在 SQL 语句当中若有 NULL 值参与数学运算，计算结果一定是 NULL 为了防止计算结果出现 NULL，建议先使用 ifnull 空值处理函数预先处理。 以下 SQL 是计算年薪的：</p>
<pre><code class="language-sql">select empno,ename,sal,(sal+ifnull(comm,0))*12 as yearsal from emp;  
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE0MTEwMDExOTE4LnBuZw?x-oss-process=image/format,png" alt="image-20200714110011918" loading="lazy"></figure>
<h3 id="4-case-when-then-else-end">4. case … when … then … else ... end</h3>
<p>如果 job 为 MANAGERG 薪水上涨 10%,如果 job 为 SALESMAN 工资上涨 50%</p>
<pre><code class="language-sql">select empno, ename, job, sal, case job when 'MANAGER' then sal*1.1 when 'SALESMAN' then sal*1.5 end as newsal from emp;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE0MTA1NzA5NzUxLnBuZw?x-oss-process=image/format,png" alt="image-20200714105709751" loading="lazy"></figure>
<p>其他的工资不动，需要加else</p>
<pre><code class="language-sql">select e.*,sal ,case job when 'salesman' then sal*1.1 when 'clerk' then sal*1.2 else sal end as new_sal from emp e;
</code></pre>
<h2 id="二-常用聚合函数">二、常用聚合函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>取得记录数</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td>avg</td>
<td>取平均</td>
</tr>
<tr>
<td>max</td>
<td>取最大的数</td>
</tr>
<tr>
<td>min</td>
<td>取最小的数</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<ul>
<li>分组函数自动忽略空值，不需要手动的加 where 条件排除空值。</li>
<li>select count(*) from emp where xxx; 符合条件的所有记录总数。</li>
<li>select count(comm) from emp; comm 这个字段中不为空的元素总数。</li>
<li>聚合函数不能直接使用在 where 关键字后面。</li>
</ul>
<h2 id="三-分组查询">三、分组查询</h2>
<h3 id="1-group-by">1. group by</h3>
<p>取得每个工作岗位的工资合计，要求显示岗位名称和工资合计</p>
<pre><code class="language-sql">select job, sum(sal) from emp group by job;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE0MTEwOTE0MjE4LnBuZw?x-oss-process=image/format,png" alt="image-20200714110914218" loading="lazy"></figure>
<p><strong>注意</strong>：在 SQL 语句中若有 group by 语句，那么在 select 语句后面只能跟聚合函数+参与分组的字段。</p>
<p><strong>错误示范</strong>：<code>select empno,deptno,avg(sal) from emp group by deptno;</code></p>
<h3 id="2-having">2. having</h3>
<p>如果想对分组数据再进行过滤需要使用 having 子句</p>
<p>取得每个岗位的平均工资大于 2000</p>
<pre><code class="language-sql">select job, avg(sal) from emp group by job having avg(sal) &gt;2000;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE0MTExMTI0OTQxLnBuZw?x-oss-process=image/format,png" alt="image-20200714111124941" loading="lazy"></figure>
<h3 id="3-select-语句顺序总结">3. select 语句顺序总结</h3>
<pre><code class="language-sql">select 字段
from 表名
where …….
group by ……..
having …….(就是为了过滤分组后的数据而存在的—不可以单独的出现)
order by ……..
</code></pre>
<p><strong>语句的执行顺序</strong>：</p>
<ol>
<li>
<p>首先执行 where 语句过滤原始数据</p>
</li>
<li>
<p>执行 group by 进行分组</p>
</li>
<li>
<p>执行 having 对分组数据进行操作</p>
</li>
<li>
<p>执行 select 选出数据</p>
</li>
<li>
<p>执行 order by 排序</p>
</li>
</ol>
<p><strong>原则</strong>：能在 where 中过滤的数据，尽量在 where 中过滤，效率较高。 having 的过滤是专门对分组之后的数据进行过滤的。</p>
<h2 id="四-连接查询重点">四、连接查询（重点）</h2>
<p><code>也可以叫跨表查询， 需要关联多个表进行查询</code></p>
<blockquote>
<p>SQL99语法相比92语法，将连接条件和where分离</p>
</blockquote>
<h3 id="内连接外连接的区别">内连接外连接的区别？</h3>
<ul>
<li><strong>内连接</strong>：只有两张表相匹配的行才能出现在结果集</li>
<li><strong>外连接</strong>：左连接以左面的表为准和右边的表比较，和左表相等的不相等都会显示出来，右表符合条件的显示</li>
</ul>
<p><strong>内连接</strong></p>
<ul>
<li>表 1 inner join 表 2 on 关联条件</li>
<li>做连接查询的时候一定要写上关联条件</li>
<li>inner 可以省略</li>
</ul>
<p><strong>外连接</strong></p>
<ul>
<li>
<p>左外连接</p>
<ul>
<li>
<p>表 1 left outer join 表 2 on 关联条件</p>
</li>
<li>
<p>做连接查询的时候一定要写上关联条件</p>
</li>
<li>
<p>outer 可以省略</p>
</li>
</ul>
</li>
<li>
<p>右外连接</p>
<ul>
<li>
<p>表 1 right outer join 表 2 on 关联条件</p>
</li>
<li>
<p>做连接查询的时候一定要写上关联条件</p>
</li>
<li>
<p>outer 可以省略</p>
<ul>
<li>左外连接（左连接）和右外连接（右连接）的区别：</li>
<li>左连接以左面的表为准和右边的表比较，和左表相等的不相等都会显示出来，右表符合条件的显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>左外连接（左连接）和右外连接（右连接）的区别</strong>：</p>
<ul>
<li>左连接以左面的表为准和右边的表比较，和左表相等的不相等都会显示出来，右表符合条件的显示,不符合条件的不显示</li>
<li>右连接恰恰相反，以上左连接和右连接也可以加入 outer 关键字，但一般不建议这种写法</li>
</ul>
<h2 id="五-视图的作用">五、视图的作用</h2>
<ul>
<li>
<p>某些频繁使用的查询语句(如级联查询)，可能很复杂，可以利用视图<code>简化查询</code>，重用sql</p>
</li>
<li>
<p><code>保护数据</code>，只授予特定权限，如查询权限</p>
</li>
<li>
<p>视图本身不包含数据，<code>只是对sql语句的一个封装</code>，如果需要封装复杂的sql需要先测试性能</p>
</li>
<li>
<p>用于数据检索，不能更新数据</p>
</li>
</ul>
<h2 id="六-如何创建删除索引">六、如何创建删除索引？</h2>
<blockquote>
<p>修改索引需要先删除在添加</p>
</blockquote>
<ol>
<li>添加PRIMARY KEY（主键索引）</li>
</ol>
<pre><code>ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
</code></pre>
<ol start="2">
<li>添加UNIQUE(唯一索引)</li>
</ol>
<pre><code>ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
</code></pre>
<ol start="3">
<li>添加INDEX(普通索引)</li>
</ol>
<pre><code>ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
</code></pre>
<ol start="4">
<li>添加FULLTEXT(全文索引)</li>
</ol>
<pre><code>ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
</code></pre>
<ol start="5">
<li>添加多列索引</li>
</ol>
<pre><code>ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
</code></pre>
<ol start="6">
<li>删除索引</li>
</ol>
<pre><code class="language-sql">DROP INDEX login_name_index ON user;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】MySQL索引总结]]></title>
        <id>https://xzzz2020.github.io/post/EM2P_CVYa/</id>
        <link href="https://xzzz2020.github.io/post/EM2P_CVYa/">
        </link>
        <updated>2020-07-26T10:44:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E4%B8%BA%E4%BB%80%E5%B9%BA%E8%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95">一、为什幺要用索引？</a></li>
<li><a href="#%E4%BA%8C-%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2">二、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</a></li>
<li><a href="#%E4%B8%89-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">三、使用索引的注意事项？</a></li>
<li><a href="#%E5%9B%9B-%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88">四、索引什么时候会失效？</a></li>
<li><a href="#%E4%BA%94-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88">五、最左前缀原则是什么？</a></li>
<li><a href="#%E5%85%AD-mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">六、MySQL索引的主要数据结构</a>
<ul>
<li><a href="#1-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95">1. 哈希索引</a></li>
<li><a href="#2-b%E6%A0%91%E7%B4%A2%E5%BC%95">2. B+树索引</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6">七、为什么索引能提高查询速度？</a></li>
<li><a href="#%E5%85%AB-%E7%B4%A2%E5%BC%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B">八、索引都有哪些类型？</a>
<ul>
<li><a href="#1-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95primary-key">1. 主键索引(Primary Key)</a></li>
<li><a href="#2-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95">2. 二级索引(辅助索引)</a></li>
<li><a href="#3-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">3. 聚集索引</a></li>
<li><a href="#4-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95">4. 非聚集索引</a></li>
<li><a href="#5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">5. 覆盖索引</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D-%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8E%9F%E5%88%99">九、索引创建的原则</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-为什幺要用索引">一、为什幺要用索引？</h2>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免排序和临时表。</li>
<li>将随机IO变为顺序IO</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ol>
<h2 id="二-索引这么多优点为什么不对表中的每一个列创建一个索引呢">二、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h2>
<ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h2 id="三-使用索引的注意事项">三、使用索引的注意事项？</h2>
<ul>
<li>
<p>在经常需要搜索的列上，可以加快搜索的速度；</p>
</li>
<li>
<p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
</li>
<li>
<p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</p>
</li>
<li>
<p>在使用InnoDB时使用与业务无关的自增主键作为主键</p>
</li>
<li>
<p>避免索引失效</p>
</li>
</ul>
<h2 id="四-索引什么时候会失效">四、索引什么时候会失效？</h2>
<ul>
<li>
<p>有or关键字必须所有字段全有索引;</p>
</li>
<li>
<p>复合索引未用左列字段;</p>
</li>
<li>
<p>like以%开头</p>
</li>
<li>
<p>where中索引列有运算</p>
</li>
<li>
<p>where中索引列使用了函数</p>
</li>
<li>
<p>如果mysql觉得全表扫描更快时（数据少）</p>
</li>
</ul>
<h2 id="五-最左前缀原则是什么">五、最左前缀原则是什么？</h2>
<p>主要针对的聚合索引是否生效，假如有一个聚合索引ABC：</p>
<ul>
<li>最左边的列必须要用到，比如这个A列</li>
<li>中间是不能断的，如只查询了A和C列，只会用到C的索引</li>
<li>遇到范围后，终止，比如where条件是这样的，where  A = x and B &gt;y  and C = z，这个时候只会用到AB索引，无法使用C索引</li>
</ul>
<h2 id="六-mysql索引的主要数据结构">六、MySQL索引的主要数据结构</h2>
<h3 id="1-哈希索引">1. 哈希索引</h3>
<p>​	对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引</p>
<ul>
<li>因为Hash索引比较的是经过Hash计算的值，所以只能进行等式比较，不能用于范围查询</li>
<li>当哈希值大量重复且数据量非常大时，其检索效率并没有Btree索引高的</li>
<li>哈希值映射的真正数据在哈希表中就不一定按照顺序排列，所以无法利用Hash索引来加速任何排序操作</li>
</ul>
<h3 id="2-b树索引">2. B+树索引</h3>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE3MTc1NDMyNDA1LnBuZw?x-oss-process=image/format,png" alt="image-20200717175432405" loading="lazy"></figure>
<ul>
<li>
<p>为磁盘或其他直接存取的辅助设备而设计的平衡二叉树</p>
</li>
<li>
<p>所有的记录节点都是按照键值的大小<code>顺序存放</code>在同一层的叶节点</p>
</li>
<li>
<p>同时最后一层叶字节点之间存在指针，这样可以保证其是连续的数据排列</p>
</li>
</ul>
<p>​</p>
<p><strong>B+树相对于B树的区别？</strong></p>
<ul>
<li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了</li>
<li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li>
<li>所有的叶子节点形成了一个有序链表，更加便于查找。</li>
</ul>
<p><strong>B+树与红黑树的比较？</strong></p>
<ul>
<li><strong>更少的查找次数</strong>：平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</li>
<li><strong>利用磁盘预读特性</strong>：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入</li>
</ul>
<p><strong>B+数树和B-树的区别？</strong></p>
<ul>
<li>
<p>B+树相当于B-树的变种，主要差异在于B+树数据都保存在叶子节点，同时叶子节点之间形成了链表</p>
</li>
<li>
<p>B+树查询时间复杂度固定是logn，B-树查询复杂度最好是 O(1)</p>
</li>
<li>
<p>B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找</p>
</li>
</ul>
<p><strong>MyISAM和InnoDB实现BTree索引方式的区别？</strong></p>
<ul>
<li>
<p><strong>MyISAM</strong>：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
</li>
<li>
<p><strong>InnoDB</strong>：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。</p>
</li>
</ul>
<h2 id="七-为什么索引能提高查询速度">七、为什么索引能提高查询速度？</h2>
<p>MySQL底层每16k的数据为一页，一页中有多个记录值。</p>
<p>如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：</p>
<ol>
<li><strong>定位到记录所在的页：需要遍历双向链表，找到所在的页</strong></li>
<li><strong>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</strong></li>
</ol>
<p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。</p>
<p>使用了索引其实就是将无序的数据变成相对有序，其实底层结构就是B+树，B+树作为树的一种实现，时间复杂度近似为O(logn)，能够让我们很快地查找出对应的记录。</p>
<h2 id="八-索引都有哪些类型">八、索引都有哪些类型？</h2>
<h3 id="1-主键索引primary-key">1. 主键索引(Primary Key)</h3>
<ul>
<li>
<p>数据表的主键列使用的就是主键索引。</p>
</li>
<li>
<p>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</p>
</li>
<li>
<p>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</p>
</li>
</ul>
<h3 id="2-二级索引辅助索引">2. 二级索引(辅助索引)</h3>
<p>二级索引又称为辅助索引，是因为二级索引的叶子节点在InnoDB中存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置；在MyISAM中存储的数据是地址。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。**建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</li>
</ol>
<h3 id="3-聚集索引">3. 聚集索引</h3>
<p>聚集索引即索引结构和数据一起存放的索引。InnoDB存储引擎中主键索引属于聚集索引，B+树的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，可能涉及自旋操作维护平衡， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h3 id="4-非聚集索引">4. 非聚集索引</h3>
<p>非聚集索引即索引结构和数据分开存放的索引，比如说MyISAM中的索引保存的指向数据文件的指针。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>更新代价比聚集索引要小</strong>：非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p><strong>非聚集索引一定回表查询吗(覆盖索引)?</strong></p>
<ul>
<li>不一定。</li>
<li>虽然MYISAM的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</li>
<li>或者想要查询的字段刚好建立了索引，查到对应的字段直接返回就行了，无需回表查询</li>
</ul>
<h3 id="5-覆盖索引">5. 覆盖索引</h3>
<ul>
<li>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是先定位主键值，再定位行记录，它的性能较扫一遍索引树更低，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</li>
<li>假如索引是AB列，想要查询出来的列是AB+主键列，则此时是覆盖索引；而想要查询出来的列是ABC列，C的数据不在索引中，就需要回表。所以切忌使用Select *</li>
</ul>
<p><strong>总结：覆盖索引的优化及限制</strong></p>
<p><strong>优点</strong>：</p>
<p>1、索引项通常比记录要小，所以MySQL访问更少的数据。</p>
<p>2、索引都按值得大小存储，相对于随机访问记录，需要更少的I/O。</p>
<p>3、数据引擎能更好的缓存索引，比如MyISAM只缓存索引。</p>
<p>4、覆盖索引对InnoDB尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引包含查询所需的数据，就不再需要在聚集索引中查找了。</p>
<p><strong>限制：</strong></p>
<p>1、覆盖索引也并不适用于任意的索引类型，索引必须存储列的值。</p>
<p>2、Hash和full-text索引不存储值，因此MySQL只能使用BTree。</p>
<p>3、不同的存储引擎实现覆盖索引都是不同的，并不是所有的存储引擎都支持覆盖索引。</p>
<p>4、如果要使用覆盖索引，一定要注意SELECT列表值取出需要的列，不可以SELECT * ，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>
<h2 id="九-索引创建的原则">九、索引创建的原则</h2>
<p><strong>最左前缀原则</strong>：</p>
<ul>
<li>虽然我目前的Mysql版本较高，好像不遵守最左前缀原则，索引也会生效。 但是我们仍应遵守最左前缀原则，以免版本更迭带来的麻烦。</li>
</ul>
<p><strong>选择合适的字段</strong></p>
<ol>
<li>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用默认值。</li>
<li>我们创建索引的字段应该是查询操作非常频繁的字段，而不是增删改比较多的。</li>
<li>被作为WHERE条件查询的字段，应该被考虑建立索引。</li>
<li>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ol>
<p><strong>需要注意的地方</strong></p>
<ul>
<li>注意避免冗余索引</li>
<li>考虑在字符串类型的字段上使用前缀索引代替普通索引，前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】MySql架构]]></title>
        <id>https://xzzz2020.github.io/post/aY-DgheCd/</id>
        <link href="https://xzzz2020.github.io/post/aY-DgheCd/">
        </link>
        <updated>2020-07-26T10:43:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-mysql-%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE">一、Mysql 的架构图</a></li>
<li><a href="#%E4%BA%8C-server-%E5%B1%82">二、Server 层</a>
<ul>
<li><a href="#1-%E8%BF%9E%E6%8E%A5%E5%99%A8">1. 连接器</a></li>
<li><a href="#2-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">2. 查询缓存</a></li>
<li><a href="#3-%E5%88%86%E6%9E%90%E5%99%A8">3. 分析器</a></li>
<li><a href="#4%E4%BC%98%E5%8C%96%E5%99%A8">4.优化器</a></li>
<li><a href="#5-%E6%89%A7%E8%A1%8C%E5%99%A8">5. 执行器</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">三、执行流程</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-mysql-的架构图">一、Mysql 的架构图</h2>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200714160802785.png" alt="image-20200714160802785" style="zoom: 80%;" />
<ul>
<li><strong>客户端</strong>：比如window和linux的黑窗口、SQLlyog、java的JDBC标准等等</li>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、 MyISAM、 Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。 现在最常用的存储引擎是 InnoDB，它从MySQL 5.5.5 版本开始就被当做默认存储引擎了。</li>
<li><strong>数据</strong>：都是二进制文件</li>
</ul>
<h2 id="二-server-层">二、Server 层</h2>
<h3 id="1-连接器">1. 连接器</h3>
<ul>
<li>
<p>连接器主要和身份认证和权限相关的功能相关</p>
</li>
<li>
<p>客户端通过连接器连接到MySql</p>
</li>
<li>
<p>客户端连接连接器是需要网络时间，所以建议使用数据库连接池，可以复用连接</p>
</li>
</ul>
<h3 id="2-查询缓存">2. 查询缓存</h3>
<ul>
<li>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</li>
<li>连接建立后，执行查询语句的时候，会先查询缓存， MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中</li>
<li>如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把<br>
结果缓存起来，方便下一次调用</li>
<li>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空，MySQL 8.0 版本后删除了缓存的功能</li>
<li>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</li>
</ul>
<p><strong>存在的问题</strong></p>
<ul>
<li>
<p>查询缓存的内存分配问题，不可避免地产生一些内存碎片；</p>
</li>
<li>
<p>查询缓存对是否是一样的查询语句，要求非常苛刻，而且还不智能</p>
</li>
<li>
<p>查询缓存中涉及的表，每一个表对象都有一个属于自己的全局性质的锁，表对象的DML操作，必须优先判断是否需要清理相关查询缓存的记录信息，将不可避免地出现锁等待事件</p>
</li>
<li>
<p>表若是做DDL等类似操作，触发相关表的查询缓存信息清空</p>
</li>
</ul>
<h3 id="3-分析器">3. 分析器</h3>
<p>没有命中缓存的话， SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的<br>
SQL 语句语法是否正确。 分析器也会分为几步：</p>
<ul>
<li>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
</li>
<li>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
</li>
</ul>
<p>完成这 2 步之后， MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了</p>
<h3 id="4优化器">4.优化器</h3>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选<br>
择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经<br>
定下来。</p>
<h3 id="5-执行器">5. 执行器</h3>
<ul>
<li>当选择了执行方案后， MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口， 从存储引擎返回执行的结果。</li>
</ul>
<h2 id="三-执行流程">三、执行流程</h2>
<ol>
<li>客户端连接连接器</li>
<li>分析器处理客户端的SQL语句，进行词法分析和语法分析，检查SQL语法是否正确</li>
<li>优化器优化分析器处理的语句，选择一个它认为的最优的执行方案去执行，比如多个索引的时候该如何选<br>
择索引，多表查询的时候如何选择关联顺序等</li>
<li>最后执行器执行优化器确定的方案，但是由于不了解数据是怎么存储的，需要调用存储引擎的接口，从存储引擎返回执行的结果</li>
<li>存储引擎决定怎么存储数据，常见的有三种：InnoDB存储引擎、MyISAM存储引擎和Memory引擎（博主主要掌握的InnoDB存储引擎）</li>
<li>当然中间还有一个查询缓存，会存储查询出来的数据，但是查询缓存命中不高，MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空，MySQL 8.0 版本后删除了缓存的功能，</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】MySQL存储引擎]]></title>
        <id>https://xzzz2020.github.io/post/j_WKr1zJr/</id>
        <link href="https://xzzz2020.github.io/post/j_WKr1zJr/">
        </link>
        <updated>2020-07-26T10:42:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-myisam-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">一、MyISAM 存储引擎</a></li>
<li><a href="#%E4%BA%8C-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">二、InnoDB 存储引擎</a></li>
<li><a href="#%E4%B8%89-memory-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">三、MEMORY 存储引擎</a></li>
<li><a href="#%E5%9B%9B-myisam%E5%92%8Cinnodb%E5%8C%BA%E5%88%AB">四、MyISAM和InnoDB区别</a></li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>存储引擎是表级别的，不同的表可以使用不同的存储引擎！！！</p>
</blockquote>
<h2 id="一-myisam-存储引擎">一、MyISAM 存储引擎</h2>
<ul>
<li>
<p>没有提供对数据库事务的支持，也不支持行级锁和外键，所以写操作需要锁定整个表，效率便会低一些</p>
</li>
<li>
<p>执行读取操作的速度很快，而且不占用大量的内存和存储资源，在设计之初就预想数据组织成有固定长度的记录，按顺序存储的</p>
</li>
<li>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
</li>
</ul>
<h2 id="二-innodb-存储引擎">二、InnoDB 存储引擎</h2>
<ul>
<li>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br>
实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li>
<li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>
<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</li>
</ul>
<h2 id="三-memory-存储引擎">三、MEMORY 存储引擎</h2>
<ul>
<li>数据存在内存</li>
<li>不支持持久化</li>
</ul>
<h2 id="四-myisam和innodb区别">四、MyISAM和InnoDB区别</h2>
<p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>
<p><strong>两者的对比：</strong></p>
<ol>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。</li>
<li><strong>索引的差别</strong>：MyISAM的B+Tree叶节点的data域存放的是数据记录的地址，然后以 data 域的值为地址读取相应的数据记录；InnoDB的数据文件本身就是索引文件，在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，否则会降低查询的素的。</li>
</ol>
<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】InnoDB存储引擎]]></title>
        <id>https://xzzz2020.github.io/post/M3FXzw5ip/</id>
        <link href="https://xzzz2020.github.io/post/M3FXzw5ip/">
        </link>
        <updated>2020-07-26T10:41:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">一、InnoDB存储引擎工作方式</a></li>
<li><a href="#%E4%BA%8C-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7">二、关键特性</a>
<ul>
<li><a href="#1-%E6%8F%92%E5%85%A5%E7%BC%93%E5%AD%98">1. 插入缓存</a></li>
<li><a href="#2-%E4%B8%A4%E6%AC%A1%E5%86%99">2. 两次写</a></li>
<li><a href="#3-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95">3. 自适应哈希索引</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-redo-log-binlog%E5%92%8Cundo-log">三、redo log、binlog和undo log</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFredo-log">1. 什么是redo log？</a></li>
<li><a href="#2-%E4%BB%80%E4%B9%88%E6%98%AFbinlog">2. 什么是binlog？</a></li>
<li><a href="#3-redo-log%E5%92%8Cbinlog%E5%8C%BA%E5%88%AB">3. redo log和binlog区别</a></li>
<li><a href="#4-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97undo-log">4. 回滚日志（undo log）</a></li>
<li><a href="#5-redo-log%E5%92%8Cundo-log%E7%9A%84%E5%8C%BA%E5%88%AB">5. redo log和undo log的区别</a></li>
<li><a href="#6-%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F">6. 一条更新语句执行的顺序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-innodb存储引擎工作方式">一、InnoDB存储引擎工作方式</h2>
<ul>
<li>将数据库文件按页（每页16k）读取到缓冲池，然后按照最近最少使用的算法（LRU）保留缓存数据。</li>
<li>如果数据发生更改，总是<code>先修改缓存池的页</code>（脏页），然后再保存在磁盘中</li>
</ul>
<h2 id="二-关键特性">二、关键特性</h2>
<h3 id="1-插入缓存">1. 插入缓存</h3>
<ul>
<li>因为主键是表唯一标识，所以插入顺序按照主键递增（自增主键）的顺序插入。</li>
<li>因此，插入的聚集索引一般是顺序的，不需要对磁盘随机读取，所以速度很快。</li>
<li>但是一个表不止有聚集索引，索引的插入不再是顺序的</li>
<li>插入索引对于非聚集索引，不是一次性插入到索引页，先判断索引页是否在缓存池。如果在，直接插入；如果不在，先放入插入缓存，<code>将多个插入合并在一个中</code>(因为都是在一个索引页中)，在根据磁盘IO情况更新到磁盘中。</li>
<li><code>索引必须是辅助索引，索引不是唯一的</code></li>
<li>默认最多占一半缓存池空间</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>由于并没有及时把索引更新到磁盘中，如果数据库宕机，则<code>需要很多的时间恢复数据</code></li>
</ul>
<h3 id="2-两次写">2. 两次写</h3>
<ul>
<li>当数据库宕机时，数据库可能正在写一个页面，而这个页面只写了一部分，则称之为部分写失效，从而导致数据丢失</li>
<li>如果此时直接使用Undo日志，由于页出现了损坏，所以此时是无意义的</li>
<li><code>在执行Undo日志之前，先需要一个页副本用来恢复的没有写之前的状态，再进行重做。</code></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nLzIwMjAwNDA5MTgzNjAwOTI2LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>doublewrite由两部分组成：内存中的doublewrite buffer，物理磁盘共享表中的两个区</li>
<li><code>在缓冲池脏页刷新时，先将数据拷贝到内存中的doublewrite buffer，然后在写入物理磁盘共享表中的两个区，然后在更新磁盘数据</code></li>
<li>由于doublewrite是连续的，所以对其的IO操作时顺序写的，开销不大</li>
</ul>
<h3 id="3-自适应哈希索引">3. 自适应哈希索引</h3>
<ul>
<li>哈希是一种查找办法，常用于join连接操作</li>
<li>会监控表上索引的查找，如果建立哈希索引可以提供速度，则建立哈希索引。</li>
<li>哈希索引通过缓存池中的B+数构造而来，因此建立速度很快</li>
<li>并不是整个表都需要建立哈希索引，InnoDB会根据访问的频率为某些页单独建立哈希索引</li>
</ul>
<h2 id="三-redo-log-binlog和undo-log">三、redo log、binlog和undo log</h2>
<h3 id="1-什么是redo-log">1. 什么是redo log？</h3>
<ul>
<li>
<p>redo  log是InnoDB存储引擎层的日志，又称重做日志文件，<strong>用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo  log恢复到掉电前的时刻，以此来保证数据的完整性。</strong></p>
</li>
<li>
<p><strong>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存</strong>，此时算是语句执行完了，然后<strong>在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中</strong>，这里涉及到<code>WAL</code>即<code>Write Ahead logging</code>技术，<strong>他的关键点是先写日志，再写磁盘。</strong></p>
</li>
<li>
<p>有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了<code>crash-safe</code>。</p>
</li>
<li>
<p><strong>redo log日志的大小是固定的，即记录满了以后就从头循环写，并且会暂停当前的所有数据更改操作，先将redo log日志同步到磁盘中。</strong></p>
</li>
</ul>
<h3 id="2-什么是binlog">2. 什么是binlog？</h3>
<ul>
<li>可以作为数据恢复，在MySQL层面保证数据一致性的</li>
<li>属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑</li>
<li>也可以用于主从之间保证数据一致性</li>
</ul>
<h3 id="3-redo-log和binlog区别">3. redo log和binlog区别</h3>
<ul>
<li>
<p>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</p>
</li>
<li>
<p>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑</p>
</li>
<li>
<p>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</p>
</li>
<li>
<p>binlog可以作为恢复数据使用，也可以用于主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</p>
</li>
</ul>
<h3 id="4-回滚日志undo-log">4. 回滚日志（undo log）</h3>
<ul>
<li>
<p>属于InnoDB层面保证事务的原子性</p>
</li>
<li>
<p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
</li>
</ul>
<h3 id="5-redo-log和undo-log的区别">5. redo log和undo log的区别</h3>
<ul>
<li>redo log是保证事务持久性的，undo log是保证事务原子性的</li>
<li>undo log用于备份一个事务开始前的数据，不会影响原本的数据，都是先在备份中更改，最后写入磁盘</li>
<li>redo log用于记录每一个数据更新的内容，用于在二次写中恢复破损的数据</li>
</ul>
<h3 id="6-一条更新语句执行的顺序">6. 一条更新语句执行的顺序</h3>
<p>update T set c=c+1 where ID=2;</p>
<ul>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】数据库优化策略]]></title>
        <id>https://xzzz2020.github.io/post/5NPno0The/</id>
        <link href="https://xzzz2020.github.io/post/5NPno0The/">
        </link>
        <updated>2020-07-26T10:39:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E5%8C%96">一、数据结构的优化</a></li>
<li><a href="#%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96">二、服务器优化</a></li>
<li><a href="#%E4%B8%89-%E7%BA%BF%E4%B8%8A%E5%AE%9A%E4%BD%8D">三、线上定位</a></li>
<li><a href="#%E5%9B%9B-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96">四、查询语句的优化</a>
<ul>
<li><a href="#1-sql-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%97%B6%E9%97%B4%E8%8A%B1%E5%9C%A8%E5%93%AA%E5%84%BF">1. sql 语句的时间花在哪儿?</a></li>
<li><a href="#2-sql-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%8F%88%E8%8A%B1%E5%9C%A8%E5%93%AA%E5%84%BF%E4%BA%86">2. sql 语句的执行时间,又花在哪儿了?</a></li>
<li><a href="#3-sql-%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">3. sql 语句的优化思路？</a></li>
<li><a href="#4-%E5%A6%82%E4%BD%95%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%9F%A5%E7%9A%84%E5%A4%9A%E5%B0%91%E8%A1%8C%E5%92%8C%E6%98%AF%E5%90%A6%E6%B2%BF%E7%9D%80%E7%B4%A2%E5%BC%95%E6%9F%A5">4. 如何定量分析查的多少行,和是否沿着索引查?</a></li>
<li><a href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">5. 常见的查询优化</a></li>
<li><a href="#6-%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96">6. 缓存优化</a></li>
<li><a href="#7-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">7. 读写分离</a></li>
<li><a href="#8-mysql-%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">8. mysql 的分库分表</a></li>
<li><a href="#9-explain%E4%BD%BF%E7%94%A8">9. EXPLAIN使用</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96">五、索引及优化</a>
<ul>
<li><a href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8">1. 索引的作用</a></li>
<li><a href="#2-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB">2. 索引的分类</a></li>
<li><a href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%E6%9F%A5%E7%9A%84%E5%BF%AB">3. 索引的优点（查的快）</a></li>
<li><a href="#4-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%E5%A2%9E%E5%88%A0%E6%94%B9%E6%85%A2">4. 索引的缺点（增删改慢）</a></li>
<li><a href="#5-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E6%88%96%E5%AD%97%E6%AE%B5%E9%80%82%E5%90%88%E5%8A%A0%E7%B4%A2%E5%BC%95">5. 哪些情况或字段适合加索引</a></li>
<li><a href="#6-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">6. 哪些情况不适合创建索引</a></li>
<li><a href="#7-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88">7. 哪些情况会造成索引失效</a></li>
<li><a href="#8-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86">8. 索引原理</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96">六、插入优化</a></li>
<li><a href="#%E4%B8%83-%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96">七、大表优化</a>
<ul>
<li><a href="#1-%E9%99%90%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8C%83%E5%9B%B4">1. 限定数据的范围</a></li>
<li><a href="#2-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">2. 读/写分离</a></li>
<li><a href="#3-%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA">3. 垂直分区</a></li>
<li><a href="#4-%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA">4. 水平分区</a></li>
<li><a href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E7%AD%96%E7%95%A5">5. 数据库分库策略</a></li>
<li><a href="#6-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8Eid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">6. 分库分表之后,id 主键如何处理？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-数据结构的优化">一、数据结构的优化</h2>
<p><strong>三大范式</strong>：</p>
<ul>
<li>数据库设计尽量遵循三范式</li>
<li>根据实际情况进行取舍，有时可能会拿冗余换速度，减少表的关联查询，用空间换时间</li>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率</li>
<li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表</li>
</ul>
<p><strong>数据库命令规范</strong>：</p>
<ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<p><strong>列的选择</strong>：</p>
<ul>
<li>字段类型优先级 整型 &gt; date,time &gt; char,varchar &gt; blob</li>
<li>尽量不要有null，可以设置为不允许空，或者加一个默认值</li>
<li>数据大小够用就行</li>
<li>不要使用大数据字段，如TEXT，BLOB</li>
<li>财务数据使用decimal，不会丢失精度</li>
</ul>
<p><strong>主键的选择</strong>：</p>
<ul>
<li>在 myisam 中,字符串索引会被压缩,用字符串做主键性能不如整型</li>
<li>用递增的值,不要用离散的值,离散值会导致文件在磁盘的位置有间隔,浪费空间且不易连续读取</li>
</ul>
<h2 id="二-服务器优化">二、服务器优化</h2>
<p><strong>优化服务器硬件</strong></p>
<ul>
<li>配置较大的内存</li>
<li>配置高速磁盘，比如 SSD</li>
<li>配置多核处理器， MySQL 是多线程的数据库，多处理器可以提高同时执行多个线程的能力</li>
</ul>
<p><strong>优化 MySQL 的参数</strong></p>
<ul>
<li>
<p>修改my.conf 或者 my.ini 配置文件</p>
</li>
<li>
<p><strong>key_buffer_size</strong>：表示索引缓冲区大小，缓存数据，只对MyISAM表起作用，不是越大越好，大小取决于内存</p>
</li>
<li>
<p><strong>innodb_buffer_pool_size</strong>：表示InnoDB类型表和索引的最大缓存，值越大查询速度越快</p>
</li>
<li>
<p><strong>query_cache_size</strong>：表示查询缓冲区大小，MySQL8以上已经移除</p>
</li>
<li>
<p><strong>max_connections</strong>：表示数据库的最大连接数，也不是越多越好，过多连接可能会导致僵死</p>
</li>
</ul>
<h2 id="三-线上定位">三、线上定位</h2>
<p><strong>发现系统运行缓慢，如何定位和分析查询慢的 sql 语句 ？</strong></p>
<ol>
<li>开启 mysql 慢日志查询 定位查询较慢的 sql 语句 （200ms 500ms ）</li>
<li>使用 EXPLAIN 关键字可以让你知道 MySQL 是如何处理你的 SQL 语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等</li>
<li>代码中可以使用 AOP 的操作 对每个持久层的 service 方法 打印执行时间，将所有执行时间较长的 sql 语句进行预警</li>
<li>查看sql语句是否出现了临时表，临时表可能会通过IO落地到磁盘上，要尽可能避免</li>
</ol>
<h2 id="四-查询语句的优化">四、查询语句的优化</h2>
<h3 id="1-sql-语句的时间花在哪儿">1. sql 语句的时间花在哪儿?</h3>
<ul>
<li>等待数据的等待时间，以及执行SQL语句时间.</li>
<li>这两个时间并非孤立的, 如果单条语句执行的快了,对其他语句的锁定的也就少了</li>
</ul>
<h3 id="2-sql-语句的执行时间又花在哪儿了">2. sql 语句的执行时间,又花在哪儿了?</h3>
<ul>
<li>查 ----&gt; 沿着索引查,甚至全表扫描</li>
<li>取 ----&gt; 查到行后,把数据取出来(sending data)</li>
</ul>
<h3 id="3-sql-语句的优化思路">3. sql 语句的优化思路？</h3>
<ul>
<li>不查, 通过业务逻辑来计算,比如论坛的注册会员数,我们可以根据前 3 个月统计的每天注册数, 用程序来估算</li>
<li>少查, 尽量精准数据,少取行. 我们观察新闻网站,评论内容等,一般一次性取列表 10-30 条左右</li>
<li>必须要查,尽量走在索引上查询行</li>
<li>取时, 取尽量少的列</li>
</ul>
<h3 id="4-如何定量分析查的多少行和是否沿着索引查">4. 如何定量分析查的多少行,和是否沿着索引查?</h3>
<ul>
<li>用 explain 来分析</li>
</ul>
<h3 id="5-常见的查询优化">5. 常见的查询优化</h3>
<ul>
<li>SELECT 语句务必指明字段名称（避免直接使用 select * ），使用*时，分析器，会要分析出都有什么列，会消耗很多时间，同时执行的时候，会返回很多没有必要的列</li>
<li>SQL 语句要避免造成索引失效的写法</li>
<li>当只需要一条数据的时候，使用 limit 1，这样就通过sql语句过滤，而避免了执行时的过滤</li>
<li>如果排序字段没有用到索引，就尽量少排序</li>
<li>如果限制条件中其他字段没有索引，尽量少用 or</li>
<li>避免在 where 子句中对字段进行 null 值判断</li>
<li>不建议使用%前缀模糊查询</li>
<li>避免在 where 子句中对字段进行表达式操作</li>
<li>Join 优化 能用 inner join 就不用 left join right join，如必须使用 一定要已小表为驱动</li>
<li>可以使用连接查询（JOIN）代替子查询，连接查询时不需要建立临时表，其速度比子查询快</li>
</ul>
<h3 id="6-缓存优化">6. 缓存优化</h3>
<ul>
<li>为了提高查询速度，我们可以通过不同的方式去缓存我们的结果从而提高响应效，可以去打开查询缓存或者使用Redis</li>
</ul>
<h3 id="7-读写分离">7. 读写分离</h3>
<ul>
<li>如果数据库的使用场景读的操作比较的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构，读写分离，解决的是，数据库的写入，影响了查询的效率。读写分离的基本原理是让主数据库处理事务性增、改、删操作（INSERT、 UPDATE、 DELETE），而从数据库处理 SELECT 查询操作</li>
</ul>
<h3 id="8-mysql-的分库分表">8. mysql 的分库分表</h3>
<ul>
<li>
<p>数据量越来越大时，单体数据库无法满足要求，可以考虑分库分表</p>
</li>
<li>
<p>两种拆分方案：</p>
<ul>
<li>垂直拆分：（分库）业务表太多？ 将业务细化 不同的小业务专门用一个库来维护</li>
<li>水平拆分：（分表）单个表存的数据太多，装不下了？ 将该表查分成多个</li>
</ul>
</li>
<li>
<p>分库分表常用工具： MyCat</p>
</li>
</ul>
<h3 id="9-explain使用">9. EXPLAIN使用</h3>
<p><strong>select_type，表示 SELECT 语句的类型，取值如下</strong></p>
<ul>
<li><strong>SIMPLE</strong>：表示简单查询，其中不包含连接查询和子查询</li>
<li><strong>PRIMARY</strong>：主键查血</li>
<li><strong>UNION</strong>：表示连接查询</li>
<li><strong>UNION RESULT</strong> ：连接查询的结果</li>
<li><strong>SUBQUERY</strong>：子查询</li>
</ul>
<p><strong>type ，表示表的连接类型 ，取值如下</strong>：</p>
<ul>
<li><strong>system</strong>：表仅有一行，这是 const 类型的特列，平时不会出现，这个也可以忽略不计</li>
<li><strong>const</strong>：数据表最多只有一个匹配行，因为只匹配一行数据，所以很快，常用于 PRIMARY KEY 或者 UNIQUE 索引的查询，<code>可理解为 const 是最优化的</code></li>
<li><strong>eq_ref</strong> ：读取本表中和关联表表中的每行组合成的一行，索引是主键或唯一非 NULL 索引</li>
<li><strong>ref</strong>：查询条件索引既不是 UNIQUE 也不是 PRIMARY KEY 的情况</li>
<li><strong>ref_or_null</strong>：该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。在解决子查询中经常使用该联接类型的优化。</li>
</ul>
<p>上面这五种情况都是很理想的索引使用情况。</p>
<ul>
<li><strong>index_merge</strong>：该联接类型表示使用了索引合并优化方法。在这种情况下， key 列包含了使用的索引的清单</li>
<li><strong>unique_subquery</strong>：是一个索引查找函数,可以完全替换子查询,效率更高。</li>
<li><strong>index_subquery</strong>：只检索给定范围的行,使用一个索引来选择行</li>
<li><strong>range</strong>：只检索给定范围的行,使用一个索引来选择行</li>
<li><strong>index</strong>：该联接类型与 ALL 相同,除了只有索引树被扫描。</li>
<li><strong>ALL</strong>：对于每个来自于先前的表的行组合,进行完整的表扫描，性能最差</li>
</ul>
<p>**possible_keys，可能用到的索引  **</p>
<p>**key，最终用的索引 ，如果没有选择索引,键是 NULL  **</p>
<h2 id="五-索引及优化">五、索引及优化</h2>
<blockquote>
<p>注意避免冗余索引，比如说(name)和(name,price)，(name)就是冗余索引</p>
</blockquote>
<h3 id="1-索引的作用">1. 索引的作用</h3>
<p>当表中的数据量越来越大时，索引对于性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段了。</p>
<p>索引能够轻易将查询性能提高好几个数量级。有了索引相当于我们给数据库的数据加了目录一样，可以快速的找到数据，如果不适用索引则需要一点一点去查找数据。 简单来说提高数据查询的效率。</p>
<h3 id="2-索引的分类">2. 索引的分类</h3>
<ul>
<li>普通索引 index :加速查找</li>
<li>唯一索引
<ul>
<li>主键索引： primary key ：加速查找+约束（不为空且唯一）</li>
<li>唯一索引： unique：加速查找+约束 （唯一）</li>
</ul>
</li>
<li>联合索引（组合索引）</li>
</ul>
<h3 id="3-索引的优点查的快">3. 索引的优点（查的快）</h3>
<ol>
<li>可以通过建立唯一索引或者主键索引,保证数据库表中每一行数据的唯一性.</li>
<li>建立索引可以大大提高检索的数据,以及减少表的检索行数</li>
<li>在表连接的连接条件 可以加速表与表直接的相连</li>
<li>在分组和排序字句进行数据检索,可以减少查询时间中 分组 和 排序时所消耗的时间(数据库的记录会重新排序)</li>
<li>建立索引,在查询中使用索引 可以提高性能</li>
</ol>
<h3 id="4-索引的缺点增删改慢">4. 索引的缺点（增删改慢）</h3>
<ol>
<li>在创建索引和维护索引 会耗费时间,随着数据量的增加而增加</li>
<li>索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间</li>
<li>当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)</li>
</ol>
<h3 id="5-哪些情况或字段适合加索引">5. 哪些情况或字段适合加索引</h3>
<ol>
<li>在经常需要搜索的列上,可以加快索引的速度</li>
<li>主键列上可以确保列的唯一性</li>
<li>在表与表的而连接条件上加上索引,可以加快连接查询的速度</li>
<li>在经常需要排序(order by),分组(group by)和的 distinct 列上加索引 可以加快排序查询的时间</li>
</ol>
<h3 id="6-哪些情况不适合创建索引">6. 哪些情况不适合创建索引</h3>
<ol>
<li>查询中很少使用到的列 不应该创建索引,如果建立了索引然而还会降低 mysql 的性能和增大了空间需求.</li>
<li>很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql 需要扫描的行数很多,增加索引,并不能提高效率</li>
<li>定义为 text 和 image 和 bit 数据类型的列不应该增加索引,</li>
<li>当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系</li>
</ol>
<h3 id="7-哪些情况会造成索引失效">7. 哪些情况会造成索引失效</h3>
<ol>
<li>如果条件中有 or，即使其中有条件带索引也不会使用(这也是为什么尽量少用 or 的原因)</li>
<li>索引字段的值不能有 null 值，有 null 值会使该列索引失效</li>
<li>对于多列索引，不是使用的第一部分，则不会使用索引（最左原则）</li>
<li>like 查询以%开头</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用单引号引用起来,否则不使用索引</li>
<li>在索引的列上使用表达式或者函数会使索引失效</li>
</ol>
<h3 id="8-索引原理">8. 索引原理</h3>
<ul>
<li>
<p>MySQL 的基本存储结构是页(记录都存在页里边)：</p>
</li>
<li>
<p>各个数据页可以组成一个双向链表</p>
</li>
<li>
<p>每个数据页中的记录又可以组成一个单向链表</p>
<ul>
<li>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>
<li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li>
</ul>
</li>
</ul>
<p>所以说，如果我们写 select * from user where indexname = 'xxx'这样没有进行任何优化的 sql 语句，默认会这样做：</p>
<ol>
<li>定位到记录所在的页：需要遍历双向链表，找到所在的页</li>
<li>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了<br>
很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为 O（n）</li>
</ol>
<p><strong>使用索引之后</strong></p>
<ul>
<li>其实就是将无序的数据变成有序(相对)：</li>
<li>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为 O(logn)）</li>
<li>其实底层结构就是 B+树， B+树作为树的一种实现，能够让我们很快地查找出对应的记录</li>
</ul>
<p><strong>面试题</strong></p>
<p>有商品表, 有主键,goods_id, 栏目列 cat_id, 价格 price说:在价格列上已经加了索引,但按价格查询还是很慢,<br>
问可能是什么原因,怎么解决?</p>
<p>答: 在实际场景中,一个电商网站的商品分类很多,直接在所有商品中,按价格查商品,是极少的,一般客户都来到分类下,然后再查.</p>
<p>改正: 去掉单独的 Price 列的索引, 加 (cat_id,price)复合索引再查询</p>
<p><strong>索引优化策略</strong></p>
<ol>
<li>选择唯一性索引</li>
<li>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</li>
<li>为经常需要排序、分组和联合操作的字段建立索引：</li>
<li>为常作为查询条件的字段建立索引。</li>
<li>限制索引的数目： 越多的索引，会使更新表变得很浪费时间。</li>
<li>尽量使用数据量少的索引</li>
<li>如果索引的值很长，那么查询的速度会受到影响。</li>
<li>尽量使用前缀来索引</li>
<li>如果索引字段的值很长，最好使用值的前缀来索引。</li>
<li>删除不再使用或者很少使用的索引</li>
<li>最左前缀匹配原则，非常重要的原则。</li>
<li>尽量选择区分度高的列作为索引</li>
<li>区分度的公式是表示字段不重复的比例</li>
<li>索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</li>
<li>尽量的扩展索引，不要新建索引。</li>
</ol>
<h2 id="六-插入优化">六、插入优化</h2>
<p><strong>InnoDB</strong>：</p>
<ol>
<li>
<p>禁用唯一性检查，唯一性校验会降低插入记录的速度，可以在插入记录之前禁用唯一性检查，插入数据完成后再开启</p>
</li>
<li>
<p>禁用外键检查，插入数据之前执行禁止事务的自动提交</p>
</li>
<li>
<p>禁止自动提交，插入数据之前执行禁止事务的自动提交</p>
</li>
<li>
<p>批量插入数据，可以使用一条 INSERT 语句插入一条数据</p>
</li>
</ol>
<h2 id="七-大表优化">七、大表优化</h2>
<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h3 id="1-限定数据的范围">1. 限定数据的范围</h3>
<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h3 id="2-读写分离">2. 读/写分离</h3>
<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h3 id="3-垂直分区">3. 垂直分区</h3>
<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE3MTU0ODA2MDU2LnBuZw?x-oss-process=image/format,png" alt="image-20200717154806056" loading="lazy"></figure>
<h3 id="4-水平分区">4. 水平分区</h3>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNzE3MTU0OTEwMjc3LnBuZw?x-oss-process=image/format,png" alt="image-20200717154910277" loading="lazy"></figure>
<p>分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<h3 id="5-数据库分库策略">5. 数据库分库策略</h3>
<ul>
<li><strong>客户端代理：</strong>  <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h3 id="6-分库分表之后id-主键如何处理">6. 分库分表之后,id 主键如何处理？</h3>
<p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p>
<p>生成全局 id 有下面这几种方式：</p>
<ul>
<li><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</li>
<li><strong>数据库自增 id</strong> : : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li><strong>利用 redis 生成 id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>
<li><strong>Twitter的snowflake算法 、美团的Leaf分布式ID生成系统</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【总结】数据库基础]]></title>
        <id>https://xzzz2020.github.io/post/74It5jkMz/</id>
        <link href="https://xzzz2020.github.io/post/74It5jkMz/">
        </link>
        <updated>2020-07-26T10:37:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该文章为知识总结的文章，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9832814.html">数据库专栏</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E8%83%BD%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFmysql%E5%90%97">一、能简单介绍一下什么是Mysql吗？</a></li>
<li><a href="#%E4%BA%8C-sql-%E7%9A%84%E5%88%86%E7%B1%BB">二、SQL 的分类</a></li>
<li><a href="#%E4%B8%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F">三、数据库三大范式</a>
<ul>
<li><a href="#1-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F">1. 第一范式</a></li>
<li><a href="#2-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F">2. 第二范式</a></li>
<li><a href="#3-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F">3. 第三范式</a></li>
<li><a href="#4-%E6%80%BB%E7%BB%93">4. 总结</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E4%BB%8B">四、事务的简介</a></li>
<li><a href="#%E4%BA%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7">五、事务的特性</a>
<ul>
<li><a href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7">1. 原子性</a></li>
<li><a href="#2-%E4%B8%80%E8%87%B4%E6%80%A7">2. 一致性</a></li>
<li><a href="#3-%E9%9A%94%E7%A6%BB%E6%80%A7">3. 隔离性</a></li>
<li><a href="#4-%E6%8C%81%E4%B9%85%E6%80%A7">4. 持久性</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98">六、并发事务出现的问题</a></li>
<li><a href="#%E4%B8%83-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">七、事务隔离级别</a>
<ul>
<li><a href="#1-%E5%9B%9B%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">1. 四个隔离级别</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E5%92%8C%E5%B9%B6%E5%8F%91%E7%AD%96%E7%95%A5">八、数据库锁和并发策略</a>
<ul>
<li><a href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81">1. 常见的锁</a></li>
<li><a href="#2-%E9%A1%B5%E7%BA%A7%E9%94%81">2. 页级锁</a></li>
<li><a href="#3-%E4%B9%90%E8%A7%82%E9%94%81">3. 乐观锁</a></li>
<li><a href="#4-%E6%82%B2%E8%A7%82%E9%94%81">4. 悲观锁</a></li>
<li><a href="#5-innodb%E9%94%81%E7%AE%97%E6%B3%95">5. InnoDB锁算法</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D-%E7%BB%99%E5%AE%9A%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%9D%E8%B7%AF">九、给定业务场景说明设计数据库的思路</a></li>
<li><a href="#%E5%8D%81-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%A0%E5%8C%96%E8%AE%BE%E8%AE%A1">十、说一下什么是池化设计</a></li>
<li><a href="#%E5%8D%81%E4%B8%80-%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0">十一、一条SQL语句执行慢的原因？</a>
<ul>
<li><a href="#1-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA">1. 分类讨论</a></li>
<li><a href="#2-%E9%92%88%E5%AF%B9%E5%81%B6%E5%B0%94%E5%BE%88%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5">2. 针对偶尔很慢的情况</a>
<ul>
<li><a href="#a-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5flush">a. 数据库在刷新脏页（flush）</a></li>
<li><a href="#b-%E6%8B%BF%E4%B8%8D%E5%88%B0%E9%94%81%E6%88%91%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E">b. 拿不到锁我能怎么办</a></li>
</ul>
</li>
<li><a href="#3-%E9%92%88%E5%AF%B9%E4%B8%80%E7%9B%B4%E9%83%BD%E8%BF%99%E4%B9%88%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5">3. 针对一直都这么慢的情况</a>
<ul>
<li><a href="#a-%E6%B2%A1%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95">a. 没用到索引</a></li>
<li><a href="#b-%E7%94%A8%E5%88%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E4%BD%86%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%AF%AF%E5%88%A4%E4%BA%86">b. 用到了索引，但是系统误判了</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="一-能简单介绍一下什么是mysql吗">一、能简单介绍一下什么是Mysql吗？</h2>
<ul>
<li>MySQL 是一种关系型数据库</li>
<li>在Java企业级开发中非常常用，因为 MySQL 是开源免费的</li>
<li>阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的</li>
<li>MySQL的默认端口号是<strong>3306</strong></li>
</ul>
<h2 id="二-sql-的分类">二、SQL 的分类</h2>
<ul>
<li>
<p><strong>DQL--数据查询语言</strong>：代表关键字:select</p>
</li>
<li>
<p><strong>DML--数据操纵语言</strong>：代表关键字:insert,delete,update</p>
</li>
<li>
<p><strong>DDL--数据定义语言</strong>：代表关键字:create ,drop,alter,</p>
</li>
<li>
<p><strong>TCL--事务控制语言</strong>：代表关键字:commit ,rollback;</p>
</li>
<li>
<p><strong>DCL--数据控制语言</strong>：代表关键字:grant,revoke.</p>
</li>
</ul>
<h2 id="三-数据库三大范式">三、数据库三大范式</h2>
<h3 id="1-第一范式">1. 第一范式</h3>
<p><code>数据库表中不能出现重复记录，每个字段是原子性的不能再分</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">学生编号</th>
<th style="text-align:center">学生姓名</th>
<th style="text-align:center">联系方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1001</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">zs@gmail.com,1359999999</td>
</tr>
<tr>
<td style="text-align:center">1002</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">ls@gmail.com,13699999999</td>
</tr>
<tr>
<td style="text-align:center">1001</td>
<td style="text-align:center">王五</td>
<td style="text-align:center">ww@163.net,13488888888</td>
</tr>
</tbody>
</table>
<ul>
<li>学生编号重复，因为没有主键</li>
<li>联系方式既有邮箱和电话</li>
</ul>
<p>因此需要修改成如下形式：</p>
<table>
<thead>
<tr>
<th>学生编号(pk)</th>
<th>学生姓名</th>
<th>email</th>
<th>联系电话</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>张三</td>
<td>zs@gmail.com</td>
<td>1359999999</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>ls@gmail.com</td>
<td>13699999999</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>ww@163.net</td>
<td>13488888888</td>
</tr>
</tbody>
</table>
<ul>
<li>每个行必须唯一，且存在主键</li>
<li>列不能再分</li>
</ul>
<h3 id="2-第二范式">2. 第二范式</h3>
<p><code>要求所有非主键字段完全依赖主键，不能产生部分依赖</code></p>
<table>
<thead>
<tr>
<th>学生编号(PK)</th>
<th>教师编号(PK)</th>
<th>学生姓名</th>
<th style="text-align:center">教师姓名</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>001</td>
<td>张三</td>
<td style="text-align:center">王老师</td>
</tr>
<tr>
<td>1002</td>
<td>002</td>
<td>李四</td>
<td style="text-align:center">赵老师</td>
</tr>
<tr>
<td>1003</td>
<td>001</td>
<td>王五</td>
<td style="text-align:center">王老师</td>
</tr>
<tr>
<td>1001</td>
<td>002</td>
<td>张三</td>
<td style="text-align:center">赵老师</td>
</tr>
<tr>
<td>1001</td>
<td>002</td>
<td>爱迪生</td>
<td style="text-align:center">赵老师</td>
</tr>
</tbody>
</table>
<ul>
<li>如果只是拿学生编号或者教师编号做主键，都不能确定唯一一行数据，所以采用联合主键</li>
<li>学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部门依赖了主键<br>
的一个字段教师编号，这就是第二范式部分依赖。</li>
</ul>
<p><strong>解决就是分表</strong>：</p>
<ul>
<li>学生信息表</li>
</ul>
<table>
<thead>
<tr>
<th>学生编号（PK）</th>
<th>学生姓名</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>张三</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
</tr>
</tbody>
</table>
<ul>
<li>教师信息表</li>
</ul>
<table>
<thead>
<tr>
<th>教师编号（PK）</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>王老师</td>
</tr>
<tr>
<td>002</td>
<td>赵老师</td>
</tr>
</tbody>
</table>
<ul>
<li>教师和学生的关系表</li>
</ul>
<table>
<thead>
<tr>
<th>学生编号(PK)</th>
<th>教师编号(PK)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>001</td>
</tr>
<tr>
<td>1002</td>
<td>002</td>
</tr>
<tr>
<td>1003</td>
<td>001</td>
</tr>
<tr>
<td>1001</td>
<td>002</td>
</tr>
</tbody>
</table>
<h3 id="3-第三范式">3. 第三范式</h3>
<p><code>非主键字段不能传递依赖于主键字段。</code></p>
<table>
<thead>
<tr>
<th>学生编号（PK）</th>
<th>学生姓名</th>
<th>班级编号</th>
<th>班级名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>张三</td>
<td>01</td>
<td>一年一班</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>02</td>
<td>一年二班</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>03</td>
<td>一年三班</td>
</tr>
</tbody>
</table>
<ul>
<li>班级名称字段没有直接依赖于主键，班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖</li>
</ul>
<p><strong>继续分表</strong></p>
<ul>
<li>学生信息表</li>
</ul>
<table>
<thead>
<tr>
<th>学生编号（PK）</th>
<th>学生姓名</th>
<th>班级编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>张三</td>
<td>01</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>02</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>03</td>
</tr>
</tbody>
</table>
<ul>
<li>班级信息表</li>
</ul>
<table>
<thead>
<tr>
<th>班级编号</th>
<th>班级名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>一年一班</td>
</tr>
<tr>
<td>02</td>
<td>一年二班</td>
</tr>
<tr>
<td>03</td>
<td>一年三班</td>
</tr>
</tbody>
</table>
<h3 id="4-总结">4. 总结</h3>
<ul>
<li>第一范式： 有主键，具有原子性，字段不可分割</li>
<li>第二范式：完全依赖， 没有部分依赖</li>
<li>第三范式： 没有传递依赖</li>
</ul>
<p>数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求</p>
<h2 id="四-事务的简介">四、事务的简介</h2>
<ul>
<li>当执行 DML 语句是其实就是开启一个事务</li>
<li>关于事务的回滚需要注意：只能回滚 insert、 delete 和 update 语句，不能回滚 select（回滚 select 没有任何意义），对于 create、 drop、 alter 这些无法回滚.事务只对 DML 有效果。</li>
<li>注意： rollback，或者 commit 后事务就结束了。</li>
</ul>
<h2 id="五-事务的特性">五、事务的特性</h2>
<h3 id="1-原子性">1. 原子性</h3>
<ul>
<li>整个事务中的所有操作，必须作为一个单元全部完成（或全部取消）。</li>
</ul>
<p>undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，他需要记录你要回滚的相应日志信息。</p>
<p>undo log 记录了这些回滚需要的信息，当事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undolog 中的信息将数据回滚到修改之前的样子。</p>
<h3 id="2-一致性">2. 一致性</h3>
<ul>
<li>关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见</li>
</ul>
<p>数据库无法保证，需要从应用层角度考虑，用业务来实现。从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据</p>
<h3 id="3-隔离性">3. 隔离性</h3>
<p>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</p>
<p>事务的隔离性是利用的是锁和 MVCC 机制。</p>
<p>至于 MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在 undo log 中。</p>
<p>如果一个事务读取的行正在做 DELELE 或者 UPDATE 操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。</p>
<h3 id="4-持久性">4. 持久性</h3>
<p>在事务完成以后，该事务对数据库所作的更改将持久地保存在数据库之中，并不会被回滚。</p>
<p>事务的持久性是利用 Innodb 的redo log</p>
<h2 id="六-并发事务出现的问题">六、并发事务出现的问题</h2>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong>  指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。     例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h2 id="七-事务隔离级别">七、事务隔离级别</h2>
<h3 id="1-四个隔离级别">1. 四个隔离级别</h3>
<ul>
<li><strong>读未提交</strong>：允许一个事务可以看到其他事务未提交的修改，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>读已提交</strong>：允许一个事务只能看到其他事务已经提交的修改，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>可重复读</strong>：确保如果在一个事务中执行两次相同的 SELECT 语句，都能得到相同的结果，不管其他事务是否提交这些修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>串行化</strong>：将一个事务与其他事务完全地隔离，相当于加锁，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p>
<blockquote>
<p>InnoDB 存储引擎<strong>REPEATABLE-READ（可重读）</strong>  事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
</blockquote>
<h2 id="八-数据库锁和并发策略">八、数据库锁和并发策略</h2>
<h3 id="1-常见的锁">1. 常见的锁</h3>
<ul>
<li><strong>MyIsam 实现了表锁</strong>。表锁可以针对数据库表加锁，在锁的灵活性上不如行锁。表锁分为两种锁：读锁与写锁。</li>
<li><strong>InnoDB 存储引擎实现了行锁与表锁（意向锁）</strong>。行锁可以以行为单位对数据集进行锁定。行锁也分为两种锁：<br>
共享锁与排他锁。 InnoDB 对于 Update、 Delete、 insert 语句会自动给涉及的数据集隐式的加上排他锁。对于 select语句 InnoDB 不会加任何锁
<ul>
<li><strong>共享锁</strong>：允许一个事务读取一行，阻止其他事务获得相同数据集的排他锁。但允许其他事务获取共享锁。<br>
显示加锁 select * from table where ... lock in share mode</li>
<li><strong>排他锁</strong>：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享与排他锁。但是可以对获取了排他锁的数据集进行单纯的查询访问。<br>
显示加锁 sql select * from table where ... for update</li>
</ul>
</li>
<li><strong>innoDB 的行锁的实现方式是基于索引项的</strong>。这意味着即使你尝试获取不同行的排他锁，若使用了相同的索引键，也可能会造成锁冲突。</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li>
<p><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
</li>
<li>
<p><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>
</li>
<li>
<p>事务更新大表中的大部分数据直接使用表级锁效率更高；事务比较复杂，使用行级索很可能引起死锁导致回滚。</p>
</li>
</ul>
<h3 id="2-页级锁">2. 页级锁</h3>
<p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 BDB 支持页级锁</p>
<h3 id="3-乐观锁">3. 乐观锁</h3>
<p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据</p>
<p><strong>实现</strong>：</p>
<p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁 机制，但是这种方法可以大大提高数据库处理的并发量</p>
<pre><code class="language-sql"># 每一个记录都有version，会有冗余，可以一个表一个version
Select data,version from biao where id = #{id};
Update biao set data=#{data},version=vsersion+1 where id=#{id} and version = #{version};

# 一个表一个修改
begin;
Select version from version_biao where table_name = #{table_name};
Update biao set data=#{data} where id=#{id};
Update version_biao set version=vsersion+1 from  where version = #{version};
commit;
</code></pre>
<h3 id="4-悲观锁">4. 悲观锁</h3>
<p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自<br>
己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取<br>
该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p>
<p><strong>实现</strong>：</p>
<p>sql 语句后边加上 for update</p>
<pre><code class="language-sql">select id,nam from biao for update ;
</code></pre>
<h3 id="5-innodb锁算法">5. InnoDB锁算法</h3>
<ul>
<li>
<p><strong>间隙锁</strong>：锁定一个一个区间记录中的间隙，不包括记录本身</p>
</li>
<li>
<p><strong>行锁</strong>：单个行记录上的锁</p>
</li>
<li>
<p><strong>临键锁</strong>：锁定一个一个区间记录中的间隙以及记录本身</p>
</li>
</ul>
<h2 id="九-给定业务场景说明设计数据库的思路">九、给定业务场景说明设计数据库的思路</h2>
<ol>
<li>分析场景选择存储引擎，比如业务是读多还是写多？需不需要支持事务？</li>
<li>数据库设计的原则，遵循三大范式，但是可以做一些适当的反三大范式</li>
<li>字段的设计，选择类型</li>
</ol>
<h2 id="十-说一下什么是池化设计">十、说一下什么是池化设计</h2>
<ul>
<li>我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。</li>
<li>池化设计会配置一些参数，比如初始线程数，最大线程数等等，还会有一个阻塞队列，当一些请求过多时，会采用一些拒绝的策略</li>
<li>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。 连接池还减少了用户必须等待建立与数据库的连接的时间。</li>
</ul>
<h2 id="十一-一条sql语句执行慢的原因">十一、一条SQL语句执行慢的原因？</h2>
<h3 id="1-分类讨论">1. 分类讨论</h3>
<ul>
<li>
<p>大多数情况是正常的，只是偶尔会出现很慢的情况。</p>
</li>
<li>
<p>在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</p>
</li>
</ul>
<h3 id="2-针对偶尔很慢的情况">2. 针对偶尔很慢的情况</h3>
<p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？</p>
<h4 id="a-数据库在刷新脏页flush">a. 数据库在刷新脏页（flush）</h4>
<p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p>
<blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
</blockquote>
<p><strong>刷脏页有两种场景会影响性能</strong></p>
<ul>
<li>**redolog写满了：**redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li>
<li>**内存不够用了：**如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>
</ul>
<h4 id="b-拿不到锁我能怎么办">b. 拿不到锁我能怎么办</h4>
<p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p>
<h3 id="3-针对一直都这么慢的情况">3. 针对一直都这么慢的情况</h3>
<p>先通过EXPLAN去分析SQL语句是否用到索引，主要关注type，possible_key，keys这几个字段</p>
<h4 id="a-没用到索引">a. 没用到索引</h4>
<ul>
<li>如果该字段没有加索引，那么自然没有用到索引</li>
<li>字段有索引，但却没有用索引，那说明出现了索引失效，比如说like 查询以%开头，或者不满足索引的最左原则，或者使用了Or关键字，或者索引字段的值有NULL值，或者使用了函数</li>
</ul>
<h4 id="b-用到了索引但是系统误判了">b. 用到了索引，但是系统误判了</h4>
<ul>
<li>非主键索引存储的是主键索引的值，如果SQL语句走的非主键索引，那么还需要到主键索引去寻找对应的data</li>
<li>当一个SQL语句范围比较大，比如where  x&gt;0  and  x &lt; 20000或者没有where条件，那么可能命中的数据非常多，甚至命中全表，而全表扫描顶多就是O(n)，此时再走索引，还会有两次索引寻找的时间消耗，即使索引查找非常快</li>
<li>此时分析器就要判断是否走索引，采用的方式是抽样检测，来预测SQL语句范围中出现相同值的概率，比如在0-20000范围中，数字3可能出现了10次，也可能只出现1次，显然如果重复数字越少，走索引的性能越好</li>
</ul>
]]></content>
    </entry>
</feed>