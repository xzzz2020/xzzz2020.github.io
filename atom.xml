<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-06-29T02:45:46.968Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[JavaSE基础知识面试考点总结]]></title>
        <id>https://xzzz2020.github.io/post/amjJC-n_8/</id>
        <link href="https://xzzz2020.github.io/post/amjJC-n_8/">
        </link>
        <updated>2020-06-28T04:01:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%A6%82%E8%BF%B0">一、 概述</a>
<ul>
<li><a href="#1-jdk%E7%89%88%E6%9C%AC">1. JDK版本</a></li>
<li><a href="#2-java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">2. Java语言特性</a></li>
<li><a href="#3-java%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">3. Java的加载与执行过程</a></li>
<li><a href="#4-jvm-jdk%E5%92%8Cjre%E7%9A%84%E5%8C%BA%E5%88%AB">4. JVM、JDK和JRE的区别</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">二、Java语言基础</a>
<ul>
<li><a href="#1-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">1. 八种基本类型</a></li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">2. 字符编码</a></li>
<li><a href="#3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">3. 类型转换</a></li>
<li><a href="#4-%E8%BF%90%E7%AE%97%E7%AC%A6">4. 运算符</a></li>
<li><a href="#5-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">5. 控制语句</a></li>
<li><a href="#6-%E6%96%B9%E6%B3%95">6. 方法</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">三、 面向对象</a>
<ul>
<li><a href="#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB">1. 面向过程与面向对象的区别</a></li>
<li><a href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81">2. 面向对象特征</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1">抽象</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">3. 参数传递</a></li>
<li><a href="#4-%E5%85%B3%E9%94%AE%E5%AD%97">4. 关键字</a>
<ul>
<li><a href="#this-%E5%85%B3%E9%94%AE%E5%AD%97">this 关键字：</a></li>
<li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li>
<li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a></li>
<li><a href="#final%E5%85%B3%E9%94%AE%E5%AD%97">final关键字</a></li>
</ul>
</li>
<li><a href="#5-%E4%BB%A3%E7%A0%81%E5%9D%97">5. 代码块</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97">静态代码块</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97">实例语句块</a></li>
</ul>
</li>
<li><a href="#6-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">6. 类的继承</a></li>
<li><a href="#7-static-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%88%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">7. static、构造方法和父子类的调用顺序</a></li>
<li><a href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3">8. 抽象类和接口（***）</a>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
</ul>
</li>
<li><a href="#9-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">9. 类之间的关系</a></li>
<li><a href="#10-object%E7%B1%BB">10. Object类</a>
<ul>
<li><a href="#equals">equals</a></li>
<li><a href="#finalize">finalize</a></li>
</ul>
</li>
<li><a href="#11-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90">11. 访问控制权限</a></li>
<li><a href="#12-%E5%86%85%E9%83%A8%E7%B1%BB">12 内部类</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB">实例内部类</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><strong>静态内部类</strong></a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%BC%82%E5%B8%B8">四、异常</a>
<ul>
<li><a href="#1-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB">1. 异常的体系</a></li>
<li><a href="#2-%E8%AF%B4%E5%87%BA%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8">2. 说出几个常见的异常</a></li>
<li><a href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">3. 异常处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<blockquote>
<p>该文章是博主采集于各大博文，用于复习和总结相关知识点，将会持续的收集和更新。</p>
</blockquote>
<h2 id="一-概述">一、 概述</h2>
<h3 id="1-jdk版本">1. JDK版本</h3>
<blockquote>
<p>目前只维护两个JDK版本，一个是8，一个是11（2018年）</p>
</blockquote>
<h3 id="2-java语言特性">2. Java语言特性</h3>
<ul>
<li><strong>可移植性，跨平台</strong>，因为Java有一个JVM虚拟机，虚拟机负责执行字节码文件</li>
<li><strong>健壮性</strong>，具有GC，有自动垃圾回收机制</li>
</ul>
<h3 id="3-java的加载与执行过程">3. Java的加载与执行过程</h3>
<ul>
<li>T.java（源文件）通过javac命令变成字节码文件</li>
<li>字节码文件通过类加载器加载到JVM中</li>
<li>JVM屏蔽了和操作系统打交道的操作</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL0phdmElMjAlRTclQTglOEIlRTUlQkElOEYlRTglQkYlOTAlRTglQTElOEMlRTglQkYlODclRTclQTglOEItMS5wbmc?x-oss-process=image/format,png" alt="Java程序运行过程" loading="lazy"></figure>
<h3 id="4-jvm-jdk和jre的区别">4. JVM、JDK和JRE的区别</h3>
<p><strong>Java虚拟机（JVM）</strong></p>
<ul>
<li>是运行 Java  字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM  实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li>
</ul>
<p><strong>JDK</strong></p>
<ul>
<li>是Java Development Kit，它是功能齐全的Java SDK。<code>它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</code></li>
</ul>
<p><strong>JRE</strong></p>
<ul>
<li><code>是 Java运行时环境。 它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。</code></li>
<li>但是，它不能用于创建新程序。</li>
</ul>
<h2 id="二-java语言基础">二、Java语言基础</h2>
<h3 id="1-八种基本类型">1. 八种基本类型</h3>
<blockquote>
<p>八种基本数据类型：byte、short、int、long、float、double、boolean、char。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNjI4MTEzMzQ4NTE1LnBuZw?x-oss-process=image/format,png" alt="image-20200628113348515" loading="lazy"></figure>
<p><strong>一个字节等于8位</strong></p>
<p><strong>IEE754标准（32位）</strong>：1位是符号位，8位是阶码用移码表示，23位尾数</p>
<h3 id="2-字符编码">2. 字符编码</h3>
<blockquote>
<p>类型可以存放一个汉字， java 中的 char 使用 utf-16 编码</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">编码名称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII 字符编码</td>
<td style="text-align:center">只支持英文字母、标点符号、数字字符等， ASCII 码占用 1 个字节，所以 ASCII 码最多可以表示 256 个字符. 小 a 97 大 A 65,’0’是 48</td>
</tr>
<tr>
<td style="text-align:center">ISO-8859-1</td>
<td style="text-align:center">有称 latin-1,是国际化标准或组织 ISO 制定的，主要为了西欧语言中的字符 编码，和 ASCII 兼容，仍不支持中文</td>
</tr>
<tr>
<td style="text-align:center">GB2312/GBK/GB18030</td>
<td style="text-align:center">主要是汉字编码，三种编码从容量上看是包含关系 简体中文： GBK &lt; GB2312 &lt; GB18030 繁体中文： Big5【大五码】</td>
</tr>
<tr>
<td style="text-align:center">unicode</td>
<td style="text-align:center">Unicode 统 一 了 全 世 界 上 的 所 有 文 字 编 码 ， unicode 有 几 种 实 现 ： UTF-8,UTF-16,UTF-32 java 语言采用的是 Unicode 编码，所以在 java 中标识符也可以使用中文</td>
</tr>
</tbody>
</table>
<h3 id="3-类型转换">3. 类型转换</h3>
<ul>
<li>
<p>在 java 中基本类型可以相互转换， boolean 类型比较特殊不可以转换成其他类型</p>
</li>
<li>
<p>转换分为默认转换和强制转换:</p>
<ul>
<li>
<p>默认转换：容量小的类型会默认转换为容量大的类型</p>
<ul>
<li>
<p>byte--&gt;short--&gt; int--&gt;long--&gt;float--&gt;double</p>
</li>
<li>
<p><strong>byte、 short、 char 之间计算不会互相转换，首先先转换成 int</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>强制转换：</p>
<ul>
<li><strong>将容量大的类型转换成容量小的类型，需要进行强制转换</strong></li>
<li>注意：只要不超出范围可以将整型值直接赋值给 byte， short， char</li>
<li>在多种类型混合运算过程中，首先先将所有数据转换成容量最大的那种，再运算</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class DataTypeTest08
{
    public static void main(String[] args){
        long x = 100L;
        int y = x;//编译不通过
        
        long a = 2147483648L;
        int b = (int)a;
        System.out.println(b);//出现精度丢失问题，大类型--&gt;&gt;小类型会出现问题，输出-2147483648
        
        byte a = 1000;//出现错误， 1000 超出了 byte 的范围
        
        long g = 10;
        int h = g/3;//出现错误，多个数值在运算过程中，会转换成容量最大的类型

        byte h3 = (byte)(int)g/3;//考察优先级，将g先转换成int，再强转成byte，再除以3得到int，赋值错误
        byte h4 = (byte)(int)(g/3);//正确的
        byte h5 = (byte)g/3;//考察优先级，先转换成byte，再运算
        byte h6 = (byte)(g/3);//正确
        short h7 = (short)(g/3);//正确
        
        short i = 10;
        byte j = 5;
        short k = i + j;//错误的，short和byte运算，首先会转换成int再运算
    }
}
</code></pre>
<h3 id="4-运算符">4. 运算符</h3>
<p><strong>短路与和逻辑与的区别？</strong></p>
<p>短路与比逻辑与智能，短路与效率高。</p>
<p><strong>短路或和逻辑或的区别？</strong></p>
<p>短路或：左边的算子结果是 true，右边的表达式不执行，发生短路</p>
<p><strong>a += 3和 a = a + 3; 是一样的吗？</strong></p>
<ul>
<li><strong>结论(重点)</strong>：<code>扩展赋值运算符不改变运算结果的类型。初始类型和最终运算结果类型完全相同。</code></li>
</ul>
<pre><code class="language-java">public class OperatorTest09
{
    public static void main(String[] args){
        byte b = 10;
        //编译错误
        //b = b + 3;
        //修改
        b = (byte)(b + 3);
        System.out.println(b); //13
        b += 3;
        System.out.println(b); //16
        b += 10000; //等同于 b = (byte)(b + 10000);
        System.out.println(b); //32
    }
}
</code></pre>
<h3 id="5-控制语句">5. 控制语句</h3>
<p><strong>switch 语句</strong></p>
<ul>
<li>
<p>switch 也称为多重分支，具体格式如下<br>
switch (表达式) {<br>
case 值 1：<br>
语句<br>
break;<br>
case 值 2：<br>
语句<br>
break;<br>
default：<br>
语句<br>
Break;<br>
}</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>表达式的值只能为： char、 byte、 short、 int 类型（<strong>JDK7 以后支持 String</strong>）， boolean、 long、 float、</li>
<li><strong>double 都是非法的</strong></li>
<li><strong>break 语句可以省略,但会出现 switch 穿透</strong></li>
<li>default 语句也可以省略，一般不建议省略，并且放置在最后</li>
</ul>
<blockquote>
<p><strong>需求：</strong></p>
<p>假定系统给定学生的考试成绩，考试成绩可以带有小数。<br>
假定成绩是合法的[0-100]，请根据学生考试成绩判断该<br>
学生成绩等级：<br>
[90-100] A<br>
[80-90) B<br>
[70-80) C<br>
[60-70) D<br>
[0-60) E</p>
</blockquote>
<p><mark>以上业务只能使用 switch 语句完成，不允许使用 if 语句。</mark></p>
<pre><code class="language-java">public class SwitchTest04 {
    public static void main(String[] args) {
        //考试成绩合法
        double score = 100;
        //开始判断
        int grade = (int) (score / 10);//case条件不能为浮点数

        switch (grade) {
            case 10:
                System.out.println(&quot;A&quot;);
                break;
            case 9:
                System.out.println(&quot;A&quot;);
                break;
            case 8:
                System.out.println(&quot;B&quot;);
                break;
            case 7:
                System.out.println(&quot;C&quot;);
                break;
            case 6:
                System.out.println(&quot;D&quot;);
                break;
            default:
                System.out.println(&quot;E&quot;);
        }

        //重点： case 是可以合并的
        switch (grade) {
            case 10:
            case 9:
                System.out.println(&quot;A&quot;);
                break;
            case 8:
                System.out.println(&quot;B&quot;);
                break;
            case 7:
                System.out.println(&quot;C&quot;);
                break;
            case 6:
                System.out.println(&quot;D&quot;);
                break;
            default:
                System.out.println(&quot;E&quot;);
        }
    }
}
</code></pre>
</li>
</ul>
<p><strong>for语句</strong></p>
<pre><code class="language-java">for(;false;){//会出现编译错误，因为无法访问
    System.out.println(&quot;呵呵&quot;);
}
for(;true;){//死循环
	System.out.println(&quot;哈哈&quot;);
}
</code></pre>
<h3 id="6-方法">6. 方法</h3>
<p><strong>方法的返回值问题</strong>：</p>
<pre><code class="language-java">public class MethodTest07
{
    //缺少返回语句，程序编译时无法判断是否能走到else，无法编译通过
    public static int m1(){
        boolean flag = true;
        if(flag){
            return 1;
        }
    }

    //正确
    public static int m2(){
        boolean flag = true;
        if(flag){
            return 1;
        }else{
            return 0;
        }
    }

    //编译错误
    public static int m3(){
        boolean flag = false;
        if(flag){//
            return 1;//return后不能接任何语句
            System.out.println(&quot;??????????&quot;);
        }
        System.out.println(&quot;??????????&quot;);
        return 0;
        System.out.println(&quot;??????????&quot;);
    }
}
</code></pre>
<h2 id="三-面向对象">三、 面向对象</h2>
<h3 id="1-面向过程与面向对象的区别">1. 面向过程与面向对象的区别</h3>
<ul>
<li>
<p><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></p>
</li>
<li>
<p><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong></p>
</li>
</ul>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>
</blockquote>
<h3 id="2-面向对象特征">2. 面向对象特征</h3>
<h4 id="封装">封装</h4>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="继承">继承</h4>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态">多态</h4>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h4 id="抽象">抽象</h4>
<ul>
<li>
<p>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。</p>
</li>
<li>
<p>抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。</p>
</li>
</ul>
<h3 id="3-参数传递">3. 参数传递</h3>
<blockquote>
<p><mark>所有基本数据类型的都是值传递，其他类型的为址传递</mark></p>
</blockquote>
<h3 id="4-关键字">4. 关键字</h3>
<h4 id="this-关键字">this 关键字：</h4>
<ul>
<li>
<p>this 关键字指的是当前调用的对象， 只能用在构造函数和实例方法内部，还可以应用在成员变量的声明上， static 标识的方法里是不能使用 this 的。</p>
</li>
<li>
<p><strong>作用：代码复用。</strong></p>
</li>
</ul>
<h4 id="super-关键字">super 关键字</h4>
<ul>
<li>
<p><strong>调用父类的构造方法</strong></p>
<ul>
<li>
<p>没有显示地调用 super(); 父类的无参构造方法也执行</p>
</li>
<li>
<p>必须将 super 放到子类的构造函数的第一语句来调用父类的构造方法</p>
</li>
</ul>
</li>
<li>
<p><strong>调用父类的成员方法</strong></p>
<ul>
<li>需要注意： super 只能应用在成员方法和构造方法中，<strong>不能应用在静态方法中</strong>（和 this 是一样的），如果<strong>在构造方法中使用必须放在第一行</strong></li>
</ul>
</li>
</ul>
<p><strong>为什么会有 super 关键字？</strong></p>
<ul>
<li><code>因为子类必须要调用父类的构造方法，先把父类构造完成，因为子类依赖于父类，没有父，也就 没有子</code></li>
<li><code>有时需要在子类中显示的调用父类的成员方法</code></li>
</ul>
<p><strong>那么我们以前为什么没有看到 super，而且我们也有继承，如： Student 继承了 Person？</strong></p>
<ul>
<li>因为子类中我们没有显示的调用父类构造方法，那么他会默认调用父类的无参构造方法，此种情况下<br>
如果父类中没有无参构造方法，那么编译时将会失败</li>
</ul>
<blockquote>
<p><code>注意构造方法不存在覆盖的概念，构造方法可以重载</code></p>
</blockquote>
<h4 id="static-关键字">static 关键字</h4>
<p>可以用来修饰它可以用来修饰的<strong>成员变量</strong>和<strong>成员方法</strong>，<code>被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</code></p>
<h4 id="final关键字">final关键字</h4>
<p><strong>final 表示不可改变的含义</strong></p>
<ul>
<li>采用 final 修饰的类不能被继承</li>
<li>采用 final 修饰的方法不能被覆盖</li>
<li>采用 final 修饰的变量不能被修改</li>
<li>final 修饰的变量必须显示初始化<br>
局部变量： 一旦赋值不能重新赋值<br>
成员变量： 不能采用系统默认值，必须手动赋值<br>
如果修饰的引用，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的</li>
<li>构造方法不能被 final 修饰 会影响 JAVA 类的初始化:</li>
<li>final 定义的静态常量调用时不会执行 static 代码块等相关语句，这是由 java 虚拟机规定的。我们不<br>
需要了解的很深，有个概念就可以了</li>
</ul>
<p><strong>修饰引用变量：</strong></p>
<ul>
<li>final 修饰引用变量，<code>主要修饰的是变量的地址</code>，那么这个引用只能指向一个对象，也就是说这个引用不能再次赋值，但被指向的对象是可以修改的</li>
</ul>
<pre><code class="language-java">public class FinalTest05 {
    public static void main(String[] args) {
        Person p1 = new Person();
        //可以赋值
        p1.name = &quot;张三&quot;;
        System.out.println(p1.name);
        final Person p2 = new Person();
        p2.name = &quot;李四&quot;;
        System.out.println(p2.name);
        //不能编译通过
        //p2 采用 final 修饰，主要限制了 p2 指向堆区中的地址不能修改(也就是 p2 只能指向一个对象)
        //p2 指向的对象的属性是可以修改的
        p2 = new Person();
    }
}
class Person {
    String name;
}
</code></pre>
<p><strong>final 和 static 联合修饰实例变量==常量</strong> （尽量使用一个静态工具类抽取出常量）</p>
<ul>
<li>常量名要求全部大写[规范]</li>
<li>常量都是 public static final 的</li>
<li>常量在类加载的时候完成初始化，存储在 JVM 的方法区中</li>
<li>常量是值不可改变的变量</li>
</ul>
<h3 id="5-代码块">5. 代码块</h3>
<blockquote>
<p>静态属性和静态代码块按照代码顺序执行，实例代码块和成员属性同理</p>
</blockquote>
<h4 id="静态代码块">静态代码块</h4>
<p><strong>使用 static 关键字可以定义静态语句块，静态语句块具有以下特点</strong>：</p>
<ul>
<li>静态语句块在类加载时执行，在 main 方法执行之前就已经执行了。</li>
<li>类只加载一次，所以静态语句块也是只执行一次</li>
<li>一个类中可以编写多个静态语句块，执行顺序是： 自上而下依次执行。</li>
<li>静态语句块的使用时机：当程序需要<code>在类加载的时候就做一些事情，可以在静态语句块中来实现</code></li>
</ul>
<h4 id="实例语句块">实例语句块</h4>
<p><strong>实例语句块和静态代码块没有关系，实例语句块有以下特点</strong>：</p>
<ul>
<li>实例语句块在构造方法执行之前执行，构造函数执行一次，实例语句块对应执行一次。</li>
<li>每调用一次构造函数之前就会执行一次实例语句块</li>
<li>实例语句块可以编写多个，也是按照自上而下的顺序依次执行。</li>
<li>实例语句块使用时机： 当程序需要<code>在对象初始化时刻就做一些事情，可以在实例语句块中实现</code></li>
</ul>
<pre><code class="language-java">//静态语句块
static{
	System.out.println(1);
}

//实例语句块
{
	System.out.println(1);
}
</code></pre>
<h3 id="6-类的继承">6. 类的继承</h3>
<p><strong>如何实现Java多继承？</strong></p>
<p><strong>继承特征</strong>：</p>
<ul>
<li>
<p>继承是面向对象的重要概念，软件中的继承和现实中的继承概念是一样的</p>
</li>
<li>
<p>继承是<strong>实现软件可重用性的重要手段</strong>，如： A 继承 B， A 就拥有了 B 的所有特性，如现实世界中的儿子继承父亲的财产，儿子不用努力就有了财产，这就是重用性</p>
</li>
<li>
<p>Java 中<strong>只支持类的单继承</strong>，也就是说 A 只能继承 B， A 不能同时继承 C</p>
</li>
<li>
<p>Java 中的继承使用 extends 关键字，语法格式：</p>
<pre><code class="language-java">[修饰符] class 子类 extends 父类 {
    
}  
</code></pre>
</li>
</ul>
<p><strong>方法的重载的条件</strong></p>
<ul>
<li>方法名相同</li>
<li><strong>方法的参数类型，个数，顺序至少有一个不同</strong></li>
<li>方法的返回类型可以不同（不依靠返回类型来区分重载）</li>
<li>方法的修饰符可以不同，因为方法重载和修饰符没有任何关系</li>
<li><strong>方法重载只出现在同一个类中</strong></li>
</ul>
<p><strong>方法的覆盖(Override)的条件：</strong></p>
<ul>
<li><code>必须要有继承关系</code></li>
<li>覆盖只能出现在子类中，如果没有继承关系，不存在覆盖，只存在重载</li>
<li>在子类中被覆盖的方法，必须和父类中的方法完全一样，也就是方法名， 返回类型、参数列表，<br>
完全一样</li>
<li><strong>子类方法的访问权限不能小于父类方法的访问权限</strong></li>
<li><strong>子类方法不能抛出比父类方法更多的异常，但可以抛出父类方法异常的子异常</strong></li>
<li><strong>父类的静态方法不能被子类覆盖</strong></li>
<li><strong>父类的私有方法不能覆盖</strong></li>
<li><strong>覆盖是针对成员方法，而非属性</strong></li>
</ul>
<p><strong>为什么需要覆盖？</strong></p>
<ul>
<li>就是要改变父类的行为。</li>
<li>方法重写之后，“子类对象”执行的一定是重写之后的方法，也体现了就近原则</li>
</ul>
<h3 id="7-static-构造方法和父子类的调用顺序">7. static、构造方法和父子类的调用顺序</h3>
<p><strong>要点</strong>：</p>
<ul>
<li>静态的代码块一定比构造方法先执行</li>
<li>如果都是静态代码，一个类里面，按照先后顺序执行，<strong>父子之间，父类静态代码块先执行</strong></li>
<li><strong>静态代码只会执行一次</strong>，多次 new 新的对象，构造方法，非静态代码块会多次执行</li>
</ul>
<pre><code class="language-java">class Parent {
    static {
        System.out.println(&quot;父类的静态块&quot;);
    }
    private static String staticStr = getStaticStr();
    private String str = getStr();
    {
        System.out.println(&quot;父类的实例块&quot;);
    }
    public Parent() {
        System.out.println(&quot;父类的构造方法&quot;);
    }
    private static String getStaticStr() {
        System.out.println(&quot;父类的静态属性初始化&quot;);
        return null;
    }
    private String getStr() {
        System.out.println(&quot;父类的实例属性初始化&quot;);
        return null;
    }
}

class Child extends Parent {
    private static String staticStr = getStaticStr();

    static {
        System.out.println(&quot;子类的静态块&quot;);
    }

    {
        System.out.println(&quot;子类的实例块&quot;);
    }

    public Child() {
        System.out.println(&quot;子类的构造方法&quot;);
    }

    private String str = getStr();

    private static String getStaticStr() {
        System.out.println(&quot;子类的静态属性初始化&quot;);
        return null;
    }

    private String getStr() {
        System.out.println(&quot;子类的实例属性初始化&quot;);
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        new Child();
    }
}
</code></pre>
<p><strong>分析</strong>：</p>
<ul>
<li>
<p>首先先加载类到JVM的方法区中，则先加载静态的内容，比如静态代码块和静态属性，并且先加载父类，且按照代码顺序加载</p>
</li>
<li>
<p>接着加载对象到堆内存中，先加载父类的实例语句块和实例属性，按照父类优先，根据代码顺序加载，最后加载构造方法</p>
</li>
</ul>
<p><strong>执行结果</strong>：</p>
<pre><code class="language-xml">父类的静态块
父类的静态属性初始化
子类的静态属性初始化
子类的静态块
父类的实例属性初始化
父类的实例块
父类的构造方法
子类的实例块
子类的实例属性初始化
子类的构造方法
</code></pre>
<h3 id="8-抽象类和接口">8. 抽象类和接口（***）</h3>
<h4 id="抽象类">抽象类</h4>
<p>看我们以前示例中的 Person、 Student 和 Employee，从我们使用的角度来看主要对 Student 和 Employee 进行实例化， Person 中主要包含了一些公共的属性和方法，而 Person 我们通常不会实例化，所以我们可以把它<br>
定义成抽象的：</p>
<ul>
<li>
<p>在 java 中采用 abstract 关键字定义的类就是抽象类，采用 abstract 关键字定义的方法就是抽象方法</p>
</li>
<li>
<p>抽象的方法只需在抽象类中，提供声明，不需要实现</p>
</li>
<li>
<p><strong>如果一个类中含有抽象方法，那么这个类必须定义成抽象类，一个抽象类不一定含有抽象方法</strong></p>
</li>
<li>
<p>如果这个类是抽象的，那么这个类被子类继承，抽象方法必须被重写。如果在子类中不复写该抽象方法，那么必须将此类再次声明为抽象类</p>
</li>
<li>
<p>抽象的类是不能实例化的，就像现实世界中人其实是抽象的，张三、李四才是具体的</p>
</li>
<li>
<p><strong>抽象类不能被 final 修饰</strong></p>
</li>
<li>
<p><strong>抽象方法不能被 final 修饰，因为抽象方法就是被子类实现的</strong></p>
</li>
</ul>
<p>抽象类中可以包含方法实现，可以将一些公共的代码放到抽象类中，另外在抽象类中可以定义一些抽象的方法，这样就会存在一个约束，而子类必须实现我们定义的方法，如： teacher 必须实现 printInfo 方法， Student也必须实现 printInfo 方法，方法名称不能修改，必须为 printInfo，这样就能实现多态的机制，有了多态的机制，我们在运行期就可以动态的调用子类的方法。所以在运行期可以灵活的互换实现。</p>
<p><strong>抽象类和普通类的区别？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">抽象类</th>
<th style="text-align:center">普通类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不能被实例化，也就是使用new关键字</td>
<td style="text-align:center">可以被实例化</td>
</tr>
<tr>
<td style="text-align:center">权限限定于Public和Protected，因为需要子类去继承抽象类<br/>JDK 1.8以前，抽象类的方法默认访问权限为protected<br/>JDK 1.8时，抽象类的方法默认访问权限变为default</td>
<td style="text-align:center">没有权限限制</td>
</tr>
<tr>
<td style="text-align:center">如果一个类继承抽象类，则必须实现抽象类的抽象方法<br/>如果没有实现抽象方法，则该类必须定义成抽象类</td>
<td style="text-align:center">不强制实现父类的方法</td>
</tr>
</tbody>
</table>
<h4 id="接口">接口</h4>
<blockquote>
<p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
</blockquote>
<p>接口我们可以看作是抽象类的一种特殊情况，在接口中<strong>只能定义抽象的方法和常量(完全抽象)</strong></p>
<ul>
<li>接口中的方法默认都是 public abstract 的(可以省略写)，不能更改</li>
<li>接口中的变量默认都是 public static final 的(省略不写)，不能更改，所以必须显示的初始化<br>
<code>注意：接口里的所有数据都是 public 修饰的！</code></li>
<li>如果一个非抽象的类实现了接口，那么接口中所有的方法必须实现</li>
<li>一类可以实现多个接口，接口和接口之间支持也是多继承的 ,但接口之间不能实现</li>
</ul>
<p>在 java 中接口其实描述了<strong>类需要做的事情，类要遵循接口的定义来做事</strong>，使用接口到底有什么本质的好<br>
处？可以归纳为两点：</p>
<ul>
<li>采用接口明确的声明了它所能提供的服务</li>
<li>解决了 Java 单继承的问题</li>
</ul>
<p><strong>接口和抽象类的区别？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">接口</th>
<th style="text-align:center">抽象类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不能被实例化</td>
<td style="text-align:center">不能被实例化</td>
</tr>
<tr>
<td style="text-align:center">需要被子类实现，并实现接口的方法</td>
<td style="text-align:center">需要被子类继承，并实现抽象方法</td>
</tr>
<tr>
<td style="text-align:center">只能做方法的声明（JDK1.8之后允许方法体）</td>
<td style="text-align:center">可以做方法的声明，也可以做方法的实现</td>
</tr>
<tr>
<td style="text-align:center">如果子类不能实现接口中的所有方法，则该类只能是抽象类</td>
<td style="text-align:center">如果子类不能实现抽象类的所有抽象，则该类只能是抽象类</td>
</tr>
<tr>
<td style="text-align:center">属性只能是静态的常量</td>
<td style="text-align:center">没有限制</td>
</tr>
<tr>
<td style="text-align:center">接口与接口之间可以多继承</td>
<td style="text-align:center">只能单继承</td>
</tr>
</tbody>
</table>
<h3 id="9-类之间的关系">9. 类之间的关系</h3>
<p><strong>泛化关系</strong></p>
<ul>
<li>类与类之间的继承以及接口与接口之间的继承</li>
</ul>
<p><strong>实现关系</strong></p>
<ul>
<li>类对接口的实现</li>
</ul>
<p><strong>关联关系</strong></p>
<ul>
<li>
<p>一个类中属性是另个类</p>
<pre><code class="language-java">public class 学生 {
    private 班级 班级;
    // getter/setter
}
public class 班级 {
}
</code></pre>
</li>
</ul>
<p><strong>聚合关系</strong></p>
<ul>
<li>
<p>是关联关系的一种，有着较强的关联关系</p>
</li>
<li>
<p>在java中一个类是整体，使用对象数组包含另个类；另个类属于某个整体</p>
<pre><code class="language-java">public class 汽车 {
    private 轮胎集合 轮胎；
    //getter/setter
}
public class 轮胎 {
    private 汽车 汽车;
    //getter/setter
}
</code></pre>
</li>
</ul>
<p><strong>依赖关系</strong></p>
<ul>
<li>
<p>依赖关系是比关联关系弱的关系，在 java 语言中体现为<strong>返回值，参数，局部变量和静态方法调用</strong></p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Person person = new Person();
    }
}
class Person {
}
</code></pre>
</li>
</ul>
<h3 id="10-object类">10. Object类</h3>
<ul>
<li>Object 类是所有 Java 类的根基类</li>
<li>如果在类的声明中未使用 extends 关键字指明其基类，则默认基类为 Object 类</li>
</ul>
<h4 id="equals">equals</h4>
<p><strong>equals的源码是这样写的</strong>：</p>
<pre><code class="language-java">public boolean equals(Object obj) {
    //this - s1
    //obj - s2
    return (this == obj);
}
</code></pre>
<p>所以，默认情况下比较的是地址值，但是可以让我们覆写该方法，实现对象的比较。</p>
<p><strong>如何覆写equals方法？</strong></p>
<ul>
<li>首先为了提高效率，需要用==判断是否是同一个对象，如果是直接返回true</li>
<li>接着为了提高健壮性，判断是否对象是否是该类的一个对象，如果是，需要对其向下转型</li>
<li>最后是比较的逻辑</li>
</ul>
<pre><code class="language-java">public class ObjectDemo {
    public static void main(String args[]){
        Student student1 = new Student(&quot;生命壹号&quot;,22,&quot;成都&quot;);
        Student student2 = new Student(&quot;生命壹号&quot;,22,&quot;成都&quot;); 
        System.out.println(student1==student2);
        System.out.println(student1.equals(student2));
    }
 }
 class Student {
     private String name;
     private int age;
     private String address;
     public Student(String name,int age,String address){
         this.name = name;
         this.age = age;
         this.address = address;
     }
     //重写Object类中的equals方法（比较两个对象的值是否相等）
     public boolean equals(Object obj){
         //为了提高效率：如果两个内存地址相等，那么一定是指向同一个对内存中的对象，就无需比较两个对象的属性值（自己跟自己比，没啥意义嘛）
         if(this==obj){
             return true;
         }
         
         //为了提供程序的健壮性
         //我先判断一下，obj是不是学生的一个对象，如果是，再做向下转型，如果不是，直接返回false。
         //这个时候，我们要判断的是对象是否是某个类的对象?
         //记住一个格式：对象名 instanceof 类名。表示：判断该对象是否是该类的一个对象       
         if(!(obj instanceof Student)){        
             return false;                
         }
         
         //如果是就继续
         Student s = (Student)obj;//强制转换，即向下转型（毕竟Object类型没有具体的对象属性）        
         return this.name.equals(s.name) &amp;&amp; this.age == s.age &amp;&amp; this.address.equals(s.address);//判断两个对象的属性值是否相等
     }
 }
</code></pre>
<p><strong>==与 equals()区别？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">==</th>
<th style="text-align:center">equals()</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">等号比较的是值， 特别是比较引用类型，比较的是引用的内存地址的那个值</td>
<td style="text-align:center">默认源码使用的是==，但是可以通过覆写该方法，实现对象的比较</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于基本数据的包装类型（Byte, Short, Character，Integer， Float, Double， Long, Boolean）除了 Float和 Double 之外，其他的六种都是<strong>实现了常量池的</strong>，因此对于这些数据类型而言，一般我们<strong>也可以直接通过==来判断是否相等</strong></p>
</blockquote>
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        Integer a = 127;
        Integer b = 127;
        System.out.println(a==b);//true

        Integer c = 128;
        Integer d = 128;
        System.out.println(c==d);//false
    }
}
</code></pre>
<blockquote>
<p>因为 Integer 在常量池中的存储范围为[-128,127]， 127 在这范围内，因此是直接存储于常量池的，而<br>
128 不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以 m， n 分别指向了两个不同的<br>
对象地址，故而导致了不相等。</p>
</blockquote>
<h4 id="finalize">finalize</h4>
<p>当垃圾收集器将要收集某个垃圾对象时将会调用 finalize，<strong>建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行</strong></p>
<p>JVM当看到对象类含有finalize函数，会将该对象交给FinalizerThread处理，但是处理的时间不确定。</p>
<h3 id="11-访问控制权限">11. 访问控制权限</h3>
<p><strong>范围由大到小的排序</strong>：<code>public &gt; protected &gt; 缺省 &gt; private</code></p>
<blockquote>
<p>对类的修饰只有public和缺省，内部类除外</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">类的内部</th>
<th style="text-align:center">同一个包中</th>
<th style="text-align:center">子类</th>
<th style="text-align:center">任何地方</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"><code>Y</code></td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">Y</td>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p><strong>总结为一句话</strong>：<code>private修饰的只能类的内部调用；缺省的可以在一个包中调用；protected扩展到了子类中，比如继承某个类，则可以使用那个类的属性和方法；public可以在任何地方访问。</code></p>
<h3 id="12-内部类">12 内部类</h3>
<p><strong>分为四种内部类</strong>：</p>
<ul>
<li><strong>实例内部类</strong>：在类的内部定义的普通类</li>
<li><strong>静态内部类</strong>：在类的内部定义的静态类</li>
<li><strong>局部内部类</strong>：在方法中定义的普通类</li>
<li><strong>匿名内部类</strong>：方法使用中定义的普通类，主要用来实现接口</li>
</ul>
<h4 id="实例内部类">实例内部类</h4>
<p><strong>特点</strong>：</p>
<ul>
<li>创建实例内部类，外部类的实例必须已经创建</li>
<li>实例内部类会持有外部类的引用，可以直接访问外部类的属性</li>
<li>不允许有静态声明</li>
</ul>
<pre><code class="language-java">public class OuterClass
{
    //静态变量
    private static String s1 = &quot;静态变量&quot;;
    //实例变量
    private String s2 = &quot;实例变量&quot;;
    //实例内部类
    public class InnerClass
    {
        //编译错误，实例内部类中不允许有静态的声明
        public static void m1(){}
        //实例方法
        public void m2(){
            System.out.println(s1);
            System.out.println(s2);
        }
    }
    //入口
    public static void main(String[] args){
        OuterClass oc = new OuterClass();
        InnerClass innerClass = oc.new InnerClass();//??
        innerClass.m2();
    }
}
</code></pre>
<h4 id="静态内部类"><strong>静态内部类</strong></h4>
<p><strong>特点</strong>：</p>
<ul>
<li>静态内部类不会持有外部的类的引用</li>
<li>创建时可以不用创建外部类，在静态内部类中只能直接访问外部类中所有的静态数据。</li>
<li>静态内部类等同于静态变量</li>
</ul>
<pre><code class="language-java">public class OuterClass
{
    //静态变量
    private static String s1 = &quot;静态变量&quot;;
    //实例变量
    private String s2 = &quot;实例变量&quot;;
    //静态内部类
    //静态内部类可以使用任何一个访问控制权限修饰符修饰。
    protected static class InnerClass{
        //静态方法
        public static void m1(){
            System.out.println(s1);
        //System.out.println(s2);
        }
        //实例方法
        public void m2(){
            System.out.println(s1);
        //System.out.println(s2);
        }
    } //入口
    public static void main(String[] args){
        OuterClass.InnerClass.m1();//外部类.可以省略
        InnerClass innerClass = new OuterClass.InnerClass();
        innerClass.m2();
    }
}
</code></pre>
<h4 id="局部内部类">局部内部类</h4>
<ul>
<li>局部内部类等同于局部变量</li>
<li>局部内部类是在方法体中声明的类，该类只能在方法体中使用</li>
<li>局部内部类不能使用 public 、 protected 、 private 修饰</li>
<li><code>局部内部类访问本地变量的时候，方法中的参数需要使用 final 修饰</code></li>
</ul>
<pre><code class="language-java">public class OuterClass {
    private int a = 100;
    //局部变量在内部类中使用必须采用 final 修饰
    public void method1(final int temp) {
        class Inner3 {
            int i1 = 10;
            //可以访问外部类的成员变量
            int i2 = a;
            int i3 = temp;
        }
        //使用内部类
        Inner3 inner3 = new Inner3();
        System.out.println(inner3.i1);
        System.out.println(inner3.i3);
    }
    public static void main(String[] args) {
        OuterClass out = new OuterClass ();
        out.method1(300);
    }
}
</code></pre>
<h4 id="匿名内部类">匿名内部类</h4>
<ul>
<li>是一种特殊的内部类，该类没有名字</li>
<li>通过new 关键字创建，并加上方法体</li>
<li>主要用于实现接口</li>
</ul>
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        //在方法中实现接口
        new Thread(new Runnable() {
            @Override
            public void run() {
                
            }
        }).run();
    }
}
</code></pre>
<h2 id="四-异常">四、异常</h2>
<blockquote>
<p>任意的异常都是在运行时发生的！！！</p>
</blockquote>
<h3 id="1-异常的体系">1. 异常的体系</h3>
<p><code>所有的异常都是Throwable的子类</code></p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctMTMwMjQ3NDEwMy5jb3MuYXAtbmFuamluZy5teXFjbG91ZC5jb20vaW1nL2ltYWdlLTIwMjAwNjI4MTA1MTE2MjM4LnBuZw?x-oss-process=image/format,png" alt="image-20200628105116238" loading="lazy"></figure>
<p><strong>Thorwable有两个直接子类Error和Exception</strong></p>
<p><strong>Error</strong>:</p>
<ul>
<li>在 Java 中只要 Error 发生了就一种结果——退出 JVM，例如 StackOverError</li>
</ul>
<p><strong>Exception的直接子类</strong>：</p>
<ul>
<li>
<p>Exception 的直接子类叫做<strong>编译时异常、受控异常、检查异常</strong>。它虽然叫做编译时异常，但是它不是发<br>
生在编译阶段的异常， 之所以叫做编译时异常是因为编译时异常要求必须在程序编译的阶段就手动的处理，如果不处理这些异常的话，程序无法编译通过。</p>
</li>
<li>
<p>对于编译时异常有两种手段处理，<strong>一是 try catch 捕获，一是 throws 抛出</strong></p>
</li>
</ul>
<p><strong>RuntimeException 的直接子类</strong>：</p>
<ul>
<li>RuntimeException 的直接子类叫做<strong>运行时异常、非受控异常、非检查异常</strong>。这种异常不要求在程序编译<br>
阶段处理，编译也可以通过</li>
<li>比如说除0异常</li>
</ul>
<p><strong>自定义异常</strong>：</p>
<ul>
<li>JDK 提供的异常不能够满足要求的情况下用户可以自己自定义异常，可以根据实际情况选择继承Exception 或者 RuntimeException 两种形式。</li>
</ul>
<h3 id="2-说出几个常见的异常">2. 说出几个常见的异常</h3>
<p><strong>Error</strong></p>
<ul>
<li>StackOverError（堆溢出）</li>
<li>OutOfMemoryError（内存溢出）</li>
</ul>
<p><strong>受控异常</strong></p>
<ul>
<li>IOException（IO异常）</li>
<li>SQLException（SQL异常）</li>
<li>ClassNotFoundException（找不到指定的类异常）</li>
</ul>
<p><strong>不受控异常</strong></p>
<ul>
<li>
<p>NullPointerException（空指针异常）</p>
</li>
<li>
<p>ArithmeticException（算术异常）</p>
</li>
<li>
<p>ArrayIndexOutOfBoundsException（数组下表越界异常）</p>
</li>
</ul>
<h3 id="3-异常处理">3. 异常处理</h3>
<blockquote>
<p><code>异常的捕获应该从小到大</code></p>
</blockquote>
<p><strong>一般有两种方式</strong></p>
<ul>
<li>try...catch...finally....</li>
<li>thorws抛给调用者</li>
</ul>
<p><strong>finally 在任何情况下都会执行，除非JVM挂掉，通常在 finally 里关闭资源</strong></p>
<pre><code class="language-java">public class ExceptionTest12 {
    public static void main(String[] args) {
        int r = method1();
        //输出为： 100？ 50？
        System.out.println(r);//输出是50
    }
    private static int method1() {
        int a = 10;
        try {
            a = 50;
            return a;//直接返回值
        }finally {
            a = 100;//该语句也会执行，只是a已经返回
        }
    }
}
</code></pre>
<p><strong>throws 和 throw 的区别 ？</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">throws</th>
<th style="text-align:center">throw</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">thorws 是声明异常</td>
<td style="text-align:center">thorws 是声明异常</td>
</tr>
<tr>
<td style="text-align:center">用在函数上</td>
<td style="text-align:center">用在函数内部</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秒杀策略（缓存+消息队列）]]></title>
        <id>https://xzzz2020.github.io/post/k_uLsJY6w/</id>
        <link href="https://xzzz2020.github.io/post/k_uLsJY6w/">
        </link>
        <updated>2020-06-27T04:07:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>该项目为仅供个人学习使用！！！<br>
个人博客地址：<a href="https://blog.csdn.net/qq_43040688">https://blog.csdn.net/qq_43040688</a><br>
个人网站地址：<a href="http://www.xzzz2020.cn/">http://www.xzzz2020.cn/</a></p>
</blockquote>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B">一、项目简介</a></li>
<li><a href="#%E4%BA%8C-%E6%8A%80%E6%9C%AF%E6%A0%88">二、技术栈</a></li>
<li><a href="#%E4%B8%89-%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0">三、详细实现</a>
<ul>
<li><a href="#31-%E5%88%86%E5%B8%83%E5%BC%8Fsession">3.1 分布式Session</a></li>
<li><a href="#32-%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98-url%E7%BC%93%E5%AD%98">3.2  页面缓存 + URL缓存</a></li>
<li><a href="#33-%E5%AF%B9%E8%B1%A1%E7%BA%A7%E7%BC%93%E5%AD%98">3.3 对象级缓存</a></li>
<li><a href="#34-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96">3.4 核心接口优化</a></li>
<li><a href="#35-%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96">3.5 接口安全优化</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">四、 项目实践中遇到的问题</a>
<ul>
<li><a href="#41-%E7%A7%92%E6%9D%80%E6%88%90%E5%8A%9F%E5%95%86%E5%93%81%E8%AE%A2%E5%8D%95%E6%95%B0%E8%B6%85%E8%BF%87%E9%A2%84%E8%AE%A2%E6%95%B0%E5%80%BC">4.1  秒杀成功商品订单数超过预订数值</a></li>
<li><a href="#42-%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%87%B4%E7%A7%92%E6%9D%80%E6%88%90%E5%8A%9F%E7%A7%92%E6%9D%80%E5%A4%9A%E6%AC%A1">4.2  一个用户的多个请求导致秒杀成功秒杀多次</a></li>
<li><a href="#43-%E4%BD%BF%E7%94%A8%E4%BA%86%E7%BC%93%E5%AD%98%E4%BE%9D%E7%84%B6%E4%BC%9A%E5%A4%A7%E9%87%8F%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93">4.3 使用了缓存依然会大量访问数据库</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">五、 接下来的优化思路</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="一-项目简介">一、项目简介</h2>
<p>该项目主要学习常用的高并发优化技术，并发的瓶颈往往在数据库，采用缓存和消息队列对接口进行优化减少对数据优化，掌握面对高并发场景下的设计思路：</p>
<ul>
<li>以 <strong>Spring Boot</strong> 为主线的技术栈，使用了 <strong>Mybatis+Druid</strong> ，采用<strong>前后端分离</strong>架构</li>
<li>整个项目基于商品的 <strong>秒杀接口</strong>，设计登录、商品展示以及订单展示等一系列的功能</li>
<li>接口高并发的优化主要利用 <strong>Redis实现页面缓存 + URL缓存 + 对象缓存</strong> ，利用 <strong>前后端分离实现页面静态化</strong> 以及整合 <strong>RabbitMQ实现异步下单</strong> 的优化。<code>QPS优化至少两倍</code></li>
<li>用户登录信息使用 <strong>Cookie+Redis实现分布式Session</strong> ，使用 <strong>拦截器+自定义参数解析器</strong> ，获取用户信息。<code>解决了不同服务器之间出现的缓存不一致或者服务器宕机Session消失的问题</code></li>
<li>接口安全实现了 <strong>秒杀接口地址隐藏 + 数学公式验证码 + 利用Redis实现接口防刷</strong>。<code>防止机器人对于核心业务的攻击</code></li>
<li>利用<strong>Jmeter模拟5000个用户，使用1万个线程</strong>，对商品展示接口和秒杀接口进行压测。<code>商品展示接口优化前QPS：584.8，优化后QPS：2085.9；秒杀接口优化前QPS：351.8，优化后QPS：2242.7</code></li>
</ul>
<h2 id="二-技术栈">二、技术栈</h2>
<p><strong>前端</strong></p>
<ul>
<li><code>Bootstrap</code></li>
<li><code>Ajax</code></li>
<li><code>thymeleaf</code></li>
</ul>
<p><strong>后端</strong></p>
<ul>
<li><code>SpringBoot</code></li>
<li><code>Mybatis</code></li>
<li><code>Druid</code></li>
<li><code>Jedis</code></li>
<li><code>fastjson</code></li>
</ul>
<p><strong>数据库</strong></p>
<ul>
<li><code>MySQL</code></li>
<li><code>Redis</code></li>
</ul>
<p><strong>中间件</strong></p>
<ul>
<li><code>RabbitMQ</code></li>
</ul>
<p><strong>测试</strong></p>
<ul>
<li><code>Jmeter</code></li>
</ul>
<h2 id="三-详细实现">三、详细实现</h2>
<h3 id="31-分布式session">3.1 分布式Session</h3>
<p>常用的有三种分布式Session解决方案：<code>服务器之间Session共享</code>、<code>Session绑定</code>、<code>Cookie+缓存</code>。<strong>本项目使用的就是Cookie+缓存的方式</strong>。下面将介绍这几种方式：</p>
<blockquote>
<p><strong>服务器之间Session共享</strong>：</p>
<ul>
<li>使用一台作为用户的登录服务器，当用户登录成功之后，会将session写到当前服务器上，我们通过脚本或者守护进程将session同步到其他服务器上，这时当用户跳转到其他服务器，session一致，也就不用再次登录。</li>
<li><strong>缺陷</strong>：速度慢，同步session有延迟性，可能导致跳转服务器之后，session未同步。而且单向同步时，登录服务器宕机，整个系统都不能正常运行。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Session绑定</strong>：</p>
<ul>
<li>基于nginx的ip-hash策略，可以对客户端和服务器进行绑定，同一个客户端就只能访问该服务器，无论客户端发送多少次请求都被同一个服务器处理</li>
<li><strong>缺陷</strong>：容易造成单点故障，如果有一台服务器宕机，那么该台服务器上的session信息将会丢失前端不能有负载均衡，如果有，session绑定将会出问题</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Cookie+缓存</strong></p>
<ul>
<li>将用户信息保存在<code>Redis</code>上，将键值放在<code>Cookie</code>中传递给浏览器，浏览器再下一次的访问中就会携带该Cookie。此时利用<code>拦截器+自定义参数解析器</code> 解析用户的Cookie，从缓存中获取数据传递给方法。</li>
</ul>
</blockquote>
<p><strong>部分代码如下：</strong></p>
<blockquote>
<p>利用Cookie + 加缓存保存用户信息</p>
</blockquote>
<pre><code class="language-java">/**
 * 分布式Session的思路是将数据存放在Redis中
 * 将数据的key放在cookie中发送给用户
 * 用户会携带cookie访问
 * 获取期中的token，从redis中获取
 * 每次访问都会生成一个新的，延长有效期
 */
private void addCookie(HttpServletResponse response, String token, MiaoshaUser user) {
    //生成Cookie
    //生成一个随机字符串token，去掉&quot;-&quot;
    //将token + 加上Redis通用缓存Key，保存在redis中
    redisService.set(MiaoshaUserKey.getByToken(), token, user);
    //生成Cookie，只将token存放在cookie,防止用户获取其他用户信息
    Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);
    //将Cookie的时间和Redis缓存时间一直
    cookie.setMaxAge(MiaoshaUserKey.getByToken().expireSeconds());
    //将Cookie存放在根目录
    cookie.setPath(&quot;/&quot;);
    ////将Cookie返回给浏览器
    response.addCookie(cookie);
}
</code></pre>
<h3 id="32-页面缓存-url缓存">3.2  页面缓存 + URL缓存</h3>
<p>页面缓存和URL缓存主要差异在于URL缓存<strong>会根据URL的变化，数据会有所不同</strong>，如某个商品的详细信息、视频的详细信息等。</p>
<p>故只介绍商品列表页面缓存技术：</p>
<blockquote>
<p><strong>页面缓存</strong></p>
<ul>
<li>当客户的请求到达后端时，<code>先去redis中查询缓存，如果缓存中找不到，则进行数据库逻辑操作，然后渲染，存入缓存并返回给前端</code></li>
<li>如果在缓存中找到了则直接返回给前端。</li>
<li>存储在Redis缓存中的页面需要设置超时时间，缓存的时间长度根据页面数据变化频繁程度适当调整。目前大多数页面<code>缓存都是在60~120秒</code>，少数几乎不变化的可以调整到5分钟!</li>
</ul>
</blockquote>
<p><strong>部分代码实现</strong>：</p>
<blockquote>
<p>商品列表的Controller层</p>
</blockquote>
<pre><code class="language-java">    @RequestMapping(value = &quot;/to_list&quot;, produces = &quot;text/html&quot;)
    @ResponseBody
    public String toGoods(Model model, MiaoshaUser user,
                          final HttpServletRequest request,
                          final HttpServletResponse response) {

        //取缓存
        String html;
        html = redisService.get(GoodsKey.getGoodsList(), &quot;&quot;, String.class);
        if (html != null) {//如果缓存有这个页面
            return html;
        } else {//如果没有这个页面
            //访问数据库获取商品数据
            List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();
            if (user != null) {
                //如果有用户信息，则保存在Model中
                model.addAttribute(&quot;user&quot;, user);
            }
            //将商品数据保存在Model中
            model.addAttribute(&quot;goodsList&quot;, goodsList);

            //手动渲染
            SpringWebContext springWebContext = new SpringWebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap(), context);
            html = viewResolver.getTemplateEngine().process(&quot;goods_list&quot;, springWebContext);
            if (!StringUtils.isEmpty(html)) {
                //保存到缓存，缓存时间只有60秒，不宜过长
                redisService.set(GoodsKey.getGoodsList(), &quot;&quot;, html);
            }
            //返回到浏览器
            return html;
        }

    }
</code></pre>
<p><strong>接下来使用Jmeter启动1万个线程进行压测：</strong></p>
<blockquote>
<p>优化前，可以看的<code>吞吐量达到584.8</code><br>
<img src="en-resource://database/948:1" alt="55bc54085c699c92fc6a66b4986169c9.png" loading="lazy"></p>
</blockquote>
<blockquote>
<p>优化后，可以看的<code>吞吐量达到2085.9</code><br>
<img src="en-resource://database/946:1" alt="87002fe601459eaaff41c543660a6592.png" loading="lazy"></p>
</blockquote>
<h3 id="33-对象级缓存">3.3 对象级缓存</h3>
<p>相比页面缓存是更细粒度缓存。在实际项目中， 不会大规模使用页面缓存，因为涉及到分页，一般只缓存前面1-2页。对象缓存就是 当用到用户数据的时候，可以从缓存中取出。</p>
<p><strong>需要注意两个问题</strong>：</p>
<ul>
<li>一旦数据发生更改，一定要将缓存失效</li>
<li>Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存</li>
</ul>
<p><strong>部分代码实现</strong>：</p>
<blockquote>
<p>保存用户信息</p>
</blockquote>
<pre><code class="language-java">/**
 * 这个是对象级的缓存
 * 从缓存中取出用户信息
 * &lt;p&gt;
 * 和页面缓存最大的区别是：1.时间是永久的 2.当对象发生更新时，需删除或者更新缓存
 * &lt;p&gt;
 * 从这里可以看出，Service之间相互调用，切忌不能直接调用DAO，因为可能中间调用了缓存
 */
public MiaoshaUser getById(long id) {
    //取缓存
    MiaoshaUser user;
    user = redisService.get(MiaoshaUserKey.getById(), &quot;:&quot; + id, MiaoshaUser.class);
    if (user != null) {
        return user;
    } else {
        //取数据库，加入到缓存中
        user = miaoshaUserDao.getById(id);
        redisService.set(MiaoshaUserKey.getById(), &quot;:&quot; + id, user);
        return user;
    }
}
</code></pre>
<h3 id="34-核心接口优化">3.4 核心接口优化</h3>
<blockquote>
<p><strong>核心的业务接口优化主要思路是</strong>：</p>
<ul>
<li>使用利用Redis保存<code>商品库存的数量</code>、<code>用户的秒杀成功的订单信息</code>和<code>商品是否秒杀完的标记</code>，这样请求更多的访问缓存，减少对数据库的压力</li>
<li>若用户秒杀成功，利用<code>RabbitMQ实现异步下单，服务器控制访问数据库的压力，让用户暂时等待</code>，这样可以优化用户的体验，防止出现服务器宕机等问题</li>
</ul>
</blockquote>
<p><strong>部分代码如下所示</strong>：</p>
<blockquote>
<p>秒杀接口Controller</p>
</blockquote>
<pre><code class="language-java">@RequestMapping(value = &quot;/{path}/do_miaosha&quot;, method = RequestMethod.POST)
@ResponseBody
public Result&lt;Integer&gt; do_miaosha(MiaoshaUser user,
                                  @RequestParam(&quot;goodsId&quot;) long goodsId,
                                  @PathVariable(&quot;path&quot;) String path) {

    //判断用户是否登录，如果没用登录，则传递提示信息
    if (user == null) {
        return Result.error(CodeMsg.SESSION_ERROR);
    }

    //隐藏了访问接口，需要验证path
    if (StringUtils.isEmpty(path)) {
        return Result.error(CodeMsg.REQUEST_ILLEGAL);
    }
    boolean check = miaoshaService.checkPath(path, user.getId(), goodsId);
    if (!check) {
        return Result.error(CodeMsg.REQUEST_ILLEGAL);
    }
    
    //判断是否秒杀到了
    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);
    //如果能够获取订单，说明该用户已经秒杀到商品
    if (order != null) {
        return Result.error(CodeMsg.REPEATE_MIAO_SHA);
    }
    //判断是否秒杀已经结束
    Boolean over = localOverMap.get(goodsId);
    if (over) {
        return Result.error(CodeMsg.MIAO_SHA_OVER);
    }

    //预减库存
    long stock = redisService.decr(GoodsKey.getMiaoGoodsStock(), &quot;:&quot; + goodsId);
    if (stock &lt; 0) {//如果发现库存不足，则将秒杀结束的标记置成true
        localOverMap.put(goodsId, true);
        return Result.error(CodeMsg.MIAO_SHA_OVER);
    }

    //保存信息
    MiaoshaMessage miaoshaMessage = new MiaoshaMessage();
    miaoshaMessage.setGoodsId(goodsId);
    miaoshaMessage.setUser(user);
    //入队，实现异步下单
    mqSender.sendMiaoshaMessage(miaoshaMessage);
    //返回客户端订单处理中
    return Result.success(0);//排队中
}
</code></pre>
<blockquote>
<p>消息的发送者</p>
</blockquote>
<pre><code class="language-java">public void sendMiaoshaMessage(MiaoshaMessage miaoshaMessage) {
    //将数据序列化字符串
    String str = SerializableUtil.beanToString(miaoshaMessage);
    //发送消息
    amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE,str);
}
</code></pre>
<blockquote>
<p>消息的接收者</p>
</blockquote>
<pre><code class="language-java">@RabbitListener(queues = MQConfig.MIAOSHA_QUEUE)
public void miaoshaReceive(String message) {
    //将消息反序列化
    MiaoshaMessage miaoshaMessage = SerializableUtil.stringToBean(message, MiaoshaMessage.class);
    //获取用户
    MiaoshaUser user = miaoshaMessage.getUser();
    //获取用户id
    long goodsId = miaoshaMessage.getGoodsId();
    //再次判断库存是否足够
    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
    Integer stockCount = goods.getStockCount();
    //如果库存不足，则直接返回
    if (stockCount &lt;= 0) {
        return;
    }
    //减库存 下订单 写入订单 一个事务中
    miaoshaService.miaosha(user, goods);
}
</code></pre>
<blockquote>
<p>订单的处理</p>
</blockquote>
<pre><code class="language-java">@Transactional
public OrderInfo miaosha(MiaoshaUser user, GoodsVo goods) {
    //减库存
    boolean success = goodsService.reduceStock(goods);
    if (success){
        //下订单
        return orderService.creatOrder(user,goods);
    }else {
        //如果库存不足，设置商品已经卖完
        setGoodsOver(goods.getId());
    }
    return null;
}

/**
 * 设置商品已经卖完
 */
private void setGoodsOver(Long id) {
    redisService.set(MiaoshaKey.getMiaoshaOver(),&quot;:&quot;+id,true);
}
</code></pre>
<p><strong>接下来使用Jmeter启动1万个线程，模拟5000个用户进行压测</strong>：</p>
<blockquote>
<p>优化前，可以看的<code>吞吐量达到351.8</code><br>
<img src="en-resource://database/950:1" alt="d1c3599b1b848a55b7270ab5e2491162.png" loading="lazy"></p>
</blockquote>
<blockquote>
<p>优化后，可以看的<code>吞吐量达到2242.7</code><br>
<img src="en-resource://database/952:1" alt="cfd03964c83a1181d88a19802e1d1f84.png" loading="lazy"></p>
</blockquote>
<h3 id="35-接口安全优化">3.5 接口安全优化</h3>
<p>接口的安全优化主要的防止恶意用户的访问，以及减少瞬时用户的并发量</p>
<blockquote>
<p><strong>接口隐藏</strong></p>
</blockquote>
<ul>
<li>由于前端的代码在浏览器，所以可以轻易的获取到核心业务的接口</li>
<li><strong>解决</strong>：地址是在客户端动态生成的，前端需要先获取地址信息，然后在发送给服务器，服务器会对浏览器的地址进行处理并和真实的地址进行比较</li>
</ul>
<blockquote>
<p><strong>数学问题验证码</strong></p>
<ul>
<li>验证码主要防止机器人的大量访问，以及将用户的请求分散开，避免集中的下单<br>
<strong>解决</strong>：服务器生成验证码，通过前端输入进行验证</li>
</ul>
</blockquote>
<blockquote>
<p><strong>接口防刷</strong></p>
<ul>
<li>恶意用户可能会大量的访问服务器，给服务器造成压力<br>
<strong>解决</strong>：利用缓存，保存一定时间的访问数，如果超过一定限制，则直接拒绝访问</li>
</ul>
</blockquote>
<h2 id="四-项目实践中遇到的问题">四、 项目实践中遇到的问题</h2>
<h3 id="41-秒杀成功商品订单数超过预订数值">4.1  秒杀成功商品订单数超过预订数值</h3>
<p><strong>问题分析</strong>：</p>
<ul>
<li>该问题主要因为在高并发下，线程不安全导致的</li>
<li>在判断是否秒杀成功时，多个用户通过了判断，然后才减少了库存</li>
</ul>
<p><strong>问题解决</strong>：</p>
<ul>
<li>MySQL数据库在更新数据时，会自动加锁</li>
<li>在SQL语句中减少库存时，判断库存是否大于0，如果不是则执行失败，订单回滚</li>
</ul>
<h3 id="42-一个用户的多个请求导致秒杀成功秒杀多次">4.2  一个用户的多个请求导致秒杀成功秒杀多次</h3>
<p><strong>问题分析</strong>：</p>
<ul>
<li>由于采用的异步下单，在该用户订单没有完成时，则可能会出现一个用户同时下多个订单</li>
</ul>
<p><strong>问题解决</strong>：</p>
<ul>
<li>设计数据库表时，多设计一个秒杀的订单，和普通的订单分离</li>
<li>在秒杀订单上，user_id采用唯一索引</li>
</ul>
<h3 id="43-使用了缓存依然会大量访问数据库">4.3 使用了缓存依然会大量访问数据库</h3>
<p><strong>问题分析</strong>：</p>
<ul>
<li>由于为了简便，在Service上面统统加了@Transactional注解，会导致所有的方法启用事务</li>
<li>此时即使使用了缓存，也依然会访问数据库，最终造成数据库压力过大</li>
</ul>
<p><strong>问题解决</strong>：</p>
<ul>
<li>只在需要事务的方法上使用@Transactiona注解，提高性能</li>
</ul>
<h2 id="五-接下来的优化思路">五、 接下来的优化思路</h2>
<ul>
<li><code>静态资源优化</code></li>
<li><code>CDN加速</code></li>
<li><code>Nginx水平扩展</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[贪心策略]]></title>
        <id>https://xzzz2020.github.io/post/-Soxdr6Ou/</id>
        <link href="https://xzzz2020.github.io/post/-Soxdr6Ou/">
        </link>
        <updated>2020-06-25T13:55:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E8%B4%AA%E5%BF%83%E7%9A%84%E7%89%B9%E7%82%B9">贪心的特点</a></li>
<li><a href="#%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90">实际例子</a>
<ul>
<li><a href="#1-%E7%A1%AC%E5%B8%81%E6%94%AF%E4%BB%98%E9%97%AE%E9%A2%98">1. 硬币支付问题</a></li>
<li><a href="#2-%E5%B0%8F%E8%88%B9%E6%B8%A1%E6%B2%B3%E9%97%AE%E9%A2%98">2. 小船渡河问题</a></li>
<li><a href="#3-%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">3. 区间调度问题（二维数组排序）</a></li>
<li><a href="#4-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9">4. 区间选点</a></li>
<li><a href="#5-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98">5. 区间覆盖问题</a></li>
<li><a href="#6-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98">6. 字典序最小问题</a></li>
<li><a href="#7-%E4%B9%98%E8%88%B9%E9%97%AE%E9%A2%98">7. 乘船问题</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="简介">简介</h2>
<ul>
<li>无论是DFS还是BFS都是遍历解空间</li>
<li>动态规划和贪心算法都是一种递推算法，运用<strong>局部最优解</strong>来推到全局最优解</li>
<li>是对<strong>遍历解空间</strong>的一种优化</li>
<li>当问题具有<strong>最优子结构</strong>的时候，可以用动归，而贪心是动归的特例。</li>
</ul>
<h2 id="贪心的特点">贪心的特点</h2>
<ul>
<li><strong>只看眼前</strong>。根据某种规则，不断的选取当前策略，最终找到最优解</li>
<li><strong>主要需要不断的举例，去猜测出一个贪心策略。</strong></li>
</ul>
<p><strong>注意</strong>：当前最优的未必是整体最优</p>
<h2 id="实际例子">实际例子</h2>
<h3 id="1-硬币支付问题">1. 硬币支付问题</h3>
<blockquote>
<p>硬币问题<br>
有1元,5元,10元,50元,100元,500元的硬币各c1,c5,c10,c50,c100,c500枚.<br>
现在要用这些硬币来支付A元,最少需要多少枚硬币?<br>
假定本题至少存在一种支付方案.<br>
0≤ci≤10^9<br>
0≤A≤10^9<br>
输入:<br>
第一行有六个数字,分别代表从小到大6种面值的硬币的个数<br>
第二行为A,代表需支付的A元<br>
样例:<br>
输入<br>
3 2 1 3 0 2<br>
620<br>
输出<br>
6</p>
</blockquote>
<pre><code class="language-java"> /**
  * 尽量先用大面值,因为不用大面值,将使用更多的小面值硬币,一定得不到最优解
  */
public class Main {
    static int [] cin = new int[6];

    public static void main(String[] args) throws InterruptedException {
        Scanner scanner = new Scanner(System.in);

        int money ;
        int ans = 0;
        for (int i = 0; i &lt; 6; i++) {
            cin[i] = scanner.nextInt();
        }
        int [] coins = new int[]{1,5,10,50,100,500};
        money = scanner.nextInt();
        for (int i = 5; i &gt;=0; i--) {
            int x = money/coins[i];//金额有多少个coins[i]
            int t = Math.min(cin[i],x);//当前面值的硬币有cin[i]个
            ans += t;
            money -= t*coins[i];
        }
        System.out.println(ans);
    }

}
</code></pre>
<h3 id="2-小船渡河问题">2. 小船渡河问题</h3>
<blockquote>
<p>N个人过河，船每次最多只能坐两个人，船载每个人过河的所需时间不同，问最快的过河时间。</p>
<p>有N个人要渡河，但是只有一艘船，船上每次最多只能载两个人，渡河的速度由两个人中较慢的那个决定，小船来回载人直到所有人都渡河，求最短的渡河时间。</p>
<p>输入的每种情况的第一行包含N，第二行包含N个整数，表示每个人过河的时间。每个案例前面都有一个空行。不会有超过1000人，没有人会花超过100秒的时间穿越。</p>
<p>对于每个测试用例，打印一行，其中包含所有N个人过河所需的总秒数。</p>
<p>Sample Input<br>
1<br>
4<br>
1 2 5 10<br>
Sample Output<br>
17</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/20200201205225396.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>可以发现，4个人以上时，前四轮都是将最慢的两个渡过河。</strong></p>
<pre><code class="language-java">public class Case02_POJ_1700 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int i = 0; i &lt; T; i++) {
            int n = sc.nextInt();
            int[] speed = new int[n];
            for (int j = 0; j &lt; n; j++) {
                speed[j] = sc.nextInt();
            }
            //排序
            Arrays.sort(speed);
            f(n, speed);
        }
    }

    /**
     * speed已经排序
     *
     * @param n
     * @param speed
     */
    private static void f(int n, int[] speed) {
        int left = n;
        int ans = 0;
        while (left &gt; 0) {
            if (left == 1) {//只有1人
                ans += speed[0];
                break;
            } else if (left == 2) {//只有两人
                ans += speed[1];
                break;
            } else if (left == 3) {//有三人
                ans += speed[2] + speed[0] + speed[1];
                break;
            } else {//通过两种策略来回两趟，渡过最慢的两个人
                //1，2出发，1返回，最后两名出发，2返回
                int s1 = speed[1] + speed[0] + speed[left - 1] + speed[1];
                //1，3出发，1返回，1，4出发，1返回，1，2过河
                int s2 = speed[left - 1] + speed[left - 2] + 2 * speed[0];
                ans += Math.min(s1, s2);
                left -= 2;//左侧是渡河的起点，left代表左侧的剩余人数
            }
        }
        System.out.println(ans);
    }
</code></pre>
<h3 id="3-区间调度问题二维数组排序">3. 区间调度问题（二维数组排序）</h3>
<blockquote>
<p>有n项工作,每项工作分别在si时间开始,在ti时间结束.<br>
对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.<br>
此外,参与工作的时间段不能重复(即使是开始的瞬间和结束的瞬间的重叠也是不允许的).<br>
你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?<br>
1≤n≤100000<br>
1≤si≤ti≤10^9<br>
输入:<br>
第一行:n<br>
第二行:n个整数空格隔开,代表n个工作的开始时间<br>
第三行:n个整数空格隔开,代表n个工作的结束时间<br>
样例输入:<br>
5<br>
1 3 1 6 8<br>
3 5 2 9 10<br>
样例输出:<br>
3<br>
说明:选取工作1,3,5</p>
</blockquote>
<p><strong>面向对象的排序思想</strong>：</p>
<ul>
<li>将不同的维度，比如说身高、体重、年龄，进行打包。</li>
<li>将对象的一些操作打包到一起，操作可以直接影响数据。</li>
</ul>
<pre><code class="language-java">//贪心策略：选择结束时间最早的
public class Case03_区间调度问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] s = new int[n];
        int[] t = new int[n];
        //建立开始时间和终止时间的打包对象
        Job[] jobs = new Job[n];
        for (int i = 0; i &lt; n; i++) {
            s[i] = sc.nextInt();
        }
        for (int i = 0; i &lt; n; i++) {
            t[i] = sc.nextInt();
        }
        for (int i = 0; i &lt; n; i++) {
            jobs[i] = new Job(s[i], t[i]);
        }

        Arrays.sort(jobs);
        //此时数据按照终止时间和开始时间由小到大排序
        int res = f(n, jobs);
        System.out.println(res);
    }

    private static int f(int n, Job[] jobs) {
        int cnt = 1;
        int y = jobs[0].t;//先选择最小的终止时间
        for (int i = 0; i &lt; n; i++) {//选择下一个终止时间最早的
            if (jobs[i].s &gt; y) {
                cnt++;
                y = jobs[i].t;
            }
        }
        return cnt;
    }

    /**
     * 必须实现排序规则
     */
    private static class Job implements Comparable&lt;Job&gt; {
        int s;
        int t;

        public Job(int s, int t) {
            this.s = s;
            this.t = t;
        }
		
        //排序规则
        @Override
        public int compareTo(Job other) {
            int x = this.t - other.t;
            if (x == 0)//如果终止的时间相同，则比较开始时间
                return this.s - other.s;
            else
                return x;
        }
    }
}
</code></pre>
<h3 id="4-区间选点">4. 区间选点</h3>
<blockquote>
<p>题意:有n个如下形式的条件:<br>
ai bi ci,表示在区间[ai, bi]内至少要选择ci个整数点.（不同区间内含的点可以是同一个）<br>
问你满足n个条件的情况下,最少需要选多少个点?<br>
Sample Input<br>
5<br>
3 7 3<br>
8 10 3<br>
6 8 1<br>
1 3 1<br>
10 11 1<br>
Sample Output<br>
6</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625174049315.png" alt="image-20200625174049315" style="zoom: 80%;" />
<pre><code class="language-java">public class Case04_区间选点问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Interval[] intervals = new Interval[n];
        for (int i = 0; i &lt; n; i++) {
            intervals[i] = new Interval(sc.nextInt(), sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(intervals);//按区间右端点排序

        int max = intervals[n - 1].t;//右端最大值
        int[] axis = new int[max + 1];//标记数轴上的点是否已经被选中
        for (int i = 0; i &lt; n; i++) {
            //1.查阅区间中有多少个点
            int s = intervals[i].s;//起点
            int t = intervals[i].t;//终点
            int cnt = sum(axis, s, t);//找到这个区间已经选点的数量，sums[t] - sums[s - 1];//效率低
            //  2.如果不够，从区间右端开始标记，遇标记过的就跳过
            intervals[i].c -= cnt;//需要新增的点的数量
            while (intervals[i].c &gt; 0) {
                if (axis[t] == 0) {//从区间终点开始选点
                    axis[t] = 1;
                    // updateSums(t,sums);//更新前缀和
                    intervals[i].c--;//进一步减少需要新增的点的数量
                    t--;
                } else {//这个点已经被选过了，不选择重复的点
                    t--;
                }
            }
        }
        System.out.println(sum(axis, 0, max));
    }

    /**
     * 统计数轴axis上s-t区间已经有多少个点被选中
     * @param axis
     * @param s
     * @param t
     * @return
     */
    private static int sum(int[] axis, int s, int t) {
        int sum = 0;
        for (int i = s; i &lt;= t; i++) {
            sum += axis[i];
        }
        return sum;
    }
    
    private static class Interval implements Comparable&lt;Interval&gt; {
        int s;//起点
        int t;//终点
        int c;//区间需求

        public Interval(int s, int t, int c) {
            this.s = s;
            this.t = t;
            this.c = c;
        }
		
        //按照终点由小到大排序
        @Override
        public int compareTo(Interval other) {
            int x = this.t - other.t;
            if (x == 0)
                return this.s - other.s;
            else
                return x;
        }
    }

}
</code></pre>
<h3 id="5-区间覆盖问题">5. 区间覆盖问题</h3>
<p><code>如果给定一堆线段，给定一个区间，看最少需要几个线段才能完全覆盖这个区间。</code></p>
<p><strong>解决思路</strong>：</p>
<ul>
<li>
<p>设区间起点为start，终点为end，所需线段数目为ans</p>
</li>
<li>
<p>首先线段中的终点，小于区间的起点，则该线段肯定无法覆盖</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625213133071.png" alt="image-20200625213133071" style="zoom:67%;" />
</li>
<li>
<p>同理如果区间的终点，大于线段的起点，则也一定无法覆盖</p>
</li>
<li>
<p>接着就需要<strong>保存线段终点大于等于区间起点且线段起点小于等于区间终点的线段</strong></p>
</li>
<li>
<p>对上面的线段<strong>根据起点的大小排序</strong></p>
</li>
<li>
<p>接着此时的寻找线段起点小于start同时终点最远的线段，并该终点设置为新的start，将ans+1<br>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200625213909588.png" alt="image-20200625213909588" style="zoom: 67%;" /></p>
</li>
<li>
<p>重复上述步骤直到找到终点大于end的</p>
</li>
</ul>
<blockquote>
<p>题目：给出n条线段，以及最大长度m，问最少需要多少条才能覆盖1-m这个区间，当无法全部覆盖的时候输出-1</p>
<p>Sample Input<br>
3 10<br>
1 7<br>
3 6<br>
6 10<br>
Sample Output<br>
2</p>
</blockquote>
<pre><code class="language-java">public class Case05_区间覆盖问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int T = sc.nextInt();
        Job[] jobs = new Job[N];
        for (int i = 0; i &lt; N; i++) {
            jobs[i] = new Job(sc.nextInt(), sc.nextInt());
        }
        Arrays.sort(jobs);
        int start = 1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右
        int end = 1;
        int ans = 1;
        for (int i = 0; i &lt; N; i++) {
            int s = jobs[i].s;
            int t = jobs[i].t;
            if (i == 0 &amp;&amp; s &gt; 1) break;//第一个起点比区间起点小，则一定无法覆盖

            if (s &lt;= start) {//当前区间有可能覆盖start
                end = Math.max(t, end);//寻找起点小于start同时终点最远的线段
            } else {//说明已经没有线段再比start小，开始下一个区间
                ans++;//上一个目标覆盖已经达成，计数加1
                start = end + 1;//更新起点，设置一个新的覆盖目标
                if (s &lt;= start) {
                    end = Math.max(t, end);
                } else {//当前的起点如果比end大，则后面的都一定大，无法继续覆盖
                    break;
                }
            }
            if (end &gt;= T) {//当前的end超越了线段的右侧，则不需要继续判断了
                break;
            }
        }
        if (end &lt; T)//如果没有覆盖
            System.out.println(-1);
        else
            System.out.println(ans);
    }

    private static class Job implements Comparable&lt;Job&gt; {
        int s;
        int t;

        public Job(int s, int t) {
            this.s = s;
            this.t = t;
        }

        /**按照区间起点排序*/
        @Override
        public int compareTo(Job other) {
            int x = this.s - other.s;
            if (x == 0)
                return this.t - other.t;
            else
                return x;
        }
    }
}
</code></pre>
<h3 id="6-字典序最小问题">6. 字典序最小问题</h3>
<blockquote>
<p>字典序最小问题<br>
给一个定长为N的字符串S,构造一个字符串T,长度也为N。<br>
起初，T是一个空串，随后反复进行下列任意操作</p>
<ol>
<li>从S的头部删除一个字符，加到T的尾部</li>
<li>从S的尾部删除一个字符，加到T的尾部<br>
目标是最后生成的字符串T的字典序尽可能小<br>
1≤N≤2000<br>
字符串S只包含大写英文字母<br>
输入：字符串S<br>
输出：字符串T</li>
</ol>
</blockquote>
<pre><code class="language-java">public class Case06_字典序最小问题 {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    StringBuilder ss = new StringBuilder();//字符输入小技巧
    for (int i = 0; i &lt; N; i++) {
      ss.append(sc.next());
    }
    // String s = sc.nextLine();
    f(ss.toString());
  }

  private static void f(String s) {
    String s1 = new StringBuilder(s).reverse().toString();//字符串翻转，
    int N = s.length();
    StringBuilder rs = new StringBuilder();
    while (rs.length() &lt; N) {//这样就可以直接比较两个字符串的头，相当于一个取头一个取尾
      if (s.compareTo(s1) &lt;= 0) {//这是个字符串字典比较的小技巧
        rs.append(s.charAt(0));
        s = s.substring(1);
      } else {
        rs.append(s1.charAt(0));
        s1 = s1.substring(1);
      }
  }
}

</code></pre>
<h3 id="7-乘船问题">7. 乘船问题</h3>
<blockquote>
<p>有n个人，第i个人重量为wi。每艘船的最大载重量均为C，且最多只能乘两个人。用最少的船装载所有人。<br>
贪心策略：考虑最轻的人i，如果每个人都无法和他一起坐船（重量和超过C），则唯一的方案是每个人坐一艘<br>
否则，他应该选择能和他一起坐船的人中最重的一个j<br>
求需要船的数量</p>
</blockquote>
<pre><code class="language-java">public class Case07_乘船问题 {
  public static void main(String[] args) {
    int[] w = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = w.length;
    int c = 10;

    Arrays.sort(w);
    int cntOfPerson = n;
    int cntOfBoat = 0;
    int p1 = 0;
    int p2 = n - 1;
    while (cntOfPerson &gt; 0) {
      if (p1 + p2 &gt; c) {//如果最大的和当前最小的不能在一艘船，则一定需要自己一艘船
        p2--;
        cntOfPerson--;
        cntOfBoat++;
      } else {
        p1++;
        p2--;
        cntOfPerson -= 2;
        cntOfBoat++;
      }
    }
    System.out.println(cntOfBoat);
  }
}
</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>本质是一种DFS的剪枝法</li>
<li>选择的是当下最优的策略</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第七章操作系统接口]]></title>
        <id>https://xzzz2020.github.io/post/KpZgrFFRY/</id>
        <link href="https://xzzz2020.github.io/post/KpZgrFFRY/">
        </link>
        <updated>2020-06-23T13:03:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">命令接口实现</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="命令接口实现">命令接口实现</h2>
<p><strong>分为下图所示的两个模块实现</strong>：</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205644062.png" alt="image-20200623205644062" style="zoom: 50%;" />
<p><strong>终端处理程序，接收键盘的输入，并将命令执行的结果回显在显示器上，功能包括</strong>：</p>
<ul>
<li>字符接收</li>
<li>字符缓冲</li>
<li>回送显示</li>
<li>屏幕编辑</li>
<li>特殊字符的处理</li>
</ul>
<p><strong>命令解释程序，从.输入缓冲区中取出数据，然后识别命令、执行命令,最后把结果放到输出缓冲区中。</strong></p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205922735.png" alt="image-20200623205922735" style="zoom: 80%;" />
<h2 id="系统调用">系统调用</h2>
<p><strong>什么是系统调用？</strong></p>
<ul>
<li>系统调用是操作系统提供给应用程序的一-种过程调用，保护操作系统程序不被用户，<br>
程序破坏。</li>
<li>系统调用是操作系统的程序接口。</li>
</ul>
<p><strong>系统调用与一般的过程调用不同</strong>：</p>
<ul>
<li>系统调用处理程序运行在内核态，而一般的过程调用运行在用户态;</li>
<li>系统调用需要借助软中断实现，而- -般过程调用不需要;</li>
<li>系统调用从内核返回时，要进行决策是否运行调度算法，而一般过程调用不需要;</li>
<li>系统调用可以嵌套调用，但调用深度有一定的限制，而一般过程调用没有深度限制;</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第六章文件管理]]></title>
        <id>https://xzzz2020.github.io/post/7ZUXXwU1m/</id>
        <link href="https://xzzz2020.github.io/post/7ZUXXwU1m/">
        </link>
        <updated>2020-06-23T12:52:11.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">文件及其逻辑结构</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6">顺序文件</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6">索引文件</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6">索引顺序文件</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6%E5%92%8C%E5%93%88%E5%B8%8C%E6%96%87%E4%BB%B6">直接文件和哈希文件</a></li>
</ul>
</li>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E8%A6%81%E6%B1%82">目录的要求</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">文件的物理结构（***）</a>
<ul>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">连续分配</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D">链接分配</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D">索引分配</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86">空闲空间管理</a>
<ul>
<li><a href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95">空闲表法</a></li>
<li><a href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95">空闲链表法</a></li>
<li><a href="#%E4%BD%8D%E8%A7%86%E5%9B%BE%E6%B3%95">位视图法（***）</a></li>
<li><a href="#%E6%88%90%E7%BB%84%E9%93%BE%E8%A1%A8%E6%B3%95">成组链表法</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B">文件系统软件模型</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7">对象及其属性</a></li>
<li><a href="#%E5%AF%B9%E5%AF%B9%E8%B1%A1%E6%93%8D%E7%BA%B5%E5%92%8C%E7%AE%A1%E7%90%86%E7%9A%84%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88">对对象操纵和管理的软件集合</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">文件系统接口</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB">文件共享</a></li>
<li><a href="#%E8%AF%BE%E6%9C%AC%E4%B9%A0%E9%A2%98">课本习题</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="文件及其逻辑结构">文件及其逻辑结构</h2>
<p><strong>文件概念</strong>：由创建者所定义、具有文件名的一组相关元素的集合，可分为结构文件和无结构文件两种。</p>
<p><strong>文件逻辑结构概念</strong>：文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性，又称为文件组织。</p>
<h3 id="顺序文件">顺序文件</h3>
<ul>
<li>顺序文件由数据依次排列组成。</li>
<li>顺序文件可分为串结构文件和有序结构文件。、
<ul>
<li>串结构文件按记录存入文件的时间先后排列。</li>
<li>有序结构按关键字值大小排列。</li>
</ul>
</li>
<li>顺序文件又分为定长记录文件和变长记录文件。</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623182042483.png" alt="image-20200623182042483" style="zoom:80%;" />
<h3 id="索引文件">索引文件</h3>
<p>若顺序文件是<strong>变长记录文件</strong>，可按记录号或关键字为每条记录建立一个索引文件，存储记录在顺序文件中的位置信息。</p>
<p>索引文件是定长的文件。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623182705177.png" alt="image-20200623182705177" style="zoom: 80%;" />
<h3 id="索引顺序文件">索引顺序文件</h3>
<ul>
<li><strong>索引文件太长会要求更多的I/O次数，直接影响了文件的读/写效率。</strong></li>
<li>索引顺序文件先<strong>对顺序文件按记录号或关键字排序分组</strong>，然后对组的第一个记录索引。</li>
</ul>
<h3 id="直接文件和哈希文件">直接文件和哈希文件</h3>
<ul>
<li>
<p><strong>直接文件</strong>是一种特殊的哈希文件,记录关键字值决定了记录在顺序文件中的位置。</p>
</li>
<li>
<p><strong>哈希文件</strong>则由关键字值通过哈希函数计算获得记录在顺序文件中的位置。</p>
</li>
</ul>
<h2 id="目录的要求">目录的要求</h2>
<ol>
<li>实现“按名存取”。</li>
<li>提高对目录的检索速度。</li>
<li>文件共享。</li>
<li>允许文件重名。</li>
</ol>
<h2 id="文件的物理结构">文件的物理结构（***）</h2>
<p><strong>概念</strong>：文件的物理结构指文件的外存分配组织管理方式</p>
<blockquote>
<p>文件占用的外存空间以块或簇等逻辑单位计量</p>
</blockquote>
<h3 id="连续分配">连续分配</h3>
<blockquote>
<p>文件数据连续存储可以提高存取速度，但限制了文件动态增长。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623195227779.png" alt="image-20200623195227779" style="zoom: 80%;" />
<h3 id="链接分配">链接分配</h3>
<blockquote>
<p>隐式链接，链接指针包含在给文件分配的块中，目录中仅包含文件的起始块和结束块(或长度)。</p>
<ul>
<li>链接指针分散在多个块中，不利于安全措施的实现</li>
</ul>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623200229916.png" alt="image-20200623200229916" style="zoom:67%;" />
<blockquote>
<p>显示链接：将所有的链接信息提取放到文件分配表中</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623200341171.png" alt="image-20200623200341171" style="zoom: 67%;" />
<h3 id="索引分配">索引分配</h3>
<ul>
<li>
<p>在链接分配中，文件块链接指针离散存储,造成文件占用块号解析效率不高。</p>
</li>
<li>
<p>索引分配方式就是将块号集中存放。</p>
</li>
</ul>
<p><strong>单级索引（一级索引）</strong></p>
<p>用一个块来记录文件占用的所有块号,我们称之为索引块</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201033041.png" alt="image-20200623201033041" style="zoom:67%;" />
<p><strong>二级索引</strong></p>
<blockquote>
<p>因为一个索引块的大小有限，但是多级索引需要检索多次，会影响性能</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201015773.png" alt="image-20200623201015773" style="zoom:67%;" />
<p><strong>混合索引(直接地址、-级索引、两级索引、三级索引方式)</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201148989.png" alt="image-20200623201148989" style="zoom:80%;" />
<h2 id="空闲空间管理">空闲空间管理</h2>
<h3 id="空闲表法">空闲表法</h3>
<ul>
<li>若干连续的空闲块组合成一个空闲区。</li>
<li>空闲表法将所有的空闲区记录在一张表里， 包括项号、起始空闲块号、空闲块数等。</li>
</ul>
<h3 id="空闲链表法">空闲链表法</h3>
<p>空闲链表法是以空闲块或空闲区为结点构成一个链表结构。</p>
<h3 id="位视图法">位视图法（***）</h3>
<blockquote>
<p>用一位二进制表示，1代表已分配，0代表空闲。</p>
</blockquote>
<ul>
<li>块号从0开始，BitsOfLine 是一行有多少位，如char类型为8位</li>
<li>block = line X BitsOfLine + column</li>
<li>line = block/BitsOfLine</li>
<li>column = block%BitsOfLine</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201428546.png" alt="image-20200623201428546" style="zoom: 80%;" />
<h3 id="成组链表法">成组链表法</h3>
<blockquote>
<p>用树的结构表示</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623201544463.png" alt="image-20200623201544463" loading="lazy"></figure>
<h2 id="文件系统软件模型">文件系统软件模型</h2>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623202429515.png" alt="image-20200623202429515" style="zoom:67%;" />
<h3 id="对象及其属性">对象及其属性</h3>
<ul>
<li>文件系统对象</li>
<li>超级块对象</li>
<li>文件</li>
<li>目录</li>
<li>索引结点</li>
<li>数据块</li>
</ul>
<h3 id="对对象操纵和管理的软件集合">对对象操纵和管理的软件集合</h3>
<ul>
<li>对文件的读/写</li>
<li>对目录文件的读/写</li>
<li>对磁盘空闲空间的管理</li>
<li>将文件的逻辑地址转换为物理地址</li>
<li>对文件的保护与共享;</li>
</ul>
<h3 id="文件系统接口">文件系统接口</h3>
<ul>
<li>基于文件名(路径)、文件逻辑地址(相对于文件起始地址的偏移)给用户提供各种操作。</li>
<li>常用的文件操作有，创建文件、删除文件、读文件、写文件、设置文件读1写位置、打开文件、关闭文件等。</li>
</ul>
<h2 id="文件共享">文件共享</h2>
<ul>
<li>基于索引结点的共享方式</li>
<li>基于符号链的共享方式</li>
</ul>
<h2 id="课本习题">课本习题</h2>
<ol>
<li>
<p><strong>11 在 UNIX 中，如果一个盘块的大小为   1KB ，每个盘块号占                4 个字节，即每块可放                256个地址。请转换下列文件的字节偏移量为物理地址。</strong></p>
<p><strong>⑴ 9999 ； ⑵ 18000 ；⑶ 420000</strong></p>
<p>答：首先将逻辑文件的字节偏移量转换为逻辑块号和块内偏移量   ,就是将 [字节偏移量 ]/[ 盘块大小 ]，商为逻辑块号，<code>余数是块内偏移量</code>。在  FCB 中，第 0-9 个地址为直接地址，第  10 个为一次间接地址，第 11 个地址为二次间接地址，第 12 个地址为三次间接地址。</p>
<p>再将文件的逻辑块号转换为物理块号。使用多重索引结构，在索引节点中根据逻辑块号通过直接索引或间接索引找到对应的物理块号。</p>
<ul>
<li>
<p>9999/1024=9余 783 ，则逻辑块号为9 ，直接索引第9个地址得到物理块号，块内偏移地址为 783 。</p>
</li>
<li>
<p>18000/1024=17  余 592 ，则逻辑块号为10&lt;17&lt;10+256，通过一次间接索引在第10个地址可得到物理块号，块内偏移地址为592 。</p>
</li>
<li>
<p>420000/1024=410 余160 ，则逻辑块号为 10+256&lt;410 ，通过二次间接索引在第 11 个地址可得到一次间址，再由此得到二次间址，再找到物理块号，其块内偏移地址160 。</p>
</li>
</ul>
</li>
<li>
<p><strong>某操作系统磁盘文件空间共   500 块，若用字长为 32 位的位示图管理磁盘空间，试问：</strong></p>
<p><strong>（1）位示图需要多少字？</strong></p>
<p><strong>（2）第 i 字第 j 位对应的块号是多少？</strong></p>
<p><strong>（3）给出申请 /归还一块的工作流程。</strong></p>
<p>答：</p>
<p>（1）位示图需要的字数计算：  INT （ 500/32 ） =16个字。</p>
<p>（2）块号 b=(i-1)*32+j</p>
<p>（3 ）申请的过程：顺序扫描位示图、找到空闲块并分配、修改位示图map[i,j]=1 。归还的过程：找到回收盘块在位示图中的行和列，修改位示图map[i,j]=0 。</p>
</li>
</ol>
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194032746.png" alt="image-20200623194032746" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194102600.png" alt="image-20200623194102600" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623194242927.png" alt="image-20200623194242927" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205009523.png" alt="image-20200623205009523" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200623205103341.png" alt="image-20200623205103341" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第五章设备管理]]></title>
        <id>https://xzzz2020.github.io/post/mxhiqNcFj/</id>
        <link href="https://xzzz2020.github.io/post/mxhiqNcFj/">
        </link>
        <updated>2020-06-23T09:01:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB">设备分类</a></li>
<li><a href="#io%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">I/O设备控制方式</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">程序查询方式</a></li>
<li><a href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">通道控制方式</a></li>
<li><a href="#dma%E6%96%B9%E5%BC%8F%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">DMA方式（直接存储器访问方式）</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F">中断方式</a></li>
</ul>
</li>
<li><a href="#io%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%8A%9F%E8%83%BD">I/O系统的软件模型及功能</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6">设备独立性软件</a></li>
<li><a href="#spooling">Spooling</a></li>
<li><a href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86">缓冲管理</a>
<ul>
<li><a href="#%E5%9B%9B%E7%A7%8D%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5">四种缓冲策略</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D">设备分配</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BC%9A%E8%AE%A1%E7%AE%97">磁盘调度算法（会计算***）</a>
<ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1">先来先服务</a></li>
<li><a href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4">最短寻道时间</a></li>
<li><a href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">扫描算法（电梯调度算法）</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95">循环扫描算法</a></li>
</ul>
</li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="设备分类">设备分类</h2>
<p><strong>按信息交换单位分类</strong>：</p>
<ul>
<li><strong>块设备</strong>：数据传送以块为单位，传输速率较高，可寻址; I/O访问常采用DMA方式。</li>
<li><strong>字符设备</strong>：数据传送以字符为单位，传输速率较低，不可寻址; I/0访问常采用中断方式。</li>
</ul>
<p><strong>按设备的的共享属性分类</strong>：</p>
<ul>
<li><strong>独占设备</strong>：一段时间内只允许一个进程使用，属于临界资源。</li>
<li><strong>共享设备</strong>：在一-段时间，允许多个进程同时访问，共享设备必须是<code>可寻址</code>和<code>可随机访问</code>的设备。</li>
<li><strong>虚拟设备</strong>：将一台独占设备变换为若干个逻辑设备,如虚拟存储器、虚拟终端。</li>
</ul>
<h2 id="io设备控制方式">I/O设备控制方式</h2>
<h3 id="程序查询方式">程序查询方式</h3>
<blockquote>
<p>不停的检查设备的状态，造成CPU资源的浪费，优点是比较简单</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623154822643.png" alt="image-20200623154822643" style="zoom: 80%;" />
<h3 id="通道控制方式">通道控制方式</h3>
<p><strong>通道程序由一系列通道指令构成，包含以下信息</strong>：</p>
<ul>
<li><strong>操作码</strong>：读、写、控制等;</li>
<li><strong>内存地址</strong>：读写内存的始址;</li>
<li><strong>计数</strong>：指令的读写字节数;</li>
</ul>
<p><strong>通道程序示例</strong>：</p>
<ul>
<li>
<p>通道程序结束位P，1表示通道指令是通道程序的最后一条指令。</p>
</li>
<li>
<p>记录结束位Record, 0表示通道指令与下一条通道指令所处理的数据块属于同- -个记录，1表示通道指令所处理的数据块是记录的最后一块数据。</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160021122.png" alt="image-20200623160021122" style="zoom:80%;" />
<h3 id="dma方式直接存储器访问方式">DMA方式（直接存储器访问方式）</h3>
<blockquote>
<p>DMA方式以<strong>块</strong>为单位传送数据，仅在数据块传送前和传送结束时,才需要处理机干预。</p>
</blockquote>
<p><strong>包含四类寄存器</strong>：</p>
<ul>
<li><strong>数据寄存器</strong>：缓存从设备到内存，或从内存到设备的数据;</li>
<li><strong>数据计数寄存器</strong>：存储要读/写的字节数;</li>
<li><strong>内存地址寄存器</strong>：存放内存起始地址; .</li>
<li><strong>控制/状态寄存器</strong>：接收处理机发来的1/O命令或有关控制信息，以及设备发送的状态信息;</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623155319789.png" alt="image-20200623155319789" style="zoom:80%;" />
<h3 id="中断方式">中断方式</h3>
<blockquote>
<p>驱动程序向处理机发出启动I/O设备指令后阻塞，处理机转向处理其它工作。</p>
<p>设备完成数据传送后，I/O控制器向处理机发送中断请求。处理机收到中断请求信号转向中断处理程序，中断处理程序将数据寄存器中的数据送到指定内存单元，并唤醒阻塞进程。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623155132894.png" alt="image-20200623155132894" style="zoom:80%;" />
<h2 id="io系统的软件模型及功能">I/O系统的软件模型及功能</h2>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160245567.png" alt="image-20200623160245567" style="zoom:67%;" />
<h2 id="设备独立性软件">设备独立性软件</h2>
<ul>
<li>
<p>设备独立性指应用程序独立于具体使用的物理设备。</p>
</li>
<li>
<p>为了实现设备独立性而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>概念，在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。</p>
</li>
</ul>
<p><strong>设备独立性软件的功能</strong>：</p>
<ol>
<li>
<p>向用户层(或文件层)软件提供统一接口。</p>
</li>
<li>
<p>执行设备的公有操作，如<code>逻辑设备名映射为物理设备名</code>、独立设备的分配与回收、对设备进行保护、缓冲管理、差错控制、提供独立于物理设备的逻辑块。</p>
</li>
</ol>
<p><strong>设备独立性实现</strong>：构建一个逻辑设备表，实现逻辑设备名到物理设备名的映射</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623161100037.png" alt="image-20200623161100037" style="zoom:67%;" />
<h2 id="spooling">Spooling</h2>
<blockquote>
<p>在联机情况下<strong>实现的同时输入/输出操作</strong>称为Spooling，或称为假脱机操作,即数据的输入、输出不再由外围控制机管理,而<strong>改为进程执行</strong>。</p>
</blockquote>
<p><strong>Spooling系统的组成</strong>：</p>
<ul>
<li>输入进程SPi和输出进程SPo</li>
<li>输入和输出缓冲区</li>
<li>输入和输出井</li>
</ul>
<p><strong>Spooling系统应用--共享打印机</strong>：</p>
<ul>
<li>将所有打印请求挂在打印机请求队列上。</li>
<li>把打印数据放入到输出井上。</li>
<li>打印机驱动进程依次完成打印机请求队列上的任务。</li>
</ul>
<p><strong>Spooling系统的特点</strong>：</p>
<ul>
<li>
<p>提高了I/O速度。</p>
</li>
<li>
<p>将独占设备改造成共享设备。</p>
</li>
<li>
<p>实现了设备的虚拟化。</p>
</li>
</ul>
<h2 id="缓冲管理">缓冲管理</h2>
<p><strong>目的</strong>：减少低速设备对高速的干扰。</p>
<h3 id="四种缓冲策略">四种缓冲策略</h3>
<p><strong>1. 单缓冲</strong></p>
<ul>
<li>
<p>由于处理机与I/O设备的并行性，用户进程对一块缓冲区数据的<strong>处理时间等价于Max(C，T)+M</strong>。</p>
</li>
<li>
<p>需要注意的是<strong>传送和计算或输入无法同时计算</strong></p>
</li>
<li>
<p>此时<strong>生产者是设备</strong>，<strong>消费者是用户进程</strong>，生产者和消费者都只有一个，不存在互斥</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623162724656.png" alt="image-20200623162724656" style="zoom:67%;" />
<p><strong>2. 双缓冲</strong></p>
<ul>
<li>数据被采集到缓冲区和数据从缓冲区传送到用户进程空间再被计算可以并行执行;</li>
<li>用户进程对一块缓冲区数据的处理时间等价于Max (C、T) ;如果C&gt;T,则CPU可以连续地工作;如果C&lt;T,则I/0设备可以连续地工作;</li>
<li>双缓冲适用于<strong>I/O设备与用户进程速度基本匹配的场合</strong>;</li>
<li>此时<strong>设备输入数据和用户进程取数据可以同时进行</strong></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623163234512.png" alt="image-20200623163234512" loading="lazy"></figure>
<p><strong>3. 循环缓冲</strong></p>
<ul>
<li>适用于<strong>I/O设备与用户进程速度差异较大的场合</strong></li>
<li>循环缓冲的使用：
<ul>
<li>GetBuf过程，从循环缓冲中获取一个满缓冲区或一个空缓冲区;</li>
<li>ReleaseBuf过程，向循环缓冲中释放一个空缓冲区或一个满缓冲区;</li>
</ul>
</li>
</ul>
<p><strong>4. 缓冲池（***）</strong></p>
<p><strong>三种缓冲队列</strong></p>
<ul>
<li>
<p>空缓冲队列emq</p>
</li>
<li>
<p>输入缓冲队列inq,装满输入数据</p>
</li>
<li>
<p>输出缓冲队列outq,装满输出数据</p>
</li>
</ul>
<p><strong>四种缓冲区</strong></p>
<ul>
<li>
<p>收容输入数据缓冲区hin</p>
</li>
<li>
<p>提取输入数据缓冲区sin</p>
</li>
<li>
<p>收容输出数据缓冲区hout</p>
</li>
<li>
<p>提取输出数据缓冲区sout</p>
</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623163922409.png" alt="image-20200623163922409" style="zoom:67%;" />
<h2 id="设备分配">设备分配</h2>
<ul>
<li><strong>安全分配</strong>：进程发出I/0请求后，便进入阻塞状态,直到I/O操作完成时才被唤醒。摒弃&quot;请求和保持”死锁必要条件之一， 缺点是进程进展缓慢。</li>
<li><strong>不安全分配</strong>：进程发出I/O请求后仍继续运行，需要时又发出第二C 个、第三个I/O请求等，效率高，缺点是可能造成死锁。</li>
</ul>
<h2 id="磁盘调度算法会计算">磁盘调度算法（会计算***）</h2>
<p><strong>注意</strong>：每次寻道都会改变当前所在磁道</p>
<h3 id="先来先服务">先来先服务</h3>
<blockquote>
<p>按照请求顺序进行寻道</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623164405289.png" alt="image-20200623164405289" style="zoom:67%;" />
<h3 id="最短寻道时间">最短寻道时间</h3>
<blockquote>
<p>每次寻找离当前磁道最近的请求，会导致饥饿现象，默写请求可能很久都难以调度</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623164703834.png" alt="image-20200623164703834" style="zoom:67%;" />
<h3 id="扫描算法电梯调度算法">扫描算法（电梯调度算法）</h3>
<blockquote>
<p>磁头可以朝着增加的方向移动也会朝着减少的方向移动，可以避免饥饿现象的发生</p>
</blockquote>
<ul>
<li>先寻找离当前磁头最近的磁道且需要比当前磁道大</li>
<li>当不存在比当前磁道更大的时候，磁头需要调转方向，朝着减少的方向移动.</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165335882.png" alt="image-20200623165335882" style="zoom:67%;" />
<h3 id="循环扫描算法">循环扫描算法</h3>
<p><strong>改进</strong>：当移动到不存在比当前磁道更大的时候，不再调转方向，从0开始继续寻找</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165646915.png" alt="image-20200623165646915" style="zoom:67%;" />
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160324835.png" alt="image-20200623160324835" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623160342737.png" alt="image-20200623160342737" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623161956615.png" alt="image-20200623161956615" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623162055577.png" alt="image-20200623162055577" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165845231.png" alt="image-20200623165845231" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165920362.png" alt="image-20200623165920362" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623165946217.png" alt="image-20200623165946217" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四章存储器管理]]></title>
        <id>https://xzzz2020.github.io/post/HB2L7VswF/</id>
        <link href="https://xzzz2020.github.io/post/HB2L7VswF/">
        </link>
        <updated>2020-06-23T02:20:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5">程序的链接与装入</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5">程序的装入</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5">程序的链接</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">连续存储分配方式</a>
<ul>
<li><a href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">单一连续分配</a></li>
<li><a href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">固定分区分配方式</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">动态分区分配（***）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">基本分页存储管理方式</a>
<ul>
<li><a href="#%E9%A1%B5%E8%A1%A8">页表</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84">地址变换机构（***）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">基本分段存储管理方式</a>
<ul>
<li><a href="#%E6%AE%B5%E8%A1%A8">段表</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-2">地址变换机构（***）</a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">分页和分段的主要区别</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">虚拟存储器（***）</a>
<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81">虚拟存储器实现方法的硬件支持</a>
<ul>
<li><a href="#%E5%88%86%E9%A1%B5%E8%AF%B7%E6%B1%82%E7%B3%BB%E7%BB%9F">分页请求系统</a></li>
<li><a href="#%E5%88%86%E6%AE%B5%E8%AF%B7%E6%B1%82%E7%B3%BB%E7%BB%9F">分段请求系统</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法（***）</a>
<ul>
<li><a href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%90%86%E6%83%B3%E5%8C%96">最佳置换算法（理想化）</a></li>
<li><a href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">先进先出页面置换算法</a></li>
<li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lru">最近最久未使用置换算法（LRU）</a></li>
<li><a href="#clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">clock置换算法</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%80%E8%BF%91%E6%9C%AA%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">简单clock置换算法（最近未访问页面置换算法）</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E5%9E%8Bclock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">改进型clock置换算法</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E6%9C%AA%E4%BD%BF%E7%94%A8lfu">最近最少未使用（LFU）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="程序的链接与装入">程序的链接与装入</h2>
<h3 id="程序的装入">程序的装入</h3>
<p><strong>目的</strong>：是将代码装入内存准备执行</p>
<ol>
<li><strong>绝对装入方式</strong></li>
<li><strong>可重定位装入方式</strong>：</li>
<li><strong>动态运行时的装入方式</strong>：增加一个重定位寄存器，通过硬件完成地址的修正。真实地址等于<strong>逻辑地址+重定位寄存器上的地址</strong><br>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622175520753.png" alt="image-20200622175520753" style="zoom:67%;" /></li>
</ol>
<h3 id="程序的链接">程序的链接</h3>
<p><strong>目的</strong>：将目标模块相对独立的地址空间合并成一个地址空间。</p>
<p>​</p>
<ol>
<li><strong>静态链接方式</strong>
<ul>
<li>对相对地址进行修改</li>
<li>变换外部调用符号</li>
</ul>
</li>
<li><strong>装入时动态链接</strong></li>
<li><strong>运行时动态链接</strong></li>
</ol>
<h2 id="连续存储分配方式">连续存储分配方式</h2>
<p><strong>目的</strong>：给每一个程序分配一片连续的存储空间，容量为程序运行时所需的最大空间。</p>
<p><strong>指标</strong>：碎片率，越小越好。</p>
<h3 id="单一连续分配">单一连续分配</h3>
<p><strong>内存分为系统区和用户区</strong></p>
<ul>
<li>用户区一次只能装入一个程序运行</li>
<li>系统区装入操作系统</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622181950847.png" alt="image-20200622181950847" style="zoom:50%;" />
<h3 id="固定分区分配方式">固定分区分配方式</h3>
<p><strong>将内存划分成固定数目的区域，如图所示</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182210610.png" alt="image-20200622182210610" style="zoom: 67%;" />
<p>为了实现内存的管理，<strong>需要建立固定分区表（数组实现）</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182308481.png" alt="image-20200622182308481" style="zoom:67%;" />
<p><strong>程序的大小和分区大小不能完全匹配</strong>，所以需要分配大于等于程序大小的内存，分区中浪费的空间称为<strong>内碎片</strong></p>
<h3 id="动态分区分配">动态分区分配（***）</h3>
<p><strong>操作系统不预设固定数目分区，按照程序内存需求为其划分，内存中分区数目动态变化。</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182722198.png" alt="image-20200622182722198" style="zoom:50%;" />
<p><strong>数据结构</strong>：</p>
<ul>
<li>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182822266.png" alt="image-20200622182822266" style="zoom:50%;" />
</li>
<li>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622182958683.png" alt="image-20200622182958683" style="zoom: 67%;" />
</li>
</ul>
<p><strong>分配算法：</strong></p>
<ul>
<li><strong>首次适应算法</strong>：空闲分区以地址递增的顺序排列，<code>每次从链首开始顺序查找</code>，直到找到一个大小能满足要求的空闲分区为止。然后再按照程序的要求大小，从该空闲分区中划分出一块内存空间给请求者，余下的空闲部分仍留在空闲链表中。<code>特点是低端或高端地址空间被频繁使用。</code></li>
<li><strong>循环首次适应算法</strong>：在首次适应算法的基础上，<code>每次查找时从上次找到空闲分区的下一个空闲分区开始查找。特点是空闲分区使用均匀，但是会缺乏大的空闲分区。</code></li>
<li><strong>最佳适应算法</strong>：能满足要求、又是最小的空闲分区分配给作业，避免&quot;大材小用”。特点:分区按照大小顺序排列。</li>
<li><strong>最差适应算法</strong>：每次从空闲分区中选择最大的空闲分区分配给程序，以便切割剩余的空闲分区空间更大。</li>
</ul>
<p>切割操作会产生一些空间过小，总是不会分配给程序，这些空间被称作<strong>外碎片</strong>。</p>
<pre><code>### 可重定位分区分配
</code></pre>
<p><strong>紧凑</strong>：通过移动程序，将外碎片合并一个大的空闲分区</p>
<h2 id="基本分页存储管理方式">基本分页存储管理方式</h2>
<p><strong>离散分配的基本单位是页</strong></p>
<h3 id="页表">页表</h3>
<p><strong>解决了逻辑地址到物理地址的转换的问题：</strong></p>
<ul>
<li>将程序逻辑地址空间划分成固定大小的页面;</li>
<li>内存划分成等大小的页框;</li>
<li><code>页表实现页面到页框的索引;</code></li>
<li>页表项个数由程序的逻辑地址空间决定，页表项位数由页框起始物理地址位数决定。</li>
</ul>
<p><strong>记录了页面和页框号（每个页框的起始地址）的对应关系，如下图所示</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622191317403.png" alt="image-20200622191317403" style="zoom:67%;" />
<p>页表<strong>存储了页框的起始物理地址</strong>，需要一个连续的存储空间实现随机访问，对于<strong>逻辑地址相当于页号+页内偏移</strong>。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622200719784.png" alt="image-20200622200719784" style="zoom:80%;" />
<h3 id="地址变换机构">地址变换机构（***）</h3>
<ul>
<li>先让页号与页表基址相加得到<strong>页框号</strong></li>
<li>再让页框号与页内偏移相加得到<strong>物理地址</strong></li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622200925736.png" alt="image-20200622200925736" style="zoom:80%;" />
<h2 id="基本分段存储管理方式">基本分段存储管理方式</h2>
<ul>
<li><strong>离散分配的基本单位是端</strong></li>
<li><strong>采用二维逻辑地址结构，由段号加段内偏移构成</strong></li>
</ul>
<h3 id="段表">段表</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622201627033.png" alt="image-20200622201627033" style="zoom: 67%;" />
<h3 id="地址变换机构-2">地址变换机构（***）</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622201656943.png" alt="image-20200622201656943" style="zoom:80%;" />
<h3 id="分页和分段的主要区别">分页和分段的主要区别</h3>
<ul>
<li>页是信息的物理单位；段是信息的逻辑单位。</li>
<li>页大小固定；段大小不固定。</li>
<li>分页采用一维线性逻辑地址，分段采用二维逻辑地址。</li>
</ul>
<h2 id="虚拟存储器">虚拟存储器（***）</h2>
<p><strong>概念</strong>：虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器，其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度,每位成本接近外存。</p>
<h3 id="虚拟存储器实现方法的硬件支持">虚拟存储器实现方法的硬件支持</h3>
<h4 id="分页请求系统">分页请求系统</h4>
<ol>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ol>
<h4 id="分段请求系统">分段请求系统</h4>
<ol>
<li>请求分段的端表机制</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ol>
<h3 id="页面置换算法">页面置换算法（***）</h3>
<p><strong>页面中断</strong>：发生页面的置换</p>
<h4 id="最佳置换算法理想化">最佳置换算法（理想化）</h4>
<blockquote>
<p>置换以后永不使用或者最长时间不使用的页面</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622203218539.png" alt="image-20200622203218539" style="zoom: 80%;" />
<ul>
<li>发生3次缺页中断和页面中断</li>
</ul>
<h4 id="先进先出页面置换算法">先进先出页面置换算法</h4>
<blockquote>
<p>淘汰最先进入的页面，即选择在内存中驻留时间最久的页面予以淘汰。</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622203901808.png" alt="image-20200622203901808" style="zoom:80%;" />
<h4 id="最近最久未使用置换算法lru">最近最久未使用置换算法（LRU）</h4>
<blockquote>
<p>选择最近最久未使用的页面予以淘汰，即当前使用次数最少的页面。</p>
</blockquote>
<p><strong>实现方式</strong>：</p>
<ul>
<li>利用栈保存当前使用的各个页面的页面号,每当进程访问某页面时，便将该页面的页面号从栈中弹出，并将它压入栈顶。<code>因此，栈底是最近最久未使用的页面。</code></li>
<li>使用寄存器，每一次访问都会在寄存器加一，每次置换选择寄存器中次数最少的页面</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622204543566.png" alt="image-20200622204543566" style="zoom:80%;" />
<h4 id="clock置换算法">clock置换算法</h4>
<h5 id="简单clock置换算法最近未访问页面置换算法">简单clock置换算法（最近未访问页面置换算法）</h5>
<ul>
<li>将所有的页面组成一个循环链表,并为每个页面添加一个访问位A。</li>
<li>当一个页面被访问时，将其A位设置为1。</li>
<li>置换过程是从pointer开始，<strong>若该页面的A位为1,将其设置为0,并使pointer指向下一个页面</strong>，直到找到A位为0的页面;<strong>若该页面的A位为0，则将其置换出内存</strong>，并用换入的页面占用换出页面的页框，使pointer指向下一个页面。</li>
<li>如果第一轮没有找到，则执行第二轮，由于第一轮将所有页面的A都设置为0，则一定能在第二轮找到</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101130548.png" alt="image-20200623101130548" style="zoom: 67%;" />
<h5 id="改进型clock置换算法">改进型clock置换算法</h5>
<p><strong>增加一个修改为M，页面状态可以分为四类</strong>：</p>
<ul>
<li>1类(A=0，M=0) ，未访问未修改;</li>
<li>2类(A=0，M= 1)，未访问.已修改;</li>
<li>3类(A=1，M=0)，已访问未修改;</li>
<li>4类(A=1, M= 1) ，已访问已修改;</li>
</ul>
<p><strong>置换过程</strong>：</p>
<ol>
<li>从pointer开始寻找<strong>1类</strong>页面，直到找到1类页面结束，或者扫描完一遍进入第II步。</li>
<li>从pointer开始寻找<strong>2类</strong>页面， 直到找到2类页面结束，或者扫描完一遍进入第I步。在本步每扫描完一个页面，<strong>须将页面的访问位修改为0</strong>。</li>
<li>重复l和II。(一 定可以找到置换的页。)</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101334666.png" alt="image-20200623101334666" style="zoom:80%;" />
<h4 id="最近最少未使用lfu">最近最少未使用（LFU）</h4>
<blockquote>
<p>在最近时期内选择使用次数最少的页面作为淘汰页</p>
</blockquote>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622181520299.png" alt="image-20200622181520299" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190511957.png" alt="image-20200622190511957" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190706448.png" alt="image-20200622190706448" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622190752961.png" alt="image-20200622190752961" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622202031148.png" alt="image-20200622202031148" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623101755205.png" alt="image-20200623101755205" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第三章进程同步与死锁]]></title>
        <id>https://xzzz2020.github.io/post/vUwZiOAP9/</id>
        <link href="https://xzzz2020.github.io/post/vUwZiOAP9/">
        </link>
        <updated>2020-06-22T09:25:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>
<ul>
<li><a href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">整型信号量</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E6%80%A7%E4%BF%A1%E5%8F%B7%E9%87%8F">记录性信号量（***）</a></li>
<li><a href="#and%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">AND型信号量</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8">信号量的应用（***）</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5">利用信号量实现互斥</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">利用信号量实现前驱关系</a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D">资源的分配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98">同步的问题</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">死锁的相关概念</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">处理死锁的基本方法</a>
<ul>
<li><a href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81">预防死锁</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81">避免死锁（***）</a>
<ul>
<li><a href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法（***）</a></li>
</ul>
</li>
<li><a href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81">检测死锁</a></li>
<li><a href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81">解除死锁</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="进程同步">进程同步</h2>
<p><strong>临界资源</strong>：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源</p>
<p><strong>临界区</strong>：每个进程中访问临界资源的代码</p>
<p><strong>实现互斥的结构</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622150153590.png" alt="image-20200622150153590" style="zoom: 67%;" />
<p><strong>硬件实现</strong>：</p>
<ul>
<li><strong>关中断</strong>：让处理机始终执行一个程序，不进行程序的切换</li>
<li><strong>指令</strong></li>
</ul>
<p><strong>同步应该遵循的规则</strong>：</p>
<ul>
<li><strong>空闲让进</strong>：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</li>
<li><strong>忙则等待</strong>：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</li>
<li><strong>有限等待</strong>：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</li>
<li><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;</li>
</ul>
<p><strong>前驱图：</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622150703762.png" alt="image-20200622150703762" style="zoom:67%;" />
<blockquote>
<p><strong>若想执行S2，则需要先执行S1。</strong></p>
</blockquote>
<h2 id="信号量">信号量</h2>
<h3 id="整型信号量">整型信号量</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622151744719.png" alt="image-20200622151744719" style="zoom:67%;" />
<h3 id="记录性信号量">记录性信号量（***）</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622151852525.png" alt="image-20200622151852525" style="zoom:67%;" />
<h3 id="and型信号量">AND型信号量</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622154354678.png" alt="image-20200622154354678" style="zoom:80%;" />
<h3 id="信号量的应用">信号量的应用（***）</h3>
<h4 id="利用信号量实现互斥">利用信号量实现互斥</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153000297.png" alt="image-20200622153000297" style="zoom:50%;" />
<p><strong>实现算法</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153444468.png" alt="image-20200622153444468" style="zoom:50%;" />
<p><strong>符合</strong>：空闲让进，忙则等待和有限等待</p>
<h4 id="利用信号量实现前驱关系">利用信号量实现前驱关系</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153525416.png" alt="image-20200622153525416" style="zoom: 67%;" />
<h4 id="资源的分配">资源的分配</h4>
<p>申请资源时需要执行P操作，释放资源时执行V操作</p>
<h2 id="同步的问题">同步的问题</h2>
<ul>
<li>生产者-消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者-写者问题</li>
</ul>
<h2 id="进程间通信">进程间通信</h2>
<p><strong>低级通信</strong>：信号量机制</p>
<p><strong>高级通讯</strong>：共享存储器系统、消息传递系统、管道通信。</p>
<h2 id="死锁的相关概念">死锁的相关概念</h2>
<p><strong>可抢占资源</strong>：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。</p>
<p><strong>不可抢占的资源</strong>：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</p>
<p><strong>死锁的定义</strong>：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。</p>
<p><strong>产生死锁的原因</strong>：</p>
<ul>
<li>竞争不可抢占资源引发死锁。</li>
<li>竞争可消耗资源引发死锁。</li>
<li>进程推进顺序不当引发死锁。</li>
</ul>
<h2 id="处理死锁的基本方法">处理死锁的基本方法</h2>
<h3 id="预防死锁">预防死锁</h3>
<ul>
<li>破坏“请求和保持条件”</li>
<li>破坏“不可抢占条件”</li>
<li><strong>破坏“循环等待条件”</strong>：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，<mark><strong>必须按照从1到4或者从4到1的顺序申请</strong></mark>。</li>
</ul>
<h3 id="避免死锁">避免死锁（***）</h3>
<p><strong>安全状态</strong>：安全状态，是指系统能按某种顺序(P1, P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,<mark><strong>直到满足每个进程对资源的最大需求</strong></mark>，使每个进程都可以顺利地完成。</p>
<p><strong>不安全状态</strong>：如果系统无法找到这样一个安全序列， 称系统处于不安全状态。</p>
<blockquote>
<p>要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622165340017.png" alt="image-20200622165340017" style="zoom:67%;" />
<ul>
<li>根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态</li>
</ul>
<h4 id="银行家算法">银行家算法（***）</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170224200.png" alt="image-20200622170224200" style="zoom:80%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170321644.png" alt="image-20200622170321644" style="zoom:80%;" />
<ul>
<li>先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。</li>
<li>寻找安全序列的方式只有两种：<strong>每次都从最上面开始</strong>；<strong>按照从上到下顺序循环</strong></li>
</ul>
<p><strong>应用</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170415300.png" alt="image-20200622170415300" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170922576.png" alt="image-20200622170922576" style="zoom:67%;" />
<p><strong>如果单向顺序，查找安全序列的流程为</strong>：</p>
<ol>
<li>判断P0，返现剩余资源不能满足。<strong>判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。</strong></li>
<li>继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。<strong>判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。</strong></li>
<li><strong>继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。</strong></li>
<li>P0、 P1结束，直接跳过。<strong>判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。</strong></li>
<li>P0、 P1、P2、P3结束，直接跳过。<strong>判断P4，发现满足，则释放P4分配的资源。</strong></li>
<li><strong>最终的安全序列为：P1、P3、P0、P2、P4。</strong></li>
<li><strong>确认分配</strong>。</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172205550.png" alt="image-20200622172205550" style="zoom:67%;" />
<ul>
<li><strong>此时找不到安全序列，拒绝分配。</strong></li>
</ul>
<h3 id="检测死锁">检测死锁</h3>
<h3 id="解除死锁">解除死锁</h3>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172918571.png" alt="image-20200622172918571" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172948218.png" alt="image-20200622172948218" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173016842.png" alt="image-20200622173016842" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173053665.png" alt="image-20200622173053665" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173114342.png" alt="image-20200622173114342" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173233127.png" alt="image-20200622173233127" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第二章处理机管理]]></title>
        <id>https://xzzz2020.github.io/post/IyZhCzd1C/</id>
        <link href="https://xzzz2020.github.io/post/IyZhCzd1C/">
        </link>
        <updated>2020-06-22T06:30:37.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F">程序的执行方式</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%96%B9%E5%BC%8F">顺序方式（*）</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C">并发执行（***）</a></li>
<li><a href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C">并行执行</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">进程的状态</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb">进程控制块（PCB）</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%93%8D%E4%BD%9C">进程的四个操作</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">进程的创建</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2">进程的终止</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92">进程的阻塞和进程的唤醒</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5">进程调度概念</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</a></li>
<li><a href="#%E8%A1%A1%E9%87%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87">衡量调度算法指标</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97">进程调度算法（计算***）</a>
<ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">先来先服务调度算法（***）</a></li>
<li><a href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">短作业优先调度算法（***）</a></li>
<li><a href="#%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">高优先权调度算法（***）</a></li>
<li><a href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">高响应比优先调度算法</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">时间片轮转调度算法（***）</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级队列调度算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级反馈队列调度算法</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0">题目练习</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="程序的执行方式">程序的执行方式</h2>
<h3 id="顺序方式">顺序方式（*）</h3>
<p>内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着<strong>严格的先后次序</strong></p>
<p><strong>顺序执行的特点</strong>：</p>
<ul>
<li><strong>顺序性</strong>：程序执行有着明确的先后顺序</li>
<li><strong>封闭性</strong>：程序运行时独占所有资源</li>
<li><strong>可再现性</strong>：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同</li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>无法满足高性能</li>
</ul>
<h3 id="并发执行">并发执行（***）</h3>
<p>并发指一段时间内执行多个程序。多个程序同时进入内存，轮流<strong>交替执行</strong>。</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622092827851.png" alt="image-20200622092827851" style="zoom:67%;" />
<p><strong>并发执行的特点</strong>：</p>
<ul>
<li>
<p><strong>间断性</strong>：交替执行就是走走停停</p>
</li>
<li>
<p><strong>失去了封闭性</strong>：程序不再独占系统资源</p>
</li>
<li>
<p><strong>不可再现性</strong>：程序执行有多种结果。</p>
</li>
</ul>
<h3 id="并行执行">并行执行</h3>
<p>同一时刻有多个程序执行，只能在多处理机上实现</p>
<h2 id="进程">进程</h2>
<p>进程是研究并发方式下，程序的执行。</p>
<p><strong>进程的概念</strong>：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。</p>
<blockquote>
<p><strong>进程实体</strong>：由程序段、相关数据段和PCB组成</p>
</blockquote>
<h3 id="进程的特征">进程的特征</h3>
<ul>
<li><mark><strong>并发性</strong></mark>， 多个进程在一段时 间内同存于内存中同时运行</li>
<li><mark><strong>动态性</strong></mark>，进程由创建而产生，由调度而执行，由撤消而消亡。</li>
<li><strong>独立性</strong>，进程是能独立运行、资源分配、调度的基本单位。</li>
<li><strong>结构性</strong>，进程映像由程序、数据、栈和进程控制块( PCB )构成。</li>
<li><strong>异步性</strong>，进程按各自独立、不可预知的速度向前推进。</li>
</ul>
<h3 id="进程的状态">进程的状态</h3>
<p><strong>有三个状态</strong>：</p>
<ul>
<li><strong>就绪状态</strong>：指程序已经处于准备好运行的状态。</li>
<li><strong>执行状态</strong>：指程序已经获得CPU，正在执行。</li>
<li><strong>阻塞状态</strong>：指程序的执行因为某些原因无法继续执行。</li>
</ul>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622093952609.png" alt="image-20200622093952609" style="zoom:50%;" />
<h3 id="进程控制块pcb">进程控制块（PCB）</h3>
<ul>
<li>用来描述进程的基本情况和活动过程，进而控制和管理进程。（<strong>类似于学籍、户口等</strong>）</li>
<li>进程创建时会建立一个PCB，结束时会收回PCB</li>
</ul>
<p><strong>进程控制块中的信息</strong>：</p>
<ul>
<li><strong>进程标识符</strong>：包括内部标识符和外部标识符。</li>
<li><strong>处理机状态</strong>：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。</li>
<li><strong>进程控制信息</strong>：程序栈和数据地址，同步和通信机制，资源清单,链接指针。</li>
<li><strong>进程调度信息</strong></li>
</ul>
<p><strong>进程控制块中的组织方式</strong></p>
<ol>
<li>
<p><strong>线性方式</strong></p>
</li>
<li>
<p><strong>链接方式</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622095654092.png" alt="image-20200622095654092" style="zoom:50%;" />
</li>
<li>
<p><strong>索引方式</strong></p>
</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622095909769.png" alt="image-20200622095909769" style="zoom:50%;" />
<h2 id="进程控制">进程控制</h2>
<ul>
<li>
<p>进程控制用于创建、终止、阻塞和唤醒进程。</p>
</li>
<li>
<p>进程控制由操作系统内核原语来实现。</p>
<blockquote>
<p>原语是由若干条指令组成，用于完成一定功能的一个<strong>过程</strong>，所有的指令<strong>要么全做，要么全不做</strong>。（<strong>一个函数</strong>）</p>
</blockquote>
</li>
</ul>
<p><strong>用户态</strong>：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。</p>
<p><strong>系统态（内核态）</strong>：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。</p>
<h3 id="进程的四个操作">进程的四个操作</h3>
<h4 id="进程的创建">进程的创建</h4>
<p><strong>引起进程创建的事件</strong>：</p>
<ul>
<li>用户执行应用程序。</li>
<li>用户登录。</li>
<li>启动服务。</li>
<li>程序创建进程。</li>
</ul>
<p><strong>进程创建的过程</strong>（必须要求是原语）：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源，如内存空间等</li>
<li>初始化PCB</li>
<li>将进程插入就绪队列</li>
</ol>
<h4 id="进程的终止">进程的终止</h4>
<p><strong>引起进程终止的事件</strong>：</p>
<ul>
<li>正常结束。</li>
<li>异常结束。</li>
<li>外界干预。</li>
</ul>
<p><strong>进程的终止过程</strong>：</p>
<ul>
<li>
<p>检查进程状态。</p>
</li>
<li>
<p>有无子孙需要终止。</p>
</li>
<li>
<p>归还进程全部资源。</p>
</li>
<li>
<p>将PCB从进程中移除。</p>
</li>
</ul>
<h4 id="进程的阻塞和进程的唤醒">进程的阻塞和进程的唤醒</h4>
<h2 id="进程调度概念">进程调度概念</h2>
<p><strong>处理机调度的层次</strong>：</p>
<ul>
<li>高级调度</li>
<li>低级调度</li>
<li>中级调度</li>
</ul>
<p><strong>引起进程调度的事件</strong>：</p>
<ul>
<li>进程终止。</li>
<li>进程创建。</li>
<li>进程阻塞。</li>
<li>进程唤醒。</li>
<li>外部设备中断。</li>
</ul>
<p>进程切换时需要保存和恢复现场。</p>
<h3 id="进程调度的方式">进程调度的方式</h3>
<ul>
<li>
<p><strong>抢占式调度</strong>：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。</p>
</li>
<li>
<p><strong>非抢占式调度</strong>：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（<strong>只有时间片用完才能调度</strong>）</p>
</li>
</ul>
<h3 id="衡量调度算法指标">衡量调度算法指标</h3>
<p><strong>面向用户（***）</strong>：</p>
<ul>
<li><strong>平均周转时间</strong>：所有周转时间求平均。</li>
<li><strong>带权周转时间</strong>：一个程序的周转时间除以服务的时间。（&gt;=1）</li>
<li><strong>平均带权周转时间</strong>：对带权周转时间求平均。</li>
</ul>
<blockquote>
<p><strong>周转时间</strong>：从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
</blockquote>
<p><strong>面向系统</strong>：</p>
<ul>
<li><strong>吞吐量</strong>：在单位时间内系统所完成的作业数。</li>
<li><strong>处理机利用率</strong>：在过去一 段时间内CPU被占用的时间总和。</li>
<li><strong>各类资源的平衡利用率</strong>：保证系统所有的资源被合理利用。</li>
</ul>
<h2 id="进程调度算法计算">进程调度算法（计算***）</h2>
<h3 id="先来先服务调度算法">先来先服务调度算法（***）</h3>
<blockquote>
<p><strong>先来的进程先抢到CPU，有利于长作业，不利于短作业</strong></p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622112903214.png" alt="image-20200622111911566" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622112903214.png" alt="image-20200622112903214" style="zoom:67%;" />
<h3 id="短作业优先调度算法">短作业优先调度算法（***）</h3>
<blockquote>
<p><strong>在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。</strong></p>
<p><strong>只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。</strong></p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622113117858.png" alt="image-20200622113117858" style="zoom:67%;" />
<p><strong>非抢占方式：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622114213680.png" alt="image-20200622114213680" loading="lazy"></figure>
<p><strong>抢占式：</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622114634375.png" alt="image-20200622114634375" style="zoom:67%;" />
<h3 id="高优先权调度算法">高优先权调度算法（***）</h3>
<blockquote>
<p>按照优先权重分配CPU，优先数越小，优先权越大</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622115711510.png" alt="image-20200622115711510" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622120734094.png" alt="image-20200622120734094" style="zoom:50%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622120734094.png" alt="image-20200622120720361" style="zoom:50%;" />
<h3 id="高响应比优先调度算法">高响应比优先调度算法</h3>
<blockquote>
<p>按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久</p>
<p>响应比 = 等待时间/服务时间</p>
</blockquote>
<h3 id="时间片轮转调度算法">时间片轮转调度算法（***）</h3>
<blockquote>
<p>按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。</p>
<p>假设时间片为2。</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200624101953231.png" alt="image-20200624101953231" style="zoom:80%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622122733994.png" alt="image-20200622122330474" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622122733994.png" alt="image-20200622122733994" style="zoom:50%;" />
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<blockquote>
<p>优先调度优先级高的</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622122939586.png" alt="image-20200622122939586" style="zoom:50%;" />
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<blockquote>
<p>解决了低优先级队列长时间无法调度的问题</p>
</blockquote>
<h2 id="线程">线程</h2>
<p><strong>为什么提出线程？</strong></p>
<ul>
<li>进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。</li>
<li>一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。</li>
</ul>
<p><strong>线程概念</strong>：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。</p>
<p>如下图所示，每个线程都会有个栈，一共有三个线程：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622142107384.png" alt="image-20200622142107384" style="zoom: 80%;" />
<p><strong>线程的特点</strong>：</p>
<ul>
<li>一个线程<strong>拥有少量的资源</strong>，记录在<strong>线程控制块中</strong>。轻型实体，线程基本上不拥有资源，或者是有较少的资源;</li>
<li>一个进程的所有线程共享进程所拥有的全部资源。</li>
<li>线程是处理机调度的基本单位，多个线程可以并发执行。</li>
</ul>
<p><strong>线程与进程的比较</strong>：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200623095239272.png" alt="image-20200623095239272" loading="lazy"></figure>
<p><strong>线程的实现方式</strong>：</p>
<ul>
<li><strong>内核级线程</strong>：所有创建、切换等都需要内核的支持，开销较大（<strong>适合多处理器系统</strong>）</li>
<li><strong>用户级线程</strong>：可以不需要进入内核态创建，但是切换进程需要进入内核（<strong>开销小</strong>）</li>
<li><strong>组合方式</strong>：建立内核级线程与用户级线程的关系。</li>
</ul>
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622093526050.png" alt="image-20200622093526050" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622100444854.png" alt="image-20200622100444854" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622100540099.png" alt="image-20200622100540099" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622103623435.png" alt="image-20200622103623435" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622103657071.png" alt="image-20200622103657071" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622143148015.png" alt="image-20200622143148015" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一章操作系统引论]]></title>
        <id>https://xzzz2020.github.io/post/ZBrN48x_g/</id>
        <link href="https://xzzz2020.github.io/post/ZBrN48x_g/">
        </link>
        <updated>2020-06-21T12:49:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95">操作系统发展</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD">操作系统的功能</a>
<ul>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86">处理机管理</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98">存储器管理（内存）</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8io%E8%AE%BE%E5%A4%87">设备管理（高效使用IO设备）</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">操作系统接口</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">操作系统的基本特征</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8">操作系统的作用</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">设计目标</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">操作系统结构</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE">练习题目</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="操作系统发展">操作系统发展</h2>
<ul>
<li><strong>无操作系统</strong></li>
<li><strong>单道批处理系统</strong></li>
<li><strong>多道批处理系统</strong>：多个程序交替使用CPU，目的是提高CPU的利用率</li>
<li><strong>分时系统</strong>：使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了<code>时分复用技术</code></li>
<li><strong>实时系统</strong>：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对<code>时间要求苛刻</code></li>
</ul>
<h2 id="操作系统的功能">操作系统的功能</h2>
<h3 id="处理机管理">处理机管理</h3>
<ol>
<li>进程控制</li>
<li>进程调度</li>
<li>进程同步</li>
<li>进程通信</li>
<li>死锁</li>
</ol>
<h3 id="存储器管理内存">存储器管理（内存）</h3>
<ol>
<li>内存分配</li>
<li>内存共享</li>
<li>内存扩充</li>
<li>内存保护</li>
</ol>
<h3 id="设备管理高效使用io设备">设备管理（高效使用IO设备）</h3>
<ol>
<li>设备处理</li>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备的独立性</li>
<li>设备的虚拟性</li>
</ol>
<h3 id="文件管理">文件管理</h3>
<ol>
<li>文件读/写</li>
<li>目录管理</li>
<li>存储空间管理</li>
<li>文件共享、存储性能优化、存储可靠性和数据一致性</li>
</ol>
<h3 id="操作系统接口">操作系统接口</h3>
<ol>
<li>
<p>图形接口</p>
</li>
<li>
<p>系统调用</p>
</li>
<li>
<p>命令调用</p>
<p>​	<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202748865.png" alt="image-20200621202748865" style="zoom: 50%;" /></p>
</li>
</ol>
<h2 id="操作系统的基本特征">操作系统的基本特征</h2>
<ul>
<li><strong>并发性</strong>：多个程序在同一时间间隔执行</li>
<li><strong>共享性</strong>：多个并发的程序共同使用计算机资源，提高计算机资源的利用率</li>
<li><strong>虚拟性</strong>：有时分复用和空分复用两种技术</li>
<li><strong>异步性</strong>：表现为多任务执行的无序性，主要应对阻塞</li>
</ul>
<h2 id="操作系统的作用">操作系统的作用</h2>
<p>操作系统(Operating System, OS)是<strong>一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。</strong></p>
<ul>
<li><strong>是用户和计算机系统之间的接口</strong></li>
<li><strong>是系统资源的管理者</strong></li>
<li><strong>扩充计算机的功能，实现对计算机的抽象</strong></li>
</ul>
<h2 id="设计目标">设计目标</h2>
<ul>
<li><strong>方便性</strong></li>
<li><strong>有效性</strong></li>
<li><strong>扩充性</strong></li>
<li><strong>开放性</strong></li>
</ul>
<h2 id="操作系统结构">操作系统结构</h2>
<ol>
<li>无操作系统结构</li>
<li>模块化结构</li>
<li>层次结构</li>
<li>微内核结构</li>
</ol>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621201525920.png" alt="image-20200621201525920" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202025346.png" alt="image-20200621201751451" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621201850031.png" alt="image-20200621201850031" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202047000.png" alt="image-20200621202047000" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621202056968.png" alt="image-20200621202056968" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621203755881.png" alt="image-20200621203755881" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200621203910781.png" alt="image-20200621203910781" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
</feed>