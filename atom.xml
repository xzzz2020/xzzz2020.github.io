<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzzz2020.github.io</id>
    <title>xzzz2020</title>
    <updated>2020-06-22T09:34:08.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzzz2020.github.io"/>
    <link rel="self" href="https://xzzz2020.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzzz2020.github.io/images/avatar.png</logo>
    <icon>https://xzzz2020.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xzzz2020</rights>
    <entry>
        <title type="html"><![CDATA[第三章进程同步与死锁]]></title>
        <id>https://xzzz2020.github.io/post/vUwZiOAP9/</id>
        <link href="https://xzzz2020.github.io/post/vUwZiOAP9/">
        </link>
        <updated>2020-06-22T09:25:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="进程同步">进程同步</h2>
<p><strong>临界资源</strong>：对一些硬件而言，打印机就是一个临界资源，即多个程序共同需要抢占的资源</p>
<p><strong>临界区</strong>：每个进程中访问临界资源的代码</p>
<p><strong>实现互斥的结构</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622150153590.png" alt="image-20200622150153590" style="zoom: 67%;" />
<p><strong>硬件实现</strong>：</p>
<ul>
<li><strong>关中断</strong>：让处理机始终执行一个程序，不进行程序的切换</li>
<li><strong>指令</strong></li>
</ul>
<p><strong>同步应该遵循的规则</strong>：</p>
<ul>
<li><strong>空闲让进</strong>：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</li>
<li><strong>忙则等待</strong>：当有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</li>
<li><strong>有限等待</strong>：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</li>
<li><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等&quot;</li>
</ul>
<p><strong>前驱图：</strong></p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622150703762.png" alt="image-20200622150703762" style="zoom:67%;" />
<blockquote>
<p><strong>若想执行S2，则需要先执行S1。</strong></p>
</blockquote>
<h2 id="信号量">信号量</h2>
<h3 id="整型信号量">整型信号量</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622151744719.png" alt="image-20200622151744719" style="zoom:67%;" />
<h3 id="记录性信号量">记录性信号量（***）</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622151852525.png" alt="image-20200622151852525" style="zoom:67%;" />
<h3 id="and型信号量">AND型信号量</h3>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622154354678.png" alt="image-20200622154354678" style="zoom:80%;" />
<h3 id="信号量的应用">信号量的应用（***）</h3>
<h4 id="利用信号量实现互斥">利用信号量实现互斥</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153000297.png" alt="image-20200622153000297" style="zoom:50%;" />
<p><strong>实现算法</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153444468.png" alt="image-20200622153444468" style="zoom:50%;" />
<p><strong>符合</strong>：空闲让进，忙则等待和有限等待</p>
<h4 id="利用信号量实现前驱关系">利用信号量实现前驱关系</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622153525416.png" alt="image-20200622153525416" style="zoom: 67%;" />
<h4 id="资源的分配">资源的分配</h4>
<p>申请资源时需要执行P操作，释放资源时执行V操作</p>
<h2 id="同步的问题">同步的问题</h2>
<ul>
<li>生产者-消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者-写者问题</li>
</ul>
<h2 id="进程间通信">进程间通信</h2>
<p><strong>低级通信</strong>：信号量机制</p>
<p><strong>高级通讯</strong>：共享存储器系统、消息传递系统、管道通信。</p>
<h2 id="死锁的相关概念">死锁的相关概念</h2>
<p><strong>可抢占资源</strong>：某进程在获得该资源后，该资源可以再被其他进程或系统抢占。</p>
<p><strong>不可抢占的资源</strong>：一旦系统将某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</p>
<p><strong>死锁的定义</strong>：如果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程就是死锁。</p>
<p><strong>产生死锁的原因</strong>：</p>
<ul>
<li>竞争不可抢占资源引发死锁。</li>
<li>竞争可消耗资源引发死锁。</li>
<li>进程推进顺序不当引发死锁。</li>
</ul>
<h2 id="处理死锁的基本方法">处理死锁的基本方法</h2>
<h3 id="预防死锁">预防死锁</h3>
<ul>
<li>破坏“请求和保持条件”</li>
<li>破坏“不可抢占条件”</li>
<li><strong>破坏“循环等待条件”</strong>：进程统一按照某种线性规则申请资源。例如,输入机资源序号为1,打印机序号为2，磁带机资源序号为3,磁盘资源序号为4，进程在申请资源时，<mark><strong>必须按照从1到4或者从4到1的顺序申请</strong></mark>。</li>
</ul>
<h3 id="避免死锁">避免死锁（***）</h3>
<p><strong>安全状态</strong>：安全状态，是指系统能按某种顺序(P1, P2,Pn)(称此序列为安全序列)，来为每个进程Pi分配其所需的资源,<mark><strong>直到满足每个进程对资源的最大需求</strong></mark>，使每个进程都可以顺利地完成。</p>
<p><strong>不安全状态</strong>：如果系统无法找到这样一个安全序列， 称系统处于不安全状态。</p>
<blockquote>
<p>要避免死锁，需要使系统处于安全状态；系统处于不安全状态，并不一定处于死锁状态</p>
</blockquote>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622165340017.png" alt="image-20200622165340017" style="zoom:67%;" />
<ul>
<li>根据上述定义，当给P1分配2个资源时，则此时P1、P2和P3都无法满足最大需求，处于不安全状态</li>
</ul>
<h4 id="银行家算法">银行家算法（***）</h4>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170224200.png" alt="image-20200622170224200" style="zoom:80%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170321644.png" alt="image-20200622170321644" style="zoom:80%;" />
<ul>
<li>先假设分配可以满足，做一次安全检测，如果仍能处于安全状态，则允许分配。</li>
<li>寻找安全序列的方式只有两种：<strong>每次都从最上面开始</strong>；<strong>按照从上到下顺序循环</strong></li>
</ul>
<p><strong>应用</strong>：</p>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170415300.png" alt="image-20200622170415300" style="zoom:67%;" />
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622170922576.png" alt="image-20200622170922576" style="zoom:67%;" />
<p><strong>如果单向顺序，查找安全序列的流程为</strong>：</p>
<ol>
<li>判断P0，返现剩余资源不能满足。<strong>判断P1，发现满足，则释放P1分配的资源，此时资源是：5，3，2。</strong></li>
<li>继续判断P0，返现剩余资源不能满足。P1结束，则直接跳过。判断P2，返现剩余资源不能满足。<strong>判断P3，发现满足，则释放P3分配的资源，此时资源是：7，4，3。</strong></li>
<li><strong>继续判断P0，发现满足，则释放P0分配的资源，此时资源是：7，5，3。</strong></li>
<li>P0、 P1结束，直接跳过。<strong>判断P2，发现满足，则释放P2分配的资源，此时资源是：10，5，5.。</strong></li>
<li>P0、 P1、P2、P3结束，直接跳过。<strong>判断P4，发现满足，则释放P4分配的资源。</strong></li>
<li><strong>最终的安全序列为：P1、P3、P0、P2、P4。</strong></li>
<li><strong>确认分配</strong>。</li>
</ol>
<img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172205550.png" alt="image-20200622172205550" style="zoom:67%;" />
<ul>
<li><strong>此时找不到安全序列，拒绝分配。</strong></li>
</ul>
<h3 id="检测死锁">检测死锁</h3>
<h3 id="解除死锁">解除死锁</h3>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172918571.png" alt="image-20200622172918571" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622172948218.png" alt="image-20200622172948218" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173016842.png" alt="image-20200622173016842" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173053665.png" alt="image-20200622173053665" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173114342.png" alt="image-20200622173114342" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/xzzz2020/PicBed01/raw/master/img/image-20200622173233127.png" alt="image-20200622173233127" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第二章处理机管理]]></title>
        <id>https://xzzz2020.github.io/post/IyZhCzd1C/</id>
        <link href="https://xzzz2020.github.io/post/IyZhCzd1C/">
        </link>
        <updated>2020-06-22T06:30:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="程序的执行方式">程序的执行方式</h2>
<h3 id="顺序方式">顺序方式（*）</h3>
<p>内存中只能驻留一个程序，前一个程序结束，后一个程序才能进来，并且有着<strong>严格的先后次序</strong></p>
<p><strong>顺序执行的特点</strong>：</p>
<ul>
<li><strong>顺序性</strong>：程序执行有着明确的先后顺序</li>
<li><strong>封闭性</strong>：程序运行时独占所有资源</li>
<li><strong>可再现性</strong>：初始条件相同，若程序执行顺序不变，则每次得到的结果一定相同</li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>无法满足高性能</li>
</ul>
<h3 id="并发执行">并发执行（***）</h3>
<p>并发指一段时间内执行多个程序。多个程序同时进入内存，轮流<strong>交替执行</strong>。</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622092827851.png" alt="image-20200622092827851" style="zoom:67%;" />
<p><strong>并发执行的特点</strong>：</p>
<ul>
<li>
<p><strong>间断性</strong>：交替执行就是走走停停</p>
</li>
<li>
<p><strong>失去了封闭性</strong>：程序不再独占系统资源</p>
</li>
<li>
<p><strong>不可再现性</strong>：程序执行有多种结果。</p>
</li>
</ul>
<h3 id="并行执行">并行执行</h3>
<p>同一时刻有多个程序执行，只能在多处理机上实现</p>
<h2 id="进程">进程</h2>
<p>进程是研究并发方式下，程序的执行。</p>
<p><strong>进程的概念</strong>：进程是进程实体的运行过程，是系统进行资源分配和调度的一一个独立单位。</p>
<blockquote>
<p><strong>进程实体</strong>：由程序段、相关数据段和PCB组成</p>
</blockquote>
<h3 id="进程的状态">进程的状态</h3>
<p><strong>有三个状态</strong>：</p>
<ul>
<li><strong>就绪状态</strong>：指程序已经处于准备好运行的状态。</li>
<li><strong>执行状态</strong>：指程序已经获得CPU，正在执行。</li>
<li><strong>阻塞状态</strong>：指程序的执行因为某些原因无法继续执行。</li>
</ul>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622093952609.png" alt="image-20200622093952609" style="zoom:50%;" />
<h3 id="进程控制块pcb">进程控制块（PCB）</h3>
<ul>
<li>用来描述进程的基本情况和活动过程，进而控制和管理进程。（<strong>类似于学籍、户口等</strong>）</li>
<li>进程创建时会建立一个PCB，结束时会收回PCB</li>
</ul>
<p><strong>进程控制块中的信息</strong>：</p>
<ul>
<li><strong>进程标识符</strong>：包括内部标识符和外部标识符。</li>
<li><strong>处理机状态</strong>：处理机状态包括通用寄存器、程序计数寄存器、程序状态寄存器、栈寄存器信息。</li>
<li><strong>进程控制信息</strong>：程序栈和数据地址，同步和通信机制，资源清单,链接指针。</li>
<li><strong>进程调度信息</strong></li>
</ul>
<p><strong>进程控制块中的组织方式</strong></p>
<ol>
<li>
<p><strong>线性方式</strong></p>
</li>
<li>
<p><strong>链接方式</strong></p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622095654092.png" alt="image-20200622095654092" style="zoom:50%;" />
</li>
<li>
<p><strong>索引方式</strong></p>
</li>
</ol>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622095909769.png" alt="image-20200622095909769" style="zoom:50%;" />
<h2 id="进程控制">进程控制</h2>
<ul>
<li>
<p>进程控制用于创建、终止、阻塞和唤醒进程。</p>
</li>
<li>
<p>进程控制由操作系统内核原语来实现。</p>
<blockquote>
<p>原语是由若干条指令组成，用于完成一定功能的一个<strong>过程</strong>，所有的指令<strong>要么全做，要么全不做</strong>。（<strong>一个函数</strong>）</p>
</blockquote>
</li>
</ul>
<p><strong>用户态</strong>：具有较低特权的执行状态，进行执行规定的指令，访问特定的寄存器和存储区。</p>
<p><strong>系统态（内核态）</strong>：具有较高特权，能执行全部的指令，访问所有的寄存器和存储区。</p>
<h3 id="进程的四个操作">进程的四个操作</h3>
<h4 id="进程的创建">进程的创建</h4>
<p><strong>引起进程创建的事件</strong>：</p>
<ul>
<li>用户执行应用程序。</li>
<li>用户登录。</li>
<li>启动服务。</li>
<li>程序创建进程。</li>
</ul>
<p><strong>进程创建的过程</strong>（必须要求是原语）：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源，如内存空间等</li>
<li>初始化PCB</li>
<li>将进程插入就绪队列</li>
</ol>
<h4 id="进程的终止">进程的终止</h4>
<p><strong>引起进程终止的事件</strong>：</p>
<ul>
<li>正常结束。</li>
<li>异常结束。</li>
<li>外界干预。</li>
</ul>
<p><strong>进程的终止过程</strong>：</p>
<ul>
<li>
<p>检查进程状态。</p>
</li>
<li>
<p>有无子孙需要终止。</p>
</li>
<li>
<p>归还进程全部资源。</p>
</li>
<li>
<p>将PCB从进程中移除。</p>
</li>
</ul>
<h4 id="进程的阻塞和进程的唤醒">进程的阻塞和进程的唤醒</h4>
<h2 id="进程调度概念">进程调度概念</h2>
<p><strong>处理机调度的层次</strong>：</p>
<ul>
<li>高级调度</li>
<li>低级调度</li>
<li>中级调度</li>
</ul>
<p><strong>引起进程调度的事件</strong>：</p>
<ul>
<li>进程终止。</li>
<li>进程创建。</li>
<li>进程阻塞。</li>
<li>进程唤醒。</li>
<li>外部设备中断。</li>
</ul>
<p>进程切换时需要保存和恢复现场。</p>
<h3 id="进程调度的方式">进程调度的方式</h3>
<ul>
<li>
<p><strong>抢占式调度</strong>：允许调度程序根据某种原则，暂停某个占用处理机的进程，抢占已经分配出去的处理机。抢占的原则有优先权原则、短作业优先原则和时间片原则。</p>
</li>
<li>
<p><strong>非抢占式调度</strong>：进程一旦获得处理机，只有在该进程任务完成或因某事件而阻塞时，才让出处理机，决不允许某进程抢占已经分配出去的处理机。（<strong>只有时间片用完才能调度</strong>）</p>
</li>
</ul>
<h3 id="衡量调度算法指标">衡量调度算法指标</h3>
<p><strong>面向用户（***）</strong>：</p>
<ul>
<li><strong>平均周转时间</strong>：所有周转时间求平均。</li>
<li><strong>带权周转时间</strong>：一个程序的周转时间除以服务的时间。（&gt;=1）</li>
<li><strong>平均带权周转时间</strong>：对带权周转时间求平均。</li>
</ul>
<blockquote>
<p><strong>周转时间</strong>：从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
</blockquote>
<p><strong>面向系统</strong>：</p>
<ul>
<li><strong>吞吐量</strong>：在单位时间内系统所完成的作业数。</li>
<li><strong>处理机利用率</strong>：在过去一 段时间内CPU被占用的时间总和。</li>
<li><strong>各类资源的平衡利用率</strong>：保证系统所有的资源被合理利用。</li>
</ul>
<h2 id="进程调度算法计算">进程调度算法（计算）</h2>
<h3 id="先来先服务调度算法fcfs">先来先服务调度算法（FCFS）</h3>
<blockquote>
<p><strong>先来的进程先抢到CPU，有利于长作业，不利于短作业</strong></p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622111911566.png" alt="image-20200622111911566" style="zoom:67%;" />
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622112903214.png" alt="image-20200622112903214" style="zoom:67%;" />
<h3 id="短作业优先调度算法">短作业优先调度算法</h3>
<blockquote>
<p><strong>在分配时，优先分配给服务时间最短的，降低了系统的平均周转时间，对长作业不利。</strong></p>
<p><strong>只有在抢占的时候，进程的创建才会导致需要重新分配CPU，非抢占式在进程终止的时候分配。</strong></p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622113117858.png" alt="image-20200622113117858" style="zoom:67%;" />
<p><strong>非抢占方式：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622114213680.png" alt="image-20200622114213680" loading="lazy"></figure>
<p><strong>抢占式：</strong></p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622114634375.png" alt="image-20200622114634375" style="zoom:67%;" />
<h3 id="高优先权调度算法">高优先权调度算法</h3>
<blockquote>
<p>按照优先权重分配CPU，优先数越小，优先权越大</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622115711510.png" alt="image-20200622115711510" style="zoom:67%;" />
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622120734094.png" alt="image-20200622120734094" style="zoom:50%;" />
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622120720361.png" alt="image-20200622120720361" style="zoom:50%;" />
<h3 id="高响应比优先调度算法">高响应比优先调度算法</h3>
<blockquote>
<p>按照响应比去分配CPU资源，既考虑的作业的先后顺序，又优先照顾短作业，同时不会使长作业等太久</p>
<p>响应比 = 等待时间/服务时间</p>
</blockquote>
<h3 id="时间片轮转调度算法">时间片轮转调度算法</h3>
<blockquote>
<p>按照先来先服务的将作业放入一个调度队列中，每隔一定的时间片，发生一次调度，一般为10ms到100ms。</p>
<p>假设时间片为2。</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622122330474.png" alt="image-20200622122330474" style="zoom:67%;" />
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622122733994.png" alt="image-20200622122733994" style="zoom:50%;" />
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<blockquote>
<p>优先调度优先级高的</p>
</blockquote>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622122939586.png" alt="image-20200622122939586" style="zoom:50%;" />
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<blockquote>
<p>解决了低优先级队列长时间无法调度的问题</p>
</blockquote>
<h2 id="线程">线程</h2>
<p><strong>为什么提出线程？</strong></p>
<ul>
<li>进程是资源的拥有者，在并发时，对进程的切换需要有较大时空的开销。</li>
<li>一个进程内全部线程都是在同一个地址空间进行，在并发时可以减少系统的开销。</li>
</ul>
<p><strong>线程概念</strong>：线程是进程的一个实体，是被系统独立调度的基本单位，只拥有少量的资源(如CPU寄存器资源)。</p>
<p>如下图所示，每个线程都会有个栈，一共有三个线程：</p>
<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622142107384.png" alt="image-20200622142107384" style="zoom: 80%;" />
<p><strong>线程的特点</strong>：</p>
<ul>
<li>一个线程<strong>拥有少量的资源</strong>，记录在<strong>线程控制块中</strong>。轻型实体，线程基本上不拥有资源，或者是有较少的资源;</li>
<li>一个进程的所有线程共享进程所拥有的全部资源。</li>
<li>线程是处理机调度的基本单位，多个线程可以并发执行。</li>
</ul>
<p><strong>线程与进程的比较</strong>：</p>
<figure data-type="image" tabindex="2"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622142510460.png" alt="image-20200622142510460" loading="lazy"></figure>
<p><strong>线程的实现方式</strong>：</p>
<ul>
<li><strong>内核级线程</strong>：所有创建、切换等都需要内核的支持，开销较大（<strong>适合多处理器系统</strong>）</li>
<li><strong>用户级线程</strong>：可以不需要进入内核态创建，但是切换进程需要进入内核（<strong>开销小</strong>）</li>
<li><strong>组合方式</strong>：建立内核级线程与用户级线程的关系。</li>
</ul>
<h2 id="题目练习">题目练习</h2>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622093526050.png" alt="image-20200622093526050" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622100444854.png" alt="image-20200622100444854" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622100540099.png" alt="image-20200622100540099" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622103623435.png" alt="image-20200622103623435" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622103657071.png" alt="image-20200622103657071" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200622143148015.png" alt="image-20200622143148015" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一章操作系统引论]]></title>
        <id>https://xzzz2020.github.io/post/ZBrN48x_g/</id>
        <link href="https://xzzz2020.github.io/post/ZBrN48x_g/">
        </link>
        <updated>2020-06-21T12:49:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="操作系统发展">操作系统发展</h2>
<ul>
<li><strong>无操作系统</strong></li>
<li><strong>单道批处理系统</strong></li>
<li><strong>多道批处理系统</strong></li>
<li><strong>分时系统</strong>：使用户以交互的方式共享计算机，用户感觉到自己在享用到计算机资源，本质还是利用了<code>时分复用技术</code></li>
<li><strong>现代操作系统</strong>：在规定的时间开始事件的处理或者在规定时间内完成对事件的处理，对<code>时间要求苛刻</code></li>
</ul>
<h2 id="操作系统的功能">操作系统的功能</h2>
<h3 id="处理机管理">处理机管理</h3>
<ol>
<li>进程控制</li>
<li>进程调度</li>
<li>进程同步</li>
<li>进程通信</li>
<li>死锁</li>
</ol>
<h3 id="存储器管理内存">存储器管理（内存）</h3>
<ol>
<li>内存分配</li>
<li>内存共享</li>
<li>内存扩充</li>
<li>内存保护</li>
</ol>
<h3 id="设备管理高效使用io设备">设备管理（高效使用IO设备）</h3>
<ol>
<li>设备处理</li>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备的独立性</li>
<li>设备的虚拟性</li>
</ol>
<h3 id="文件管理">文件管理</h3>
<ol>
<li>文件读/写</li>
<li>目录管理</li>
<li>存储空间管理</li>
<li>文件共享、存储性能优化、存储可靠性和数据一致性</li>
</ol>
<h3 id="操作系统接口">操作系统接口</h3>
<ol>
<li>
<p>图形接口</p>
</li>
<li>
<p>系统调用</p>
</li>
<li>
<p>命令调用</p>
<p>​	<img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621202748865.png" alt="image-20200621202748865" style="zoom: 50%;" /></p>
</li>
</ol>
<h2 id="操作系统的基本特征">操作系统的基本特征</h2>
<ul>
<li><strong>并发性</strong>：多个程序在同一时间间隔执行</li>
<li><strong>共享性</strong>：多个并发的程序共同使用计算机资源，提高计算机资源的利用率</li>
<li><strong>虚拟性</strong>：有时分复用和空分复用两种技术</li>
<li><strong>异步性</strong>：表现为多任务执行的无序性，主要应对阻塞</li>
</ul>
<h2 id="操作系统的作用">操作系统的作用</h2>
<p>操作系统(Operating System, OS)是<strong>一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。</strong></p>
<ul>
<li><strong>是用户和计算机系统之间的接口</strong></li>
<li><strong>是系统资源的管理者</strong></li>
<li><strong>扩充计算机的功能，实现对计算机的抽象</strong></li>
</ul>
<h2 id="设计目标">设计目标</h2>
<ul>
<li><strong>方便性</strong></li>
<li><strong>有效性</strong></li>
<li><strong>扩充性</strong></li>
<li><strong>开放性</strong></li>
</ul>
<h2 id="操作系统结构">操作系统结构</h2>
<ol>
<li>无操作系统结构</li>
<li>模块化结构</li>
<li>层次结构</li>
<li>微内核结构</li>
</ol>
<h2 id="练习题目">练习题目</h2>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621201525920.png" alt="image-20200621201525920" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621201751451.png" alt="image-20200621201751451" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621201850031.png" alt="image-20200621201850031" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="4"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621202025346.png" alt="image-20200621202025346" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621202047000.png" alt="image-20200621202047000" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="6"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621202056968.png" alt="image-20200621202056968" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="7"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621203755881.png" alt="image-20200621203755881" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="8"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621203910781.png" alt="image-20200621203910781" loading="lazy"></figure>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="9"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200621204526744.png" alt="image-20200621204526744" loading="lazy"></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020最新-Java面试]]></title>
        <id>https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/</id>
        <link href="https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/">
        </link>
        <updated>2020-06-18T12:29:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：<a href="https://blog.csdn.net/qq_43040688/article/details/105819866">https://blog.csdn.net/qq_43040688/article/details/105819866</a></p>
</blockquote>
<p>这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。</p>
<br>
<br>
<br>
<br>
<br>
<h2 id="一-数据库">一. 数据库</h2>
<h3 id="11-关系型数据库">1.1 关系型数据库</h3>
<h4 id="mysql已更新">MySQL(已更新)</h4>
<p>推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》<br>
<code>对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句</code></p>
<table>
<thead>
<tr>
<th>SQL语句学习</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105346357">https://blog.csdn.net/qq_43040688/article/details/105346357</a></td>
</tr>
<tr>
<td>重点部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105348610">https://blog.csdn.net/qq_43040688/article/details/105348610</a></td>
</tr>
<tr>
<td>扩展部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105381801">https://blog.csdn.net/qq_43040688/article/details/105381801</a></td>
</tr>
</tbody>
</table>
<p><code>接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构</code></p>
<table>
<thead>
<tr>
<th>SQL高级部分</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL体系结构和存储引擎介绍</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105393816">https://blog.csdn.net/qq_43040688/article/details/105393816</a></td>
</tr>
<tr>
<td>InnoDB存储引擎</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105415093">https://blog.csdn.net/qq_43040688/article/details/105415093</a></td>
</tr>
<tr>
<td>MySQL 索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105419053">https://blog.csdn.net/qq_43040688/article/details/105419053</a></td>
</tr>
<tr>
<td>MySQL创建高性能的索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105454477">https://blog.csdn.net/qq_43040688/article/details/105454477</a></td>
</tr>
<tr>
<td>MySQL查询性能优化</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105456790">https://blog.csdn.net/qq_43040688/article/details/105456790</a></td>
</tr>
<tr>
<td>MySQL锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105440448">https://blog.csdn.net/qq_43040688/article/details/105440448</a></td>
</tr>
<tr>
<td>MySQL事务</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441274">https://blog.csdn.net/qq_43040688/article/details/105441274</a></td>
</tr>
<tr>
<td>MySQL备份</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441944">https://blog.csdn.net/qq_43040688/article/details/105441944</a></td>
</tr>
<tr>
<td>MySQL架构</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105450005">https://blog.csdn.net/qq_43040688/article/details/105450005</a></td>
</tr>
<tr>
<td>MySQL高级特性</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105465192">https://blog.csdn.net/qq_43040688/article/details/105465192</a></td>
</tr>
<tr>
<td>分库分表的高频面试题</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105594653">https://blog.csdn.net/qq_43040688/article/details/105594653</a></td>
</tr>
</tbody>
</table>
<h3 id="12-非关系型数据库">1.2 非关系型数据库</h3>
<h4 id="redis">Redis</h4>
<h2 id="二-java基础">二、Java基础</h2>
<h3 id="21-java虚拟机已更新">2.1 Java虚拟机（已更新）</h3>
<p>虛拟机推荐 <strong>《深入理解Java虚拟机》</strong> 这本书，重点学习一下<code>内存</code>、<code>垃圾回收</code>、<code>类加载机制</code>这几部分内容。</p>
<table>
<thead>
<tr>
<th>JVM内存结构</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>JVM简介</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104964070">https://blog.csdn.net/qq_43040688/article/details/104964070</a></td>
</tr>
<tr>
<td>程序计数器和虚拟机栈</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104970081">https://blog.csdn.net/qq_43040688/article/details/104970081</a></td>
</tr>
<tr>
<td>本地方法栈和堆</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104972811">https://blog.csdn.net/qq_43040688/article/details/104972811</a></td>
</tr>
<tr>
<td>方法区</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104982648">https://blog.csdn.net/qq_43040688/article/details/104982648</a></td>
</tr>
<tr>
<td>直接内存</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104996032">https://blog.csdn.net/qq_43040688/article/details/104996032</a></td>
</tr>
</tbody>
</table>
<h3 id="22-java并发已更新">2.2 Java并发（已更新）</h3>
<blockquote>
<p>Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久</p>
</blockquote>
<h4 id="java并发基础">Java并发基础</h4>
<blockquote>
<p>学习Java并发，需要先掌握线程的一些基础知识<br>
这些基础知识的组合构成了后面的设计模式</p>
</blockquote>
<ul>
<li>首先应该了解如何启动一个多线程，即<strong>使用Runnable、Callable、Thread</strong>；还需要了解线程启动后的<strong>生命周期</strong>，<strong>了解了不用实现方式的差别</strong>，最重要的<strong>研读Thread的源码</strong>，详情参考：<code>Java多线程起步</code>，<code>Thread构造函数源码分析</code></li>
<li>需要学习<strong>Thread常用API</strong>以及<strong>三种关闭线程的方式</strong>，详情参考：<code>Thread的API</code></li>
<li>需要了解<strong>this锁</strong>和<strong>class锁</strong>，详情参考：<code>Java多线程之认识“锁”</code></li>
<li>需要了解<strong>线程间的通讯</strong>，最基本的就是消费者和生产者模型，需要深入了解了<strong>wait、sleep、notify、nitifyAll</strong>的机制和差异，对于<strong>wait set</strong>要有个清晰的认识，详情参考：<code>Java多线程之线程间的通讯</code></li>
<li>需要尝试自定义了一个<strong>Boolean锁</strong>，了解了<strong>加锁和释放锁的过程</strong>，实现了获取正在阻塞的线程；需要了解<strong>线程运行时出现异常的处理方式</strong><br>
，详情参考：<code>自定义Boolean锁&amp;捕获线程中的异常</code></li>
<li>需要学习了<strong>线程组的概念以及常用API</strong>，如interrupt，setDaemon，activeCount，enumerate， 详情参考：<code>线程组</code></li>
<li>需要<strong>自定义了一个线程池</strong>，对线程池的处理机制有了较深的理解，详情参考：<code>自定义线程池</code></li>
</ul>
<table>
<thead>
<tr>
<th>Java并发基础</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java多线程起步</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/103979628">https://blog.csdn.net/qq_43040688/article/details/103979628</a></td>
</tr>
<tr>
<td>Thread构造函数源码分析</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105543926">https://blog.csdn.net/qq_43040688/article/details/105543926</a></td>
</tr>
<tr>
<td>Thread的API</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105747547">https://blog.csdn.net/qq_43040688/article/details/105747547</a></td>
</tr>
<tr>
<td>Java多线程之认识“锁”</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105752943">https://blog.csdn.net/qq_43040688/article/details/105752943</a></td>
</tr>
<tr>
<td>Java多线程之线程间的通讯</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105754406">https://blog.csdn.net/qq_43040688/article/details/105754406</a></td>
</tr>
<tr>
<td>自定义Boolean锁&amp;捕获线程中的异常</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105771445">https://blog.csdn.net/qq_43040688/article/details/105771445</a></td>
</tr>
<tr>
<td>线程组</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105774614">https://blog.csdn.net/qq_43040688/article/details/105774614</a></td>
</tr>
<tr>
<td>自定义线程池</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105786243">https://blog.csdn.net/qq_43040688/article/details/105786243</a></td>
</tr>
</tbody>
</table>
<h4 id="多线程的设计模式">多线程的设计模式</h4>
<blockquote>
<p>Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合<font color = "red">以满足应用需求</font><br>
<strong>下面有十四个多线程的设计模式，帮助理解后面的JUC包。</strong></p>
</blockquote>
<ul>
<li>
<p>第一个设计模式是：<strong>观察者模式</strong>。需要定义一个<strong>主题</strong>，一个<strong>观察者</strong>。<font color = "purple">主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。</font>详情参考：<code>观察者模式</code></p>
</li>
<li>
<p>第二个设计模式是：<strong>单例模式</strong>。解决方式有三种：<font color = "purple">第一种是double check方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static 类实现；第三种是利用enum类实现。</font>详情参考：<code>单例模式</code></p>
</li>
<li>
<p>第三个设计模式是<strong>单线程执行模式</strong>。<font color = "purple">就是在同一时刻只能有一个对共享资源进行操作。</font>详情参考：<code>单线程执行设计模式</code></p>
</li>
<li>
<p>第四个设计模式<strong>不可变对象设计模式</strong>。<font color = "purple">是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。</font>详情参考：<code>不可变对象设计模式</code></p>
</li>
<li>
<p>第五个设计模式<strong>确保挂起设计模式</strong>。<font color = "purple">当线程在工作时，如果来了其他任务，将任务放入到队列中等待。</font>详情参考：<code>确保挂起设计模式</code></p>
</li>
<li>
<p>第六个设计模式<strong>Balking设计模式</strong>。<font color = "purple">当工作已经执行过了，就直接return，防止重复的工作，提高效率。</font>详情参考：<code>Balking设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>生产者-消费者设计模式</strong>。<font color = "purple">如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。</font>详情参考：<code>生产者-消费者设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>读写锁的设计模式</strong>。<font color = "purple">读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能</font>。详情参考：<code>读写锁的设计模式</code></p>
</li>
<li>
<p>第八个设计模式<strong>Thread-Per-Message</strong>。<font color = "purple">每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。</font>详情参考：<code>Thread-Per-Message</code></p>
</li>
<li>
<p>第九个设计模式 <strong>Worker 设计模式</strong>。<font color = "purple">需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。</font><br>
详情参考：<code>Worker 设计模式</code></p>
</li>
<li>
<p>第十个设计模式<strong>Future设计模式</strong>。<font color = "purple">通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。</font>详情参考：<code>Future设计模式</code></p>
</li>
<li>
<p>第十一个设计模式<strong>两阶段终止设计模式</strong>。<font color = "purple">当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。</font>详情参考：<code>两阶段终止设计模式</code></p>
</li>
<li>
<p>第十二个设计模式<strong>线程保险箱设计模式</strong>。<font color = "purple">利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。</font >详情参考：<code>线程保险箱设计模式</code>和<code>上下文设计模式</code></p>
</li>
<li>
<p>第十三个设计模式<strong>Active Objects 设计模式</strong>。<font color = "purple">接受异步调用的主动方法。可以主动异步的执行一些任务。</font>详情参考：<code>Active Objects 设计模式</code></p>
</li>
<li>
<p>第十四个设计模式<strong>Count Down设计模式</strong>。<font color = "purple">多个子任务执行，主任务等待子任务全部执行完，再执行</font>详情参考：<code>Count Down设计模式</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>多线程的设计模式</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>观察者模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105835544">https://blog.csdn.net/qq_43040688/article/details/105835544</a></td>
</tr>
<tr>
<td>单例模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105798423">https://blog.csdn.net/qq_43040688/article/details/105798423</a></td>
</tr>
<tr>
<td>单线程执行设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105856901">https://blog.csdn.net/qq_43040688/article/details/105856901</a></td>
</tr>
<tr>
<td>不可变对象设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105865371">https://blog.csdn.net/qq_43040688/article/details/105865371</a></td>
</tr>
<tr>
<td>确保挂起设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105886681">https://blog.csdn.net/qq_43040688/article/details/105886681</a></td>
</tr>
<tr>
<td>Balking设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105890674">https://blog.csdn.net/qq_43040688/article/details/105890674</a></td>
</tr>
<tr>
<td>生产者-消费者设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105891561">https://blog.csdn.net/qq_43040688/article/details/105891561</a></td>
</tr>
<tr>
<td>读写锁的设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105857920">https://blog.csdn.net/qq_43040688/article/details/105857920</a></td>
</tr>
<tr>
<td>Thread-Per-Message</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892219">https://blog.csdn.net/qq_43040688/article/details/105892219</a></td>
</tr>
<tr>
<td>Worker 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105894685">https://blog.csdn.net/qq_43040688/article/details/105894685</a></td>
</tr>
<tr>
<td>Future设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105868293">https://blog.csdn.net/qq_43040688/article/details/105868293</a></td>
</tr>
<tr>
<td>两阶段终止设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892777">https://blog.csdn.net/qq_43040688/article/details/105892777</a></td>
</tr>
<tr>
<td>线程保险箱设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105887378">https://blog.csdn.net/qq_43040688/article/details/105887378</a></td>
</tr>
<tr>
<td>上下文设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105888242">https://blog.csdn.net/qq_43040688/article/details/105888242</a></td>
</tr>
<tr>
<td>Active Objects 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105895280">https://blog.csdn.net/qq_43040688/article/details/105895280</a></td>
</tr>
<tr>
<td>Count Down设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892054">https://blog.csdn.net/qq_43040688/article/details/105892054</a></td>
</tr>
</tbody>
</table>
<h4 id="java高并发与jvm的关系">Java高并发与JVM的关系</h4>
<blockquote>
<p>主要是学习<code>wait set</code>、<code>JMM模型</code></p>
</blockquote>
<p><strong>JMM模型中有四个内容</strong>，主要参看博客：<code>Java多线程之内存模型三大特性</code>。如果想学习更多，请学习JVM的部分。</p>
<ul>
<li><strong>解决高速缓存中数据不一致性的问题</strong>——总线锁（效率低）、高速缓存一致性协议，英特尔</li>
<li><strong>高并发的三个要求</strong>——原子性、可见性、有序性</li>
<li><strong>happens-before</strong></li>
<li><strong>指令重排序</strong></li>
</ul>
<p>Java多线程之内存模型三大特性：<a href="https://blog.csdn.net/qq_43040688/article/details/105823532">https://blog.csdn.net/qq_43040688/article/details/105823532</a></p>
<h4 id="原子包">原子包</h4>
<p><strong>CAS</strong>  ：</p>
<ul>
<li>乐观锁，CompareAndSwap。</li>
<li>优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。</li>
<li>缺点：在竞争激烈的情况下，浪费CUP资源。</li>
<li>还有一个问题是ABA问题，解决方法是：加一个版本号。</li>
<li>详情参考：<code>CAS</code></li>
</ul>
<p><strong>UnSafe类</strong></p>
<ul>
<li>内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式</li>
<li>获取Unsafe需要通过<code>反射</code>Unsafe类的属性</li>
<li>常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现</li>
<li>详情参考：<code>UnSafe类</code></li>
</ul>
<p><strong>AtomicInteger和AtomicBoolean</strong>：</p>
<ul>
<li>是保证原子性的对象。</li>
<li>利用的CAS</li>
<li>详情参考：<code>AtomicInteger</code>和<code>AtomicBoolean</code></li>
</ul>
<p><strong>AtomicReference</strong></p>
<ul>
<li>是一个利用CAS帮助对象保证原子性的</li>
<li>但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：<code>CAS</code></li>
<li>详情参考：<code>AtomicReference</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAS</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105914717">https://blog.csdn.net/qq_43040688/article/details/105914717</a></td>
</tr>
<tr>
<td>AtomicInteger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105908835">https://blog.csdn.net/qq_43040688/article/details/105908835</a></td>
</tr>
<tr>
<td>AtomicBoolean</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105917939">https://blog.csdn.net/qq_43040688/article/details/105917939</a></td>
</tr>
<tr>
<td>AtomicReference</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105918329">https://blog.csdn.net/qq_43040688/article/details/105918329</a></td>
</tr>
<tr>
<td>UnSafe类</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105923421">https://blog.csdn.net/qq_43040688/article/details/105923421</a></td>
</tr>
</tbody>
</table>
<h4 id="juc工具包">JUC工具包</h4>
<p><strong>CountDownLatch</strong></p>
<ul>
<li>通过一个计数器实现，计数器初始值就是线程的数量</li>
<li>每当一个线程完成任务，就会使计数减一</li>
<li>可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成</li>
<li>详情见：<code>CountDownLatch</code></li>
</ul>
<p><strong>CyclicBarrier</strong></p>
<ul>
<li>跟<code>CountDownLatch</code>的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点</li>
<li>详情见：<code>CyclicBarrier</code></li>
</ul>
<p><strong>Phaser</strong></p>
<ul>
<li>JDK1.7之后引用的，具有<code>CyclicBarrier</code>和<code>CountDownLatch</code></li>
<li>同时它的注册数是支持动态增加或减少（可以用于线程出现异常）</li>
<li>当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复</li>
<li>详情见：<code>Phaser</code></li>
</ul>
<p><strong>Exchanger</strong></p>
<ul>
<li>用于线程间交换数据</li>
<li>需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题</li>
<li>详情见：<code>Exchanger</code></li>
</ul>
<p><strong>Semaphore</strong></p>
<ul>
<li>是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问</li>
<li>详情见：<code>Semaphore</code></li>
</ul>
<p><strong>ReentrantLock</strong></p>
<ul>
<li>支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的</li>
<li>支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞</li>
<li>需要手动的释放锁，try...finally...</li>
<li>相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高</li>
<li>是一个Java类，具有更多的功能，同时可以自由的扩展</li>
<li>详情请见：<code>ReentrantLock</code></li>
</ul>
<p><strong>读写锁</strong></p>
<ul>
<li>将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能</li>
<li>是悲观锁，可能读的线程太多，写的线程迟迟难以执行</li>
<li>详情请见：<code>读写锁</code></li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li>解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁</li>
<li>思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据</li>
<li>详情请见：<code>StampedLock</code></li>
</ul>
<p><strong>三种锁的比较</strong></p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>StampedLock</th>
<th>Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>是JVM的的内置锁，每个JDK版本都会优化</td>
<td>是一个Java类，可以更好的扩展</td>
<td>是一个Java类，可以更好的扩展</td>
</tr>
<tr>
<td>都是悲观锁</td>
<td>提供了写的乐观锁</td>
<td>都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁</td>
</tr>
<tr>
<td>性能一般，因为有一个从用户态到内核态的过程</td>
<td>性能最好，可以代替读写锁</td>
<td>性能十分不稳定，在复杂的读写环境下，性能十分差</td>
</tr>
</tbody>
</table>
<ul>
<li>详情请见：<code>三种锁的比较</code></li>
</ul>
<p><strong>ForkJoin</strong></p>
<ul>
<li>基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行</li>
<li>分为Fork和Join两个阶段，充分利用CPU资源</li>
<li>详情请见：<code>ForkJoin</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountDownLatch</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105935307">https://blog.csdn.net/qq_43040688/article/details/105935307</a></td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105937169">https://blog.csdn.net/qq_43040688/article/details/105937169</a></td>
</tr>
<tr>
<td>Phaser</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106033183">https://blog.csdn.net/qq_43040688/article/details/106033183</a></td>
</tr>
<tr>
<td>Exchanger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105955788">https://blog.csdn.net/qq_43040688/article/details/105955788</a></td>
</tr>
<tr>
<td>Semaphore</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105956731">https://blog.csdn.net/qq_43040688/article/details/105956731</a></td>
</tr>
<tr>
<td>ReentrantLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105958719">https://blog.csdn.net/qq_43040688/article/details/105958719</a></td>
</tr>
<tr>
<td>读写锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105975257">https://blog.csdn.net/qq_43040688/article/details/105975257</a></td>
</tr>
<tr>
<td>StampedLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106026847">https://blog.csdn.net/qq_43040688/article/details/106026847</a></td>
</tr>
<tr>
<td>三种锁的比较</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032189">https://blog.csdn.net/qq_43040688/article/details/106032189</a></td>
</tr>
<tr>
<td>ForkJoin</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032309">https://blog.csdn.net/qq_43040688/article/details/106032309</a></td>
</tr>
</tbody>
</table>
<h4 id="exectors框架">Exectors框架</h4>
<blockquote>
<p>首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。</p>
</blockquote>
<p><strong>ThreadPoolExecutor</strong></p>
<ul>
<li>创建线程池有七大参数，<code>特别重要</code></li>
<li>有四种拒绝策略</li>
<li>四种阻塞队列</li>
<li>一些调试的API</li>
<li>关闭线程池的注意事项</li>
<li>详情请见：<code>ThreadPoolExecutor</code></li>
</ul>
<p><strong>Executors</strong><br>
用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：</p>
<ul>
<li>newCachedThreadPool</li>
<li>newFixedThreadPool</li>
<li>newScheduledThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newWorkStealingPool</li>
<li>详情请见：<code>Executors</code></li>
</ul>
<p><strong>CompletionService</strong></p>
<ul>
<li>用来增强线程池，主要思想是：<code>执行一批任务，先执行的，先获取结果</code></li>
<li>实现的子类是：<code>ExecutorCompletionService</code></li>
<li>详情请见：<code>CompletionService</code></li>
</ul>
<p><strong>CompleableFuture</strong></p>
<ul>
<li>可以进行串联的操作，即利用上一个任务的结果，执行下一个任务</li>
<li>进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果</li>
<li>可以不需要调用者主动获取结果，而进行回调</li>
<li>执行一批任务时，获取的Future是按照任务完成的顺序</li>
<li>创建CompleableFuture有多种方式，最多的是<code>runAsync</code>和<code>supplyAsync</code></li>
<li>API分为组合方法、中转方法和终结方法</li>
<li>详情请见：<code>CompleableFuture</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolExecutor</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106041236">https://blog.csdn.net/qq_43040688/article/details/106041236</a></td>
</tr>
<tr>
<td>Executors</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106046629">https://blog.csdn.net/qq_43040688/article/details/106046629</a></td>
</tr>
<tr>
<td>CompletionService</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106058225">https://blog.csdn.net/qq_43040688/article/details/106058225</a></td>
</tr>
<tr>
<td>CompleableFuture</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106061776">https://blog.csdn.net/qq_43040688/article/details/106061776</a></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMQ监控平台（附网盘链接）]]></title>
        <id>https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/</id>
        <link href="https://xzzz2020.github.io/post/rocketmq-jian-kong-ping-tai-fu-wang-pan-lian-jie/">
        </link>
        <updated>2020-06-16T12:01:12.000Z</updated>
        <content type="html"><![CDATA[<p><code>RocketMQ</code>有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，先将<a href="https://github.com/apache/rocketmq-externals">incubator-rocketmq-externals</a>拉到本地，因为我们需要自己对<code>rocketmq-console</code>进行编译打包运行。</p>
<p>在linux环境下，使用<code>nohub java -jar xxxx &amp;</code>  启动，为了防止端口冲突，已经修改其端口为<strong>9999</strong></p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA">https://pan.baidu.com/s/1_z8UOFyPwOQKIa_VAl5nTA</a><br>
提取码：jpg0</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020053110115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQwNjg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="352-下载并编译打包">3.5.2 下载并编译打包</h3>
<pre><code class="language-sh">git clone https://github.com/apache/rocketmq-externals
cd rocketmq-console
mvn clean package -Dmaven.test.skip=true
</code></pre>
<p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：</p>
<pre><code class="language-sh">rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876
</code></pre>
<p>启动rocketmq-console：</p>
<pre><code class="language-sh">java -jar rocketmq-console-ng-1.0.0.jar
</code></pre>
<p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200531101225351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQwNjg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
</feed>