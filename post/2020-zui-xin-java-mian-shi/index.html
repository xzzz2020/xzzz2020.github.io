<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="https://xzzz2020.github.io/favicon.ico" type="image/x-icon" /><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"><meta name="description"content="温故而知新"><meta charset="UTF-8"><title>2020最新-Java面试 | xzzz2020</title>
<link href="https://xzzz2020.github.io/styles/main.css" type="text/css" rel="stylesheet" /><link href="https://at.alicdn.com/t/font_1621793_zatzzgvf30g.css" type="text/css" rel="stylesheet" /><link rel="stylesheet" href="https://xzzz2020.github.io/media/css/katex.css"><script async src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.min.js"></script><script src="https://xzzz2020.github.io/media/js/magnify.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script type="text/javascript">function btn_toggle(){document.getElementById("hn").classList.contains("no-js")?document.getElementById("hn").classList.remove("no-js"):document.getElementById("hn").classList.add("no-js")}</script>

<link rel="canonical" href="https://xzzz2020.github.io/post/2020-zui-xin-java-mian-shi/" />
</head>
<body>
<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://xzzz2020.github.io"><img alt="logo" style="display:inline-block;" src="https://xzzz2020.github.io/images/avatar.png"/></a><h1 title="xzzz2020" class="weaklink"><a  href="/">xzzz2020</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/Friendship_chain" class="selected active current nav__item" >友链</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div><div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/Friendship_chain" class="selected active current nav__item" >友链</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form" data-update="1592991099098" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

<div class="main"><div class="main-inner"><div class="content">
<article class="post">
<h2 class="post_title sm_margin"><a>2020最新-Java面试</a></h2>
<script>function lan(){if(document.getElementById("lan").innerText=="繁"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="简"}else{if(document.getElementById("lan").innerText=="簡"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="繁"}}};</script>
<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px"> 2020-06-18</span><i class="iconfont icon-browse"></i><span style="margin-right:15px"> <span id="busuanzi_value_page_pv"></span> Views</span><i class="iconfont icon-category"></i><span class="weaklink" style="margin-right:15px">	<a href="https://xzzz2020.github.io/tag/WEcmHbovN/" class="tag">个人经验</a></span><i class="iconfont icon-caret-down"></i><span style="margin-right:15px">3865字</span><i class="iconfont icon-naozhong"></i><span style="margin-right:15px">16 min read</span><a id="lan" href="javascript:void(0);"onclick="lan();"title="调整简繁体" style="margin-right:15px;">繁</a>
<font color=7D26CD>置顶</font></section>

<img class="featureImg" alt="featureimg" src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/photo-1592736158789-303583e8db16.webp" referrerpolicy="no-referrer">

<div style="display:flex">
<div class="md_block" id="md_block">
<div class="round-shape-one"></div>
<blockquote>
<p>学习的知识体系图片太大，直接奉上链接，可以自己保存到电脑上：<a href="https://blog.csdn.net/qq_43040688/article/details/105819866">https://blog.csdn.net/qq_43040688/article/details/105819866</a></p>
</blockquote>
<p>这些全部都是博主学习时记录的一些笔记，手上也有学习时使用的相关的网课资源或者是课本资源，感觉讲的都很不错，资料也很全。</p>
<br>
<br>
<br>
<br>
<br>
<h2 id="一-数据库">一. 数据库</h2>
<h3 id="11-关系型数据库">1.1 关系型数据库</h3>
<h4 id="mysql已更新">MySQL(已更新)</h4>
<p>推荐书目：《MySQL必知必会》、《MySQL技术内幕》、《高性能MySQL》<br>
<code>对于MySQL语法优先学习SQL的语句增删改查等，然后在LeetCode练习一下数据库的题目，可能会手写SQL语句</code></p>
<table>
<thead>
<tr>
<th>SQL语句学习</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105346357">https://blog.csdn.net/qq_43040688/article/details/105346357</a></td>
</tr>
<tr>
<td>重点部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105348610">https://blog.csdn.net/qq_43040688/article/details/105348610</a></td>
</tr>
<tr>
<td>扩展部分</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105381801">https://blog.csdn.net/qq_43040688/article/details/105381801</a></td>
</tr>
</tbody>
</table>
<p><code>接着需要重点学习索引、锁、事务、SQL优化以及MySQL的架构</code></p>
<table>
<thead>
<tr>
<th>SQL高级部分</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL体系结构和存储引擎介绍</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105393816">https://blog.csdn.net/qq_43040688/article/details/105393816</a></td>
</tr>
<tr>
<td>InnoDB存储引擎</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105415093">https://blog.csdn.net/qq_43040688/article/details/105415093</a></td>
</tr>
<tr>
<td>MySQL 索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105419053">https://blog.csdn.net/qq_43040688/article/details/105419053</a></td>
</tr>
<tr>
<td>MySQL创建高性能的索引</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105454477">https://blog.csdn.net/qq_43040688/article/details/105454477</a></td>
</tr>
<tr>
<td>MySQL查询性能优化</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105456790">https://blog.csdn.net/qq_43040688/article/details/105456790</a></td>
</tr>
<tr>
<td>MySQL锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105440448">https://blog.csdn.net/qq_43040688/article/details/105440448</a></td>
</tr>
<tr>
<td>MySQL事务</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441274">https://blog.csdn.net/qq_43040688/article/details/105441274</a></td>
</tr>
<tr>
<td>MySQL备份</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105441944">https://blog.csdn.net/qq_43040688/article/details/105441944</a></td>
</tr>
<tr>
<td>MySQL架构</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105450005">https://blog.csdn.net/qq_43040688/article/details/105450005</a></td>
</tr>
<tr>
<td>MySQL高级特性</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105465192">https://blog.csdn.net/qq_43040688/article/details/105465192</a></td>
</tr>
<tr>
<td>分库分表的高频面试题</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105594653">https://blog.csdn.net/qq_43040688/article/details/105594653</a></td>
</tr>
</tbody>
</table>
<h3 id="12-非关系型数据库">1.2 非关系型数据库</h3>
<h4 id="redis">Redis</h4>
<h2 id="二-java基础">二、Java基础</h2>
<h3 id="21-java虚拟机已更新">2.1 Java虚拟机（已更新）</h3>
<p>虛拟机推荐 <strong>《深入理解Java虚拟机》</strong> 这本书，重点学习一下<code>内存</code>、<code>垃圾回收</code>、<code>类加载机制</code>这几部分内容。</p>
<table>
<thead>
<tr>
<th>JVM内存结构</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>JVM简介</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104964070">https://blog.csdn.net/qq_43040688/article/details/104964070</a></td>
</tr>
<tr>
<td>程序计数器和虚拟机栈</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104970081">https://blog.csdn.net/qq_43040688/article/details/104970081</a></td>
</tr>
<tr>
<td>本地方法栈和堆</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104972811">https://blog.csdn.net/qq_43040688/article/details/104972811</a></td>
</tr>
<tr>
<td>方法区</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104982648">https://blog.csdn.net/qq_43040688/article/details/104982648</a></td>
</tr>
<tr>
<td>直接内存</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/104996032">https://blog.csdn.net/qq_43040688/article/details/104996032</a></td>
</tr>
</tbody>
</table>
<h3 id="22-java并发已更新">2.2 Java并发（已更新）</h3>
<blockquote>
<p>Java并发主要看了汪文君的并发三个阶段，内容比较丰富，看了很久</p>
</blockquote>
<h4 id="java并发基础">Java并发基础</h4>
<blockquote>
<p>学习Java并发，需要先掌握线程的一些基础知识<br>
这些基础知识的组合构成了后面的设计模式</p>
</blockquote>
<ul>
<li>首先应该了解如何启动一个多线程，即<strong>使用Runnable、Callable、Thread</strong>；还需要了解线程启动后的<strong>生命周期</strong>，<strong>了解了不用实现方式的差别</strong>，最重要的<strong>研读Thread的源码</strong>，详情参考：<code>Java多线程起步</code>，<code>Thread构造函数源码分析</code></li>
<li>需要学习<strong>Thread常用API</strong>以及<strong>三种关闭线程的方式</strong>，详情参考：<code>Thread的API</code></li>
<li>需要了解<strong>this锁</strong>和<strong>class锁</strong>，详情参考：<code>Java多线程之认识“锁”</code></li>
<li>需要了解<strong>线程间的通讯</strong>，最基本的就是消费者和生产者模型，需要深入了解了<strong>wait、sleep、notify、nitifyAll</strong>的机制和差异，对于<strong>wait set</strong>要有个清晰的认识，详情参考：<code>Java多线程之线程间的通讯</code></li>
<li>需要尝试自定义了一个<strong>Boolean锁</strong>，了解了<strong>加锁和释放锁的过程</strong>，实现了获取正在阻塞的线程；需要了解<strong>线程运行时出现异常的处理方式</strong><br>
，详情参考：<code>自定义Boolean锁&amp;捕获线程中的异常</code></li>
<li>需要学习了<strong>线程组的概念以及常用API</strong>，如interrupt，setDaemon，activeCount，enumerate， 详情参考：<code>线程组</code></li>
<li>需要<strong>自定义了一个线程池</strong>，对线程池的处理机制有了较深的理解，详情参考：<code>自定义线程池</code></li>
</ul>
<table>
<thead>
<tr>
<th>Java并发基础</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java多线程起步</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/103979628">https://blog.csdn.net/qq_43040688/article/details/103979628</a></td>
</tr>
<tr>
<td>Thread构造函数源码分析</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105543926">https://blog.csdn.net/qq_43040688/article/details/105543926</a></td>
</tr>
<tr>
<td>Thread的API</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105747547">https://blog.csdn.net/qq_43040688/article/details/105747547</a></td>
</tr>
<tr>
<td>Java多线程之认识“锁”</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105752943">https://blog.csdn.net/qq_43040688/article/details/105752943</a></td>
</tr>
<tr>
<td>Java多线程之线程间的通讯</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105754406">https://blog.csdn.net/qq_43040688/article/details/105754406</a></td>
</tr>
<tr>
<td>自定义Boolean锁&amp;捕获线程中的异常</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105771445">https://blog.csdn.net/qq_43040688/article/details/105771445</a></td>
</tr>
<tr>
<td>线程组</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105774614">https://blog.csdn.net/qq_43040688/article/details/105774614</a></td>
</tr>
<tr>
<td>自定义线程池</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105786243">https://blog.csdn.net/qq_43040688/article/details/105786243</a></td>
</tr>
</tbody>
</table>
<h4 id="多线程的设计模式">多线程的设计模式</h4>
<blockquote>
<p>Java在并发的场景中，设计模式就像个套路，开发者可以自由的组合<font color = "red">以满足应用需求</font><br>
<strong>下面有十四个多线程的设计模式，帮助理解后面的JUC包。</strong></p>
</blockquote>
<ul>
<li>
<p>第一个设计模式是：<strong>观察者模式</strong>。需要定义一个<strong>主题</strong>，一个<strong>观察者</strong>。<font color = "purple">主题在多线程情况下，可以实现Runnable接口，传递给线程；线程在执行的过程中，可能会修改主题的状态；主题状态发生变化，会通知观察者，执行观察者的onChange方法。</font>详情参考：<code>观察者模式</code></p>
</li>
<li>
<p>第二个设计模式是：<strong>单例模式</strong>。解决方式有三种：<font color = "purple">第一种是double check方式，但是可能会引起空指针异常；第二种是holder方式，利用内部static 类实现；第三种是利用enum类实现。</font>详情参考：<code>单例模式</code></p>
</li>
<li>
<p>第三个设计模式是<strong>单线程执行模式</strong>。<font color = "purple">就是在同一时刻只能有一个对共享资源进行操作。</font>详情参考：<code>单线程执行设计模式</code></p>
</li>
<li>
<p>第四个设计模式<strong>不可变对象设计模式</strong>。<font color = "purple">是一种无锁的设计模式，其思想是如果共享资源是不可以修改的，则线程一定安全。</font>详情参考：<code>不可变对象设计模式</code></p>
</li>
<li>
<p>第五个设计模式<strong>确保挂起设计模式</strong>。<font color = "purple">当线程在工作时，如果来了其他任务，将任务放入到队列中等待。</font>详情参考：<code>确保挂起设计模式</code></p>
</li>
<li>
<p>第六个设计模式<strong>Balking设计模式</strong>。<font color = "purple">当工作已经执行过了，就直接return，防止重复的工作，提高效率。</font>详情参考：<code>Balking设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>生产者-消费者设计模式</strong>。<font color = "purple">如果生产一个产品，放到吧台上，通知消费者；如果吧台上有产品，消费者就会立即执行。</font>详情参考：<code>生产者-消费者设计模式</code></p>
</li>
<li>
<p>第七个设计模式<strong>读写锁的设计模式</strong>。<font color = "purple">读取操作与读取操作之间不存在线程安全的问题，所以在此情况下，避免加锁，影响性能</font>。详情参考：<code>读写锁的设计模式</code></p>
</li>
<li>
<p>第八个设计模式<strong>Thread-Per-Message</strong>。<font color = "purple">每一个请求都创建一个线程服务，为了提高性能，可以使用线程池。</font>详情参考：<code>Thread-Per-Message</code></p>
</li>
<li>
<p>第九个设计模式 <strong>Worker 设计模式</strong>。<font color = "purple">需要一个Master，负责创建worker、启动worker、监控worker以及接受任务。</font><br>
详情参考：<code>Worker 设计模式</code></p>
</li>
<li>
<p>第十个设计模式<strong>Future设计模式</strong>。<font color = "purple">通过返回一个票据，避免陷入阻塞；当任务完成后，可以调用票据的get方法获取结果。</font>详情参考：<code>Future设计模式</code></p>
</li>
<li>
<p>第十一个设计模式<strong>两阶段终止设计模式</strong>。<font color = "purple">当线程关闭时，不会立马关闭，而是先执行第二阶段的资源释放任务。利用的try...finally...。</font>详情参考：<code>两阶段终止设计模式</code></p>
</li>
<li>
<p>第十二个设计模式<strong>线程保险箱设计模式</strong>。<font color = "purple">利用Map，线程是key，数据是value。可以保证线程间的数据是安全的。需要注意：线程池下，需要清空原来的数据。</font >详情参考：<code>线程保险箱设计模式</code>和<code>上下文设计模式</code></p>
</li>
<li>
<p>第十三个设计模式<strong>Active Objects 设计模式</strong>。<font color = "purple">接受异步调用的主动方法。可以主动异步的执行一些任务。</font>详情参考：<code>Active Objects 设计模式</code></p>
</li>
<li>
<p>第十四个设计模式<strong>Count Down设计模式</strong>。<font color = "purple">多个子任务执行，主任务等待子任务全部执行完，再执行</font>详情参考：<code>Count Down设计模式</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>多线程的设计模式</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>观察者模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105835544">https://blog.csdn.net/qq_43040688/article/details/105835544</a></td>
</tr>
<tr>
<td>单例模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105798423">https://blog.csdn.net/qq_43040688/article/details/105798423</a></td>
</tr>
<tr>
<td>单线程执行设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105856901">https://blog.csdn.net/qq_43040688/article/details/105856901</a></td>
</tr>
<tr>
<td>不可变对象设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105865371">https://blog.csdn.net/qq_43040688/article/details/105865371</a></td>
</tr>
<tr>
<td>确保挂起设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105886681">https://blog.csdn.net/qq_43040688/article/details/105886681</a></td>
</tr>
<tr>
<td>Balking设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105890674">https://blog.csdn.net/qq_43040688/article/details/105890674</a></td>
</tr>
<tr>
<td>生产者-消费者设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105891561">https://blog.csdn.net/qq_43040688/article/details/105891561</a></td>
</tr>
<tr>
<td>读写锁的设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105857920">https://blog.csdn.net/qq_43040688/article/details/105857920</a></td>
</tr>
<tr>
<td>Thread-Per-Message</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892219">https://blog.csdn.net/qq_43040688/article/details/105892219</a></td>
</tr>
<tr>
<td>Worker 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105894685">https://blog.csdn.net/qq_43040688/article/details/105894685</a></td>
</tr>
<tr>
<td>Future设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105868293">https://blog.csdn.net/qq_43040688/article/details/105868293</a></td>
</tr>
<tr>
<td>两阶段终止设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892777">https://blog.csdn.net/qq_43040688/article/details/105892777</a></td>
</tr>
<tr>
<td>线程保险箱设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105887378">https://blog.csdn.net/qq_43040688/article/details/105887378</a></td>
</tr>
<tr>
<td>上下文设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105888242">https://blog.csdn.net/qq_43040688/article/details/105888242</a></td>
</tr>
<tr>
<td>Active Objects 设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105895280">https://blog.csdn.net/qq_43040688/article/details/105895280</a></td>
</tr>
<tr>
<td>Count Down设计模式</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105892054">https://blog.csdn.net/qq_43040688/article/details/105892054</a></td>
</tr>
</tbody>
</table>
<h4 id="java高并发与jvm的关系">Java高并发与JVM的关系</h4>
<blockquote>
<p>主要是学习<code>wait set</code>、<code>JMM模型</code></p>
</blockquote>
<p><strong>JMM模型中有四个内容</strong>，主要参看博客：<code>Java多线程之内存模型三大特性</code>。如果想学习更多，请学习JVM的部分。</p>
<ul>
<li><strong>解决高速缓存中数据不一致性的问题</strong>——总线锁（效率低）、高速缓存一致性协议，英特尔</li>
<li><strong>高并发的三个要求</strong>——原子性、可见性、有序性</li>
<li><strong>happens-before</strong></li>
<li><strong>指令重排序</strong></li>
</ul>
<p>Java多线程之内存模型三大特性：<a href="https://blog.csdn.net/qq_43040688/article/details/105823532">https://blog.csdn.net/qq_43040688/article/details/105823532</a></p>
<h4 id="原子包">原子包</h4>
<p><strong>CAS</strong>  ：</p>
<ul>
<li>乐观锁，CompareAndSwap。</li>
<li>优点是：保证变量的原子性；避免从用户态到内核态，可以提高性能确定。</li>
<li>缺点：在竞争激烈的情况下，浪费CUP资源。</li>
<li>还有一个问题是ABA问题，解决方法是：加一个版本号。</li>
<li>详情参考：<code>CAS</code></li>
</ul>
<p><strong>UnSafe类</strong></p>
<ul>
<li>内部有很多native方法，是执行的是C++的代码，给了Java操作内存的方式</li>
<li>获取Unsafe需要通过<code>反射</code>Unsafe类的属性</li>
<li>常用的功能：CAS、加载类（可以不运行构造方法）、能直接操作内存、内置锁的实现</li>
<li>详情参考：<code>UnSafe类</code></li>
</ul>
<p><strong>AtomicInteger和AtomicBoolean</strong>：</p>
<ul>
<li>是保证原子性的对象。</li>
<li>利用的CAS</li>
<li>详情参考：<code>AtomicInteger</code>和<code>AtomicBoolean</code></li>
</ul>
<p><strong>AtomicReference</strong></p>
<ul>
<li>是一个利用CAS帮助对象保证原子性的</li>
<li>但是存在ABA问题，解决该问题的是：AtomicStampedReference，详情参考：<code>CAS</code></li>
<li>详情参考：<code>AtomicReference</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAS</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105914717">https://blog.csdn.net/qq_43040688/article/details/105914717</a></td>
</tr>
<tr>
<td>AtomicInteger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105908835">https://blog.csdn.net/qq_43040688/article/details/105908835</a></td>
</tr>
<tr>
<td>AtomicBoolean</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105917939">https://blog.csdn.net/qq_43040688/article/details/105917939</a></td>
</tr>
<tr>
<td>AtomicReference</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105918329">https://blog.csdn.net/qq_43040688/article/details/105918329</a></td>
</tr>
<tr>
<td>UnSafe类</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105923421">https://blog.csdn.net/qq_43040688/article/details/105923421</a></td>
</tr>
</tbody>
</table>
<h4 id="juc工具包">JUC工具包</h4>
<p><strong>CountDownLatch</strong></p>
<ul>
<li>通过一个计数器实现，计数器初始值就是线程的数量</li>
<li>每当一个线程完成任务，就会使计数减一</li>
<li>可以在多线程环境使用，使多个线程阻塞，等待上一阶段任务的全部完成</li>
<li>详情见：<code>CountDownLatch</code></li>
</ul>
<p><strong>CyclicBarrier</strong></p>
<ul>
<li>跟<code>CountDownLatch</code>的区别是：完成任务后需要等待其他线程完成任务，同时是一个可重用点</li>
<li>详情见：<code>CyclicBarrier</code></li>
</ul>
<p><strong>Phaser</strong></p>
<ul>
<li>JDK1.7之后引用的，具有<code>CyclicBarrier</code>和<code>CountDownLatch</code></li>
<li>同时它的注册数是支持动态增加或减少（可以用于线程出现异常）</li>
<li>当它在一个阶段所有任务完成时，会进入下一阶段，同时计数器重新恢复</li>
<li>详情见：<code>Phaser</code></li>
</ul>
<p><strong>Exchanger</strong></p>
<ul>
<li>用于线程间交换数据</li>
<li>需要注意一点：交换的数据对象是一个引用，而不是拷贝，需要考虑线程安全问题</li>
<li>详情见：<code>Exchanger</code></li>
</ul>
<p><strong>Semaphore</strong></p>
<ul>
<li>是一个对共享资源管理的设施，通过对信号量的控制，可以让资源被多个线程访问</li>
<li>详情见：<code>Semaphore</code></li>
</ul>
<p><strong>ReentrantLock</strong></p>
<ul>
<li>支持公平锁，即尽可能的保证线程之间获取时间片的次数的相同的</li>
<li>支持tryLock机制，尝试获取锁，如果没有获取到，不会阻塞</li>
<li>需要手动的释放锁，try...finally...</li>
<li>相较内置锁而言，是基于AQS实现的，不需要一个从用户态到内核态的过程，性能更高</li>
<li>是一个Java类，具有更多的功能，同时可以自由的扩展</li>
<li>详情请见：<code>ReentrantLock</code></li>
</ul>
<p><strong>读写锁</strong></p>
<ul>
<li>将读和写分为两个锁，可以有效解决读-读之间的冲突问题，大幅提高性能</li>
<li>是悲观锁，可能读的线程太多，写的线程迟迟难以执行</li>
<li>详情请见：<code>读写锁</code></li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li>解决读写锁中，写的线程迟迟难以执行的过程，是一个乐观锁</li>
<li>思路是：获得一个乐观的读锁，先读取数据；在返回数据时，检测数据是否有被写入，如果有，则获取一个悲观读锁，重新读取数据</li>
<li>详情请见：<code>StampedLock</code></li>
</ul>
<p><strong>三种锁的比较</strong></p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>StampedLock</th>
<th>Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>是JVM的的内置锁，每个JDK版本都会优化</td>
<td>是一个Java类，可以更好的扩展</td>
<td>是一个Java类，可以更好的扩展</td>
</tr>
<tr>
<td>都是悲观锁</td>
<td>提供了写的乐观锁</td>
<td>都是悲观锁，但是提供了自旋锁，或者不阻塞的获取锁</td>
</tr>
<tr>
<td>性能一般，因为有一个从用户态到内核态的过程</td>
<td>性能最好，可以代替读写锁</td>
<td>性能十分不稳定，在复杂的读写环境下，性能十分差</td>
</tr>
</tbody>
</table>
<ul>
<li>详情请见：<code>三种锁的比较</code></li>
</ul>
<p><strong>ForkJoin</strong></p>
<ul>
<li>基本思想是：如果当前线程执行任务速度比较慢，则将此任务拆分，交给子线程执行</li>
<li>分为Fork和Join两个阶段，充分利用CPU资源</li>
<li>详情请见：<code>ForkJoin</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountDownLatch</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105935307">https://blog.csdn.net/qq_43040688/article/details/105935307</a></td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105937169">https://blog.csdn.net/qq_43040688/article/details/105937169</a></td>
</tr>
<tr>
<td>Phaser</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106033183">https://blog.csdn.net/qq_43040688/article/details/106033183</a></td>
</tr>
<tr>
<td>Exchanger</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105955788">https://blog.csdn.net/qq_43040688/article/details/105955788</a></td>
</tr>
<tr>
<td>Semaphore</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105956731">https://blog.csdn.net/qq_43040688/article/details/105956731</a></td>
</tr>
<tr>
<td>ReentrantLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105958719">https://blog.csdn.net/qq_43040688/article/details/105958719</a></td>
</tr>
<tr>
<td>读写锁</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/105975257">https://blog.csdn.net/qq_43040688/article/details/105975257</a></td>
</tr>
<tr>
<td>StampedLock</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106026847">https://blog.csdn.net/qq_43040688/article/details/106026847</a></td>
</tr>
<tr>
<td>三种锁的比较</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032189">https://blog.csdn.net/qq_43040688/article/details/106032189</a></td>
</tr>
<tr>
<td>ForkJoin</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106032309">https://blog.csdn.net/qq_43040688/article/details/106032309</a></td>
</tr>
</tbody>
</table>
<h4 id="exectors框架">Exectors框架</h4>
<blockquote>
<p>首先需要学习线程池的构造方法中参数的意义，如果可以尽量不要使用工厂方法创建线程池。</p>
</blockquote>
<p><strong>ThreadPoolExecutor</strong></p>
<ul>
<li>创建线程池有七大参数，<code>特别重要</code></li>
<li>有四种拒绝策略</li>
<li>四种阻塞队列</li>
<li>一些调试的API</li>
<li>关闭线程池的注意事项</li>
<li>详情请见：<code>ThreadPoolExecutor</code></li>
</ul>
<p><strong>Executors</strong><br>
用来创建线程池，可以创建5种线程池，需要对这些线程池特性很熟悉：</p>
<ul>
<li>newCachedThreadPool</li>
<li>newFixedThreadPool</li>
<li>newScheduledThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newWorkStealingPool</li>
<li>详情请见：<code>Executors</code></li>
</ul>
<p><strong>CompletionService</strong></p>
<ul>
<li>用来增强线程池，主要思想是：<code>执行一批任务，先执行的，先获取结果</code></li>
<li>实现的子类是：<code>ExecutorCompletionService</code></li>
<li>详情请见：<code>CompletionService</code></li>
</ul>
<p><strong>CompleableFuture</strong></p>
<ul>
<li>可以进行串联的操作，即利用上一个任务的结果，执行下一个任务</li>
<li>进行并联的操作，即多个线程执行不同任务，最先执行完成的任务结果将作为这一批任务的结果</li>
<li>可以不需要调用者主动获取结果，而进行回调</li>
<li>执行一批任务时，获取的Future是按照任务完成的顺序</li>
<li>创建CompleableFuture有多种方式，最多的是<code>runAsync</code>和<code>supplyAsync</code></li>
<li>API分为组合方法、中转方法和终结方法</li>
<li>详情请见：<code>CompleableFuture</code></li>
</ul>
<table>
<thead>
<tr>
<th>文章名称</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolExecutor</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106041236">https://blog.csdn.net/qq_43040688/article/details/106041236</a></td>
</tr>
<tr>
<td>Executors</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106046629">https://blog.csdn.net/qq_43040688/article/details/106046629</a></td>
</tr>
<tr>
<td>CompletionService</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106058225">https://blog.csdn.net/qq_43040688/article/details/106058225</a></td>
</tr>
<tr>
<td>CompleableFuture</td>
<td><a href="https://blog.csdn.net/qq_43040688/article/details/106061776">https://blog.csdn.net/qq_43040688/article/details/106061776</a></td>
</tr>
</tbody>
</table>

<span id="footnote"></span>
<div id = "warn"></div>
</div>
<div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93">一. 数据库</a>
<ul>
<li><a href="#11-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">1.1 关系型数据库</a>
<ul>
<li><a href="#mysql%E5%B7%B2%E6%9B%B4%E6%96%B0">MySQL(已更新)</a></li>
</ul>
</li>
<li><a href="#12-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">1.2 非关系型数据库</a>
<ul>
<li><a href="#redis">Redis</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-java%E5%9F%BA%E7%A1%80">二、Java基础</a>
<ul>
<li><a href="#21-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%B2%E6%9B%B4%E6%96%B0">2.1 Java虚拟机（已更新）</a></li>
<li><a href="#22-java%E5%B9%B6%E5%8F%91%E5%B7%B2%E6%9B%B4%E6%96%B0">2.2 Java并发（已更新）</a>
<ul>
<li><a href="#java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80">Java并发基础</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">多线程的设计模式</a></li>
<li><a href="#java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8Ejvm%E7%9A%84%E5%85%B3%E7%B3%BB">Java高并发与JVM的关系</a></li>
<li><a href="#%E5%8E%9F%E5%AD%90%E5%8C%85">原子包</a></li>
<li><a href="#juc%E5%B7%A5%E5%85%B7%E5%8C%85">JUC工具包</a></li>
<li><a href="#exectors%E6%A1%86%E6%9E%B6">Exectors框架</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="fullPage"><canvas id="canvas"></canvas></div>
</article>
<div id="eof"><span>EOF</span></div><div class="round-shape-one"></div>
<section>
<div class="doc_comments">

	  
		<div id="gitalk-container"></div>
		<!--评论显示区，请插入合适的位置-->
<div id="comment"></div>
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.6.1/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<script>
    new Valine({
        el:'#comment',
        appId: 'DysN4QrSvmmE6SpDXopbCLD6-gzGzoHsz',
        appKey: 'mjK643yLFa4WWXtobofr24Ap',
        placeholder: 'ヾﾉ≧∀≦)o快来评论一下吧!',
        avatar:''
    });
</script>
	  
		  
	  

</div></section>
</div></div></div><script>
"use strict";!function(){for(var n=document.getElementsByTagName("pre"),e=n.length,s=0;s<e;s++){n[s].innerHTML='<span class="line-number"></span>'+n[s].innerHTML+'<span class="cl"></span>';for(var a=n[s].innerHTML.split(/\n/).length,r=0;r<a-1;r++){n[s].getElementsByTagName("span")[0].innerHTML+="<span>"+(r+1)+"</span>"}}}();
let mainNavLinks=document.querySelectorAll(".markdownIt-TOC a");window.addEventListener("scroll",event=>{let fromTop=window.scrollY;mainNavLinks.forEach((link,index)=>{let section=document.getElementById(decodeURI(link.hash).substring(1));let nextSection=null
if(mainNavLinks[index+1]){nextSection=document.getElementById(decodeURI(mainNavLinks[index+1].hash).substring(1));}
if(section.offsetTop<=fromTop){if(nextSection){if(nextSection.offsetTop>fromTop){link.classList.add("currentToc");}else{link.classList.remove("currentToc");}}else{link.classList.add("currentToc");}}else{link.classList.remove("currentToc");}});});
var list=document.querySelectorAll(".katex");for(var i=0;i<list.length;i++){list[i].style.display="unset"};
var h=document.documentElement,b=document.body,st="scrollTop",sh="scrollHeight",progress=document.querySelector(".progress"),scroll;document.addEventListener("scroll",function(){scroll=(h[st]||b[st])/((h[sh]||b[sh])-h.clientHeight)*100;progress.style.setProperty("--scroll",scroll+"%")});
var wxScale=new WxScale({fullPage:document.querySelector("#fullPage"),canvas:document.querySelector("#canvas")});var imgBox=document.querySelectorAll("#md_block img");for(var i=0;i<imgBox.length;i++){imgBox[i].onclick=function(e){wxScale.start(this)}};
content="本文最后更新于2020-06-18，已超过 1 年没有更新，涉及的内容可能已经失效！";var date1="2020-06-18 20:29:23";date1=date1.replace("-","/");var date2=new Date();var date3=date2.getTime()-new Date(date1).getTime();var days=Math.floor(date3/(24*3600*1000));if(days>=365){document.getElementById("warn").innerHTML=content};
</script>
<style>#magnifyImg{position:fixed;left:0;top:0;text-align:center;width:100%;display:none;z-index:9999}#magnifyImg img{object-fit:contain;background:#eaecef;padding:15px;border-radius:10px;height:auto;width:auto;vertical-align:middle}</style>
<a id="scrollUp" href="#top" style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"></div></div><div class="copyright"id="copyright">Copyright © 2018-2020 <a href="https://xzzz2020.github.io" style="margin:0;">xzzz2020</a>.</div>
<span style="display: inline;margin-right:15px;">👁<strong><span id="busuanzi_value_site_uv"></span></strong></span><span id="busuanzi_container_page_pv" style="display: inline;"><span>📚<strong>12</strong> posts</span></div></div>
<script>
console.log("\n %c \u26a1Theme: Bitcron-pro Author's Blog:https://blog.blinkstar.cn  Writen By Serence  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;", );
</script>
<script src="https://cdn.jsdelivr.net/npm/instant.page@3.0.0/instantpage.min.js" type="module" defer></script>
<script type="text/javascript" async src="https://xzzz2020.github.io/media/js/prism.js"></script>
</body>
</html>