<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="https://xzzz2020.github.io/favicon.ico" type="image/x-icon" /><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"><meta name="description"content="温故而知新"><meta charset="UTF-8"><title>Java集合面试题总结 | xzzz2020</title>
<link href="https://xzzz2020.github.io/styles/main.css" type="text/css" rel="stylesheet" /><link href="https://at.alicdn.com/t/font_1621793_zatzzgvf30g.css" type="text/css" rel="stylesheet" /><link rel="stylesheet" href="https://xzzz2020.github.io/media/css/katex.css"><script async src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.min.js"></script><script src="https://xzzz2020.github.io/media/js/magnify.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script type="text/javascript">function btn_toggle(){document.getElementById("hn").classList.contains("no-js")?document.getElementById("hn").classList.remove("no-js"):document.getElementById("hn").classList.add("no-js")}</script>

<link rel="canonical" href="https://xzzz2020.github.io/post/D60cWKdQu/" />
</head>
<body>
<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://xzzz2020.github.io"><img alt="logo" style="display:inline-block;" src="https://xzzz2020.github.io/images/avatar.png"/></a><h1 title="xzzz2020" class="weaklink"><a  href="/">xzzz2020</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/Friendship_chain" class="selected active current nav__item" >友链</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div><div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/Friendship_chain" class="selected active current nav__item" >友链</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form" data-update="1595847222760" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

<div class="main"><div class="main-inner"><div class="content">
<article class="post">
<h2 class="post_title sm_margin"><a>Java集合面试题总结</a></h2>
<script>function lan(){if(document.getElementById("lan").innerText=="繁"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="简"}else{if(document.getElementById("lan").innerText=="簡"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="繁"}}};</script>
<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px"> 2020-07-03</span><i class="iconfont icon-browse"></i><span style="margin-right:15px"> <span id="busuanzi_value_page_pv"></span> Views</span><i class="iconfont icon-category"></i><span class="weaklink" style="margin-right:15px">	<a href="https://xzzz2020.github.io/tag/Interview_summary/" class="tag">面试总结</a></span><i class="iconfont icon-caret-down"></i><span style="margin-right:15px">4297字</span><i class="iconfont icon-naozhong"></i><span style="margin-right:15px">17 min read</span><a id="lan" href="javascript:void(0);"onclick="lan();"title="调整简繁体" style="margin-right:15px;">繁</a>
</section>

<img class="featureImg" alt="featureimg" src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/panorama-sunrise-dawn-bled-thumb.jpg" referrerpolicy="no-referrer">

<div style="display:flex">
<div class="md_block" id="md_block">
<div class="round-shape-one"></div>
<blockquote>
<p>该文章为面试精华版，如果是初学者，建议先从专栏学习：<a href="https://blog.csdn.net/qq_43040688/category_9692685.html">Java集合专栏</a></p>
</blockquote>
<p>[TOC]</p>
<h2 id="一-主要容器概述">一、 主要容器概述</h2>
<blockquote>
<p>注意Collection是一个接口，是List和Set的公共接口，Collections是一个工具类</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200710110409450.png" alt="image-20200710110409450" loading="lazy"></figure>
<p><strong>Java容器主要有三个</strong>：</p>
<ul>
<li><strong>List</strong>:是一个有序集合，可以放重复的数据</li>
<li><strong>Set</strong>:是一个无序集合，不允许放重复的数据</li>
<li><strong>Map</strong>:是一个无序集合，集合中包含一个键对象，-一个值对象，键对象不允许重复，值对象可以重复(身份证号-姓名)</li>
</ul>
<p><strong>size ()，length，length()区别？</strong></p>
<ul>
<li>size()是集合中使用，统计集合中元素的个数</li>
<li>length是数组的一个成员属性</li>
<li>length()是String的一个方法</li>
</ul>
<p><strong>Iterator</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean hasNext()</td>
<td>判断集合中是否还有下一个元素</td>
</tr>
<tr>
<td>Object next()</td>
<td>返回下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>从集合中删除一个由 next()方法返回的元素</td>
</tr>
</tbody>
</table>
<h2 id="二-list">二、 List</h2>
<ul>
<li><strong>ArrayList</strong>：查询数据比较快，添加和删除数据比较慢(基于可变数组)</li>
<li><strong>LinkedList</strong>：查询数据比较慢，添加和删除数据比较快（基于链表数据结构）</li>
</ul>
<h3 id="1-arraylist">1. ArrayList</h3>
<blockquote>
<p>查找比较快，增删比较慢</p>
</blockquote>
<ul>
<li>底层是基于数组。</li>
<li><strong>默认容量是10</strong></li>
<li><strong>每次扩容1.5倍</strong></li>
<li>如果增加 0.5 倍后的新容量超过限制的容量，则用所需的最小容量与限制的容量进行判断，超过则指定为 Integer 的最大值</li>
<li>通过数组的复制将原数据复制到一个更大(新的容量大小)的数组</li>
</ul>
<p><strong>如何保证线程安全？</strong></p>
<ul>
<li>继承ArrayList，重写其中的方法</li>
<li><code>List list = Collections.synchronizedList(new ArrayList());</code></li>
</ul>
<h3 id="2-linkedlist">2. LinkedList</h3>
<blockquote>
<p>增删比较快，查找比较慢</p>
</blockquote>
<ul>
<li>
<p>基于链表的，除了存放数据，还需要存放指针，所以<strong>占用的空间会大一些</strong></p>
</li>
<li>
<p>它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p>
</li>
<li>
<p>不是线程安全的</p>
</li>
</ul>
<h3 id="3-vector">3. Vector</h3>
<p>Vector与 ArrayList 一样，也是通过数组实现的，<strong>不同的是它支持线程的同步</strong>，即某一时刻只有一 个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p>
<h3 id="4-arraylist-与-linkedlist-异同">4. ArrayList 与 LinkedList 异同</h3>
<ul>
<li>
<p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p>
</li>
<li>
<p><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组； LinkedList 底层使用的是双向链表数据结构JDK1.6之前为循环链表， JDK1.7 取消了循环。注意双向链表和双向循环链表的区别：节约空间）；</p>
</li>
<li>
<p><strong>插入和删除是否受元素位置的影响</strong>：</p>
<ul>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 add(Ee) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
</ul>
</li>
<li>
<p>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</p>
</li>
<li>
<p><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。</p>
</li>
</ul>
<h3 id="5-arraylist和vector的区别">5. ArrayList和Vector的区别</h3>
<ul>
<li><strong>Vector 类的所有方法都是同步的</strong>。可以由两个线程安全地访问一个 Vector 对象、但是一个线程访问 Vector的话代码要在同步操作上耗费大量的时间。</li>
<li><strong>Arraylist 不是同步的</strong>，所以在不需要保证线程安全时时建议使用 ArrayList。【CopyOnWriteArrayList 是同步的】。</li>
<li><strong>扩容倍数不一样</strong>：Vector 每次扩容请求其大小的 2 倍空间 ，而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="6-systemarraycopy和-arrayscopyof">6. System.arraycopy()和 Arrays.copyOf()</h3>
<ol>
<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>
<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。</li>
</ol>
<h3 id="7-copyonwritearraylist">7. CopyOnWriteArrayList</h3>
<p><strong>是一种读写分离的结构</strong>：</p>
<ul>
<li>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</li>
<li>写操作需要加锁，防止并发写入时导致写入数据丢失。</li>
<li>写操作结束之后需要把原始数组指向新的复制数组。</li>
</ul>
<pre><code class="language-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
final void setArray(Object[] a) {
    array = a;
}
@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}
</code></pre>
<p><strong>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。但是 CopyOnWriteArrayList 有其缺陷</strong>:</p>
<ul>
<li><strong>内存占用</strong>：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li><strong>数据不一致</strong>：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</li>
</ul>
<h2 id="三-set">三、 Set</h2>
<p><strong>在Set家族中，常用的有三种</strong>：</p>
<ul>
<li><strong>HashSet</strong>: 采用 Hashmap 的 key 来储存元素，主要特点是无序的，基本操作都是 O(1) 的时间复杂度，很快。</li>
<li><strong>LinkedHashSet</strong>: 这个是一个 HashSet + LinkedList 的结构，特点就是既拥有了 O(1) 的时间复杂度，又能够保留插入的顺序。</li>
<li><strong>TreeSet</strong>: 采用红黑树结构，特点是可以有序，可以用自然排序或者自定义比较器来排序；缺点就是查询速度没有 HashSet 快。</li>
</ul>
<h3 id="1-哈希表">1. 哈希表</h3>
<p>哈希表是一种数据结构，哈希表能够提供快速存取操作。<strong>哈希表是基于数组的，所以也存在缺点，数</strong><br>
<strong>组一旦创建将不能扩展。</strong></p>
<p>正常的数组，如果需要查询某个值，需要对数组进行遍历，只是一种线性查找，查找的速度比较慢。<br>
如果数组中的元素值和下标能够存在明确的对应关系，那么<strong>通过数组元素的值就可以换算出数据元素的下</strong><br>
**标，通过下标就可以快数定位数组元素，这样的数组就是哈希表。**一张哈希表：</p>
<table>
<thead>
<tr>
<th>元素值</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><strong>以上我们的示例元素值和下标的关系为</strong>：</p>
<ul>
<li>
<p>元素下标=元素值-10，此时的示例 hashcode 就是和数组下标一致了,取得 hashcode 方法如下：</p>
<pre><code class="language-java">//取得 hashCode
pubic int hashCode(int value) {
	return value – 10;
}
</code></pre>
</li>
</ul>
<h3 id="2-hashset">2. HashSet</h3>
<ul>
<li>HashSet中的数据是无序的不可重复的。</li>
<li>采用 Hashmap 的 key 来储存元素</li>
</ul>
<h3 id="3-hashcode">3. hashCode()</h3>
<blockquote>
<p>覆盖了 equals 和 hashCode，当 hashCode 相同，它会调用 equals 进行比较，如果 equals 比较相等将不加把此元素加入到 Set 中</p>
<p>但 equals 比较不相等会重新根据 hashCode 换算位置仍然会将该元素加入进去的。</p>
</blockquote>
<p><strong>hashCode() 与 equals() 的相关规定</strong>：</p>
<ul>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li>因此， equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
<p><strong>再次强调：特别是向 HashSet 或 HashMap 中加入数据时必须同时覆盖 equals 和 hashCode 方法，应该</strong><br>
<strong>养成一种习惯覆盖 equals 的同时最好同时覆盖 hashCode</strong></p>
<p><strong>Java 要求</strong>：</p>
<ul>
<li>两个对象 equals 相等，那么它的 hashcode 相等</li>
<li>两个对象 equals 不相等，那么它的 hashcode 并不要求它不相等，但一般建议不相等hashcode 相等不代表两个对象相等（采用 equals 比较）</li>
</ul>
<p><strong>为什么重写 equals() 就必须要重写 hashCode()？</strong></p>
<ul>
<li>当key的hashCode()计算的数值相同时，就会出现hash冲突</li>
</ul>
<p><strong>处理 hash 冲突有哪些方法？Java 中用的哪一种？为什么？另一种方法你在工作中用过吗？在什么情况下用得多？</strong></p>
<p>见：<a href="https://xzzz2020.gitee.io/post/d0otbdSTy">https://xzzz2020.gitee.io/post/d0otbdSTy</a></p>
<h3 id="4-treeset">4. TreeSet</h3>
<ul>
<li>TreeSet 可以对 Set 集合进行排序， <strong>默认自然排序</strong>（即升序）</li>
<li>引用类型实现排序，需要实现Comparator或者Comparable</li>
</ul>
<p><strong>Comparable 和Comparator 的区别？</strong></p>
<ul>
<li>Comparable是自然排序，需要实体类实现，需要修改源代码</li>
<li>Comparator 是定制排序，不需要更改源代码，定义一个比较规则，传递给需要调用的方法中，将<strong>比较策略与数据分离，体现了策略模式</strong></li>
<li>Comparator 比Comparable 优先级更高</li>
</ul>
<h2 id="四-map">四、 Map</h2>
<blockquote>
<p>关于HashMap的全部面试题见：<a href="https://xzzz2020.gitee.io/post/hashmap">https://xzzz2020.gitee.io/post/hashmap</a></p>
</blockquote>
<p>Map 中可以放置键值对，也就是每一个元素都包含键对象和值对象， Map 实现较常用的为 HashMap，HashMap 对键对象的存取和 HashSet 一样，仍然采用的是哈希算法，所以如果使用自定类作为 Map 的键对象，必须复写 equals 和 hashCode 方法</p>
<p><strong>Map中常用的三个</strong>：</p>
<ul>
<li><strong>HashMap</strong>: 与 HashSet 对应，也是无序的，O(1)。</li>
<li><strong>LinkedHashMap</strong>: 这是一个「HashMap + 双向链表」的结构，落脚点是 HashMap，所以既拥有 HashMap 的所有特性还能有顺序。</li>
<li><strong>TreeMap</strong>: 是有序的，本质是用二叉搜索树来实现的。</li>
</ul>
<h3 id="1-hashmap">1. HashMap</h3>
<p><strong>实现原理</strong></p>
<ul>
<li>对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的</li>
<li>Hash函数跟HashMap的容量有关系</li>
</ul>
<p><strong>如果不同的元素的key算出了相同的哈希值，那么该怎么存放呢？</strong></p>
<ul>
<li>这就是哈希碰撞，即多个 key 对应了同一个桶。</li>
</ul>
<p><strong>HashMap 中是如何保证元素的唯一性的呢？即相同的元素会不会算出不同的哈希值呢？</strong></p>
<ul>
<li>通过 hashCode() 和 equals() 方法来保证元素的唯一性。</li>
</ul>
<h3 id="2-hashtable">2. HashTable</h3>
<blockquote>
<p>是一个线程安全的，但是锁住了全部数据效率低下</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-1302474103.cos.ap-nanjing.myqcloud.com/img/image-20200703101554984.png" alt="image-20200703101554984" loading="lazy"></figure>
<p><strong>HashMap 和 Hashtable 的区别 ?</strong></p>
<ol>
<li><strong>线程是否安全</strong>： HashMap 是非线程安全的， HashTable 是线程安全的； HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率</strong>：因为线程安全的问题， HashMap 要比 HashTable 效率高一点。另外， HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持</strong>： HashMap 中， null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>HashMap 的迭代器是 fail-fast 迭代器，HashTable是用的Enumeration（枚举）的迭代器</strong></li>
<li><strong>初始容量大小和每次扩充容量大小的不同</strong>：<br>
①创建时如果不指定容量初始值， Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<br>
HashMap 默认的初始化大小为 16。 之后每次扩充，容量变为原来的 2 倍。<br>
②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2的幂次方大小（HashMap 中的 tableSizeFor() 方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默<br>
认为 8）时，将链表转化为红黑树，以减少搜索时间。 Hashtable 没有这样的机制。</li>
</ol>
<h3 id="3-linkedhashmap">3. LinkedHashMap</h3>
<p>保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序 。</p>
<ul>
<li>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序</li>
</ul>
<p><strong>如何实现LRU 缓存 ？</strong></p>
<p><strong>构造方法提供了一个参数accessOrder，默认是false，表示按照插入顺序</strong>：</p>
<pre><code class="language-java">    public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
</code></pre>
<p>而当accessOrder 为true时，表示按照访问顺序，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除， MAX_ENTRIES默认为3</p>
<p><strong>需要继承LinkedHashMap，并且覆盖 removeEldestEntry() 方法实现</strong> ：</p>
<pre><code class="language-java">class LRUCache&lt;k,v&gt; extends LinkedHashMap&lt;k,v&gt; {
    private final static int MAX_CACHE_SIZE = 100;

    private final int limitCacheSize;

    public LRUCache() {
        this(MAX_CACHE_SIZE);
    }


    public LRUCache(int cacheSize){
        super(cacheSize, 0.75f, true);
        this.limitCacheSize = cacheSize;
    }

    /**
     * 判断什么时候删除缓存
     */
    @Override
    protected boolean removeEldestEntry(Map.Entry&lt;k, v&gt; eldest) {
        return this.size()&gt;this.limitCacheSize;
    }


}
</code></pre>
<h2 id="五-collections常用方法">五、 Collections常用方法</h2>
<h3 id="排序">排序</h3>
<pre><code class="language-java">void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由 Comparator 控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当 distance 为正数时，将 list 后 distance 个元素整体移到前面。当 distance 为负数时，将 list 的前 distance 个元素整体移到后面。  
</code></pre>
<h3 id="查找替换操作">查找,替换操作</h3>
<pre><code class="language-java">int binarySearch(List list, Object key)//对 List 进行二分查找，返回索引，注意 List 必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。
int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由 Comparatator 类控制。
int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定 list 中
所有元素。 int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计 target 在 list 中第一次出现的索引，找不到则返回-1，
int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素  
</code></pre>
<h3 id="同步控制">同步控制</h3>
<p>Collections 提供了多个 synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决多<br>
线程并发访问集合时的线程安全问题。</p>
<p>我们知道 HashSet， TreeSet， ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。 Collections 提供了多个静态方法可以把他们包装成线程同步的集合</p>
<pre><code class="language-java">synchronizedCollection(Collection&lt;T&gt; c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List&lt;T&gt; list) //返回指定列表支持的同步（线程安全的） List。
synchronizedMap(Map&lt;K,V&gt; m) //返回由指定映射支持的同步（线程安全的） Map。
synchronizedSet(Set&lt;T&gt; s) //返回指定 set 支持的同步（线程安全的） set。
</code></pre>
<h3 id="设置不可变集合">设置不可变集合</h3>
<p><strong>emptyXxx()</strong>： 返回一个空的、不可变的集合对象，此处的集合既可以是 List，也可以是 Set，还可以是 Map。</p>
<p><strong>singletonXxx()</strong>： 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以<br>
是： List， Set， Map。</p>
<p><strong>unmodifiableXxx()</strong>： 返回指定集合对象的不可变视图，此处的集合可以是： List， Set， Map。 上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本</p>
<h2 id="六-fail-fast-和-fail-safe">六、Fail-Fast 和 Fail-Safe</h2>
<ul>
<li>
<p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p>
</li>
<li>
<p>java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。</p>
</li>
<li>
<p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
</li>
</ul>
<h3 id="快速失败原理">快速失败原理</h3>
<ul>
<li>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
</li>
<li>
<p>在进行序列化或者迭代或者remove()等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出<br>
ConcurrentModificationException。</p>
</li>
</ul>
<pre><code class="language-java">    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();
        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);
        // Write out all elements in the proper order.
        for (int i = 0; i &lt; size; i++) {
            s.writeObject(elementData[i]);
        }
        if(modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
</code></pre>
<h3 id="解决fail-fast的原理">解决fail-fast的原理</h3>
<p>在返回一个迭代器的时候，拷贝数据，因此，对容器内容的修改不影响遍历。</p>
<pre><code class="language-java">private COWIterator(Object[] elements, int initialCursor) {
    cursor = initialCursor;
    snapshot = elements;
}
</code></pre>
<ul>
<li>常见的的使用fail-safe方式遍历的容器有<strong>ConcerrentHashMap</strong>和<strong>CopyOnWriteArrayLis</strong>t等。</li>
</ul>

<span id="footnote"></span>
<div id = "warn"></div>
</div>
<div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E4%B8%BB%E8%A6%81%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0">一、 主要容器概述</a></li>
<li><a href="#%E4%BA%8C-list">二、 List</a>
<ul>
<li><a href="#1-arraylist">1. ArrayList</a></li>
<li><a href="#2-linkedlist">2. LinkedList</a></li>
<li><a href="#3-vector">3. Vector</a></li>
<li><a href="#4-arraylist-%E4%B8%8E-linkedlist-%E5%BC%82%E5%90%8C">4. ArrayList 与 LinkedList 异同</a></li>
<li><a href="#5-arraylist%E5%92%8Cvector%E7%9A%84%E5%8C%BA%E5%88%AB">5. ArrayList和Vector的区别</a></li>
<li><a href="#6-systemarraycopy%E5%92%8C-arrayscopyof">6. System.arraycopy()和 Arrays.copyOf()</a></li>
<li><a href="#7-copyonwritearraylist">7. CopyOnWriteArrayList</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-set">三、 Set</a>
<ul>
<li><a href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8">1. 哈希表</a></li>
<li><a href="#2-hashset">2. HashSet</a></li>
<li><a href="#3-hashcode">3. hashCode()</a></li>
<li><a href="#4-treeset">4. TreeSet</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-map">四、 Map</a>
<ul>
<li><a href="#1-hashmap">1. HashMap</a></li>
<li><a href="#2-hashtable">2. HashTable</a></li>
<li><a href="#3-linkedhashmap">3. LinkedHashMap</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-collections%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">五、 Collections常用方法</a>
<ul>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C">查找,替换操作</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6">同步控制</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88">设置不可变集合</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-fail-fast-%E5%92%8C-fail-safe">六、Fail-Fast 和 Fail-Safe</a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E5%8E%9F%E7%90%86">快速失败原理</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3fail-fast%E7%9A%84%E5%8E%9F%E7%90%86">解决fail-fast的原理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="fullPage"><canvas id="canvas"></canvas></div>
</article>
<div id="eof"><span>EOF</span></div><div class="round-shape-one"></div>
<section>
<div class="doc_comments">

	  
		<div id="gitalk-container"></div>
		<!--评论显示区，请插入合适的位置-->
<div id="comment"></div>
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.6.1/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<script>
    new Valine({
        el:'#comment',
        appId: 'DysN4QrSvmmE6SpDXopbCLD6-gzGzoHsz',
        appKey: 'mjK643yLFa4WWXtobofr24Ap',
        placeholder: 'ヾﾉ≧∀≦)o快来评论一下吧!',
        avatar:''
    });
</script>
	  
		  
	  

</div></section>
</div></div></div>
<!--
<script>
"use strict";!function(){for(var n=document.getElementsByTagName("pre"),e=n.length,s=0;s<e;s++){n[s].innerHTML='<span class="line-number"></span>'+n[s].innerHTML+'<span class="cl"></span>';for(var a=n[s].innerHTML.split(/\n/).length,r=0;r<a-1;r++){n[s].getElementsByTagName("span")[0].innerHTML+="<span>"+(r+1)+"</span>"}}}();
let mainNavLinks=document.querySelectorAll(".markdownIt-TOC a");window.addEventListener("scroll",event=>{let fromTop=window.scrollY;mainNavLinks.forEach((link,index)=>{let section=document.getElementById(decodeURI(link.hash).substring(1));let nextSection=null
if(mainNavLinks[index+1]){nextSection=document.getElementById(decodeURI(mainNavLinks[index+1].hash).substring(1));}
if(section.offsetTop<=fromTop){if(nextSection){if(nextSection.offsetTop>fromTop){link.classList.add("currentToc");}else{link.classList.remove("currentToc");}}else{link.classList.add("currentToc");}}else{link.classList.remove("currentToc");}});});
var list=document.querySelectorAll(".katex");for(var i=0;i<list.length;i++){list[i].style.display="unset"};
var h=document.documentElement,b=document.body,st="scrollTop",sh="scrollHeight",progress=document.querySelector(".progress"),scroll;document.addEventListener("scroll",function(){scroll=(h[st]||b[st])/((h[sh]||b[sh])-h.clientHeight)*100;progress.style.setProperty("--scroll",scroll+"%")});
var wxScale=new WxScale({fullPage:document.querySelector("#fullPage"),canvas:document.querySelector("#canvas")});var imgBox=document.querySelectorAll("#md_block img");for(var i=0;i<imgBox.length;i++){imgBox[i].onclick=function(e){wxScale.start(this)}};
content="本文最后更新于2020-07-03，已超过 1 年没有更新，涉及的内容可能已经失效！";var date1="2020-07-03 11:27:44";date1=date1.replace("-","/");var date2=new Date();var date3=date2.getTime()-new Date(date1).getTime();var days=Math.floor(date3/(24*3600*1000));if(days>=365){document.getElementById("warn").innerHTML=content};
</script>
-->

<script>
    "use strict";
    ! function () {
        for (var n = document.getElementsByTagName("pre"), e = n.length, s = 0; s < e; s++) {
            n[s].innerHTML = '<span class="line-number"></span>' + n[s].innerHTML + '<span class="cl"></span>';
            for (var a = n[s].innerHTML.split(/\n/).length, r = 0; r < a - 1; r++) {
                n[s].getElementsByTagName("span")[0].innerHTML += "<span>" + (r + 1) + "</span>"
            }
        }
    }();
    let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
    window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;
        mainNavLinks.forEach((link, index) => {
            let section = document.getElementById(decodeURI(link.hash).substring(1));
            let nextSection = null
            if (mainNavLinks[index + 1]) {
                nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(
                    1));
            }
            if (section.offsetTop <= fromTop) {
                if (nextSection) {
                    if (nextSection.offsetTop > fromTop) {
                        link.classList.add("currentToc");
                    } else {
                        link.classList.remove("currentToc");
                    }
                } else {
                    link.classList.add("currentToc");
                }
            } else {
                link.classList.remove("currentToc");
            }
        });
    });
    var list = document.querySelectorAll(".katex");
    for (var i = 0; i < list.length; i++) {
        list[i].style.display = "unset"
    };
    var h = document.documentElement,
        b = document.body,
        st = "scrollTop",
        sh = "scrollHeight",
        progress = document.querySelector(".progress"),
        scroll;
    document.addEventListener("scroll", function () {
        scroll = (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100;
        progress.style.setProperty("--scroll", scroll + "%")
    });
    var wxScale = new WxScale({
        fullPage: document.querySelector("#fullPage"),
        canvas: document.querySelector("#canvas")
    });
    var imgBox = document.querySelectorAll("#md_block img");
    for (var i = 0; i < imgBox.length; i++) {
        imgBox[i].onclick = function (e) {
            wxScale.start(this)
        }
    };
    content = "本文最后更新于2020-07-03，已超过 1 年没有更新，涉及的内容可能已经失效！";
    var date1 = "2020-07-03 11:27:44";
    date1 = date1.replace("-", "/");
    var date2 = new Date();
    var date3 = date2.getTime() - new Date(date1).getTime();
    var days = Math.floor(date3 / (24 * 3600 * 1000));
    if (days >= 365) {
        document.getElementById("warn").innerHTML = content
    };
</script>

<style>#magnifyImg{position:fixed;left:0;top:0;text-align:center;width:100%;display:none;z-index:9999}#magnifyImg img{object-fit:contain;background:#eaecef;padding:15px;border-radius:10px;height:auto;width:auto;vertical-align:middle}</style>
<a id="scrollUp" href="#top" style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"></div></div><div class="copyright"id="copyright">Copyright © 2018-2020 <a href="https://xzzz2020.github.io" style="margin:0;">xzzz2020</a>.</div>
<span style="display: inline;margin-right:15px;">👁<strong><span id="busuanzi_value_site_pv"></span></strong></span><span id="busuanzi_container_page_pv" style="display: inline;"><span>📚<strong>50</strong> posts</span></div></div>
<script>
console.log("\n %c \u26a1Theme: Bitcron-pro Author's Blog:https://blog.blinkstar.cn  Writen By Serence  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;", );
</script>
<script src="https://cdn.jsdelivr.net/npm/instant.page@3.0.0/instantpage.min.js" type="module" defer></script>
<script type="text/javascript" async src="https://xzzz2020.github.io/media/js/prism.js"></script>
</body>
</html>